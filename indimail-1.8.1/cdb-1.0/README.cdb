What is it?

cdb is a fast, reliable, simple package for creating and reading constant databases. Its database structure provides several features:

    * Fast lookups: A successful lookup in a large database normally takes just two disk accesses. An unsuccessful
      lookup takes only one.
    * Low overhead: A database uses 2048 bytes, plus 24 bytes per record, plus the space for keys and data.
    * No random limits: cdb can handle any database up to 4 gigabytes. There are no other restrictions; records don't even
      have to fit into memory. Databases are stored in a machine-independent format.
    * Fast atomic database replacement: cdbmake can rewrite an entire database two orders of magnitude faster than other
      hashing packages.
    * Fast database dumps: cdbdump prints the contents of a database in cdbmake-compatible format. 

cdb is designed to be used in mission-critical applications like e-mail. Database replacement is safe against system crashes.
Readers don't have to pause during a rewrite. 

cdb was written by D.J Bernstein (I have just converted this into GNU autotool package). Any mistakes would be mine

http://cr.yp.to/cdb.html

A structure for constant databases
19960914
Copyright 1996
D. J. Bernstein

A cdb is an associative array: it maps strings (``keys'') to strings
(``data'').

A cdb contains 256 pointers to linearly probed open hash tables. The
hash tables contain pointers to (key,data) pairs. A cdb is stored in
a single file on disk:

    +----------------+---------+-------+-------+-----+---------+
    | p0 p1 ... p255 | records | hash0 | hash1 | ... | hash255 |
    +----------------+---------+-------+-------+-----+---------+

Each of the 256 initial pointers states a position and a length. The
position is the starting byte position of the hash table. The length
is the number of slots in the hash table.

Records are stored sequentially, without special alignment. A record
states a key length, a data length, the key, and the data.

Each hash table slot states a hash value and a byte position. If the
byte position is 0, the slot is empty. Otherwise, the slot points to
a record whose key has that hash value.

Positions, lengths, and hash values are 32-bit quantities, stored in
little-endian form in 4 bytes. Thus a cdb must fit into 4 gigabytes.

A record is located as follows. Compute the hash value of the key in
the record. The hash value modulo 256 is the number of a hash table.
The hash value divided by 256, modulo the length of that table, is a
slot number. Probe that slot, the next higher slot, and so on, until
you find the record or run into an empty slot.

The cdb hash function is ``h = ((h << 5) + h) ^ c'', with a starting
hash of 5381.

The cdb-reading library interface
Overview
You can read records in a constant database from file descriptor fd as follows:

   1. Use cdb_init to place information about fd into a struct cdb variable c.
   2. Carry out any number of searches, as described below.
   3. Use cdb_free to remove any memory map that might have been reserved by cdb_init. 

 Each search works as follows:

   1. Use cdb_find to search for a record under key k. If cdb_find returns 0, the database does not contain that key; stop. If cdb_find returns -1, there was a read error; abort.
   2. Use cdb_datalen to find the number of bytes of data in this record. Allocate a pointer d to a region of memory large enough to hold the data. If not enough memory is available, abort.
   3. Use cdb_read with cdb_datapos to read the data. If cdb_read returns -1, there was a read error; abort.
   4. Do something with the data, and then free the allocated region of memory. 

 There may be several records under a single key. You can use cdb_findnext to find the next record under this key.
 Details

   #include <cdb.h>

   cdb_init(&c,fd);
   cdb_free(&c);
   result = cdb_read(&c,d,dlen,dpos);

   cdb_findstart(&c);
   result = cdb_findnext(&c,k,klen);
   result = cdb_find(&c,k,klen);

   dpos = cdb_datapos(&c);
   dlen = cdb_datalen(&c);

   static struct cdb c;
   int fd;

   char *d;
   unsigned int dlen;
   uint32 dpos;

   char *k;
   unsigned int klen;
   int result;

  A struct cdb variable such as c is either unallocated or allocated. If it is allocated, it holds information about
  a constant database:

   * a file descriptor fd reading from the database;
   * if convenient, a shared memory map reading from the database; and
   * information about a search in progress. 

  c must be initialized to zero, meaning unallocated.

  cdb_free unallocates c if c is allocated. Otherwise it leaves c alone. cdb_free does not close fd.

  cdb_init allocates c to hold information about a constant database read by descriptor fd. You may call cdb_init repeatedly;
  if c is already allocated, cdb_init unallocates it first.

  cdb_read reads dlen bytes into d from byte position dpos in the database. You must allocate c before calling cdb_read.
  Normally cdb_read returns 0. If the database file is shorter than dpos+dlen bytes, or if there is a disk read error,
  cdb_read returns -1, setting errno appropriately.

  cdb_findstart prepares c to search for the first record under a new key. You must allocate c before calling cdb_findstart,
  and you must call cdb_findstart before calling cdb_findnext.

  cdb_findnext looks for the nth record under key k in the database, where n is the number of calls to cdb_findnext after
  the most recent call to cdb_findstart. If it finds the record, cdb_findnext returns 1; if there are exactly n-1 such records,
  cdb_findnext returns 0; if there are fewer than n-1 such records, the behavior of cdb_findnext is undefined; if there is a
  database format error or disk error, cdb_findnext returns -1, setting errno appropriately. Each call to cdb_findnext
  (before another call to cdb_findstart) must use the same k and klen.

  If cdb_findnext returns 1, it arranges for cdb_datapos to return the starting byte position of the data in the record,
  and for cdb_datalen to return the number of bytes of data in the record. Otherwise the results of cdb_datapos and cdb_datalen
  are undefined.

  cdb_find is the same as cdb_findstart followed by cdb_findnext: it finds the first record under key k.

  Beware that these functions may rely on non-atomic operations on the fd ofile, such as seeking to a particular position and
  then reading. Do not attempt two simultaneous database reads using a single ofile. 
