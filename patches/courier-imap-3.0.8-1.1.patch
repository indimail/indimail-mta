diff -Naur Courier-imap-3.0.8/authlib/authlib.7.in courier-imap-3.0.8/authlib/authlib.7.in
--- Courier-imap-3.0.8/authlib/authlib.7.in	2004-07-13 05:15:30.000000000 +0530
+++ courier-imap-3.0.8/authlib/authlib.7.in	2009-05-30 20:58:20.000000000 +0530
@@ -107,7 +107,7 @@
 \fBuserdb\fR(8) database.
 .TP
 \fBauthvchkpw\fR
-supports existing vpopmail/vchkpw
+supports existing indimail/vchkpw
 virtual domains.
 .TP
 \fBauthcram\fR
diff -Naur Courier-imap-3.0.8/authlib/authlib.html.in courier-imap-3.0.8/authlib/authlib.html.in
--- Courier-imap-3.0.8/authlib/authlib.html.in	2004-09-03 06:50:34.000000000 +0530
+++ courier-imap-3.0.8/authlib/authlib.html.in	2009-05-30 20:58:20.000000000 +0530
@@ -311,7 +311,7 @@
 ><P
 >supports existing <TT
 CLASS="LITERAL"
->vpopmail/vchkpw</TT
+>indimail/vchkpw</TT
 >
 virtual domains.</P
 ></DD
@@ -1969,4 +1969,4 @@
 ></DIV
 ></BODY
 ></HTML
->
\ No newline at end of file
+>
diff -Naur Courier-imap-3.0.8/authlib/authmoduser3.c courier-imap-3.0.8/authlib/authmoduser3.c
--- Courier-imap-3.0.8/authlib/authmoduser3.c	2002-10-01 08:30:12.000000000 +0530
+++ courier-imap-3.0.8/authlib/authmoduser3.c	2009-06-04 00:39:04.000000000 +0530
@@ -3,13 +3,13 @@
 ** distribution information.
 */
 
-#include	"auth.h"
-#include	"authmod.h"
-#include	"debug.h"
 #include	<stdio.h>
 #include	<string.h>
 #include	<stdlib.h>
 #include	<ctype.h>
+#include	"auth.h"
+#include	"authmod.h"
+#include	"debug.h"
 
 static const char rcsid[]="$Id: authmoduser3.c,v 1.4 2002/10/01 03:00:12 mrsam Exp $";
 
diff -Naur Courier-imap-3.0.8/authlib/authstaticlistsearch.c courier-imap-3.0.8/authlib/authstaticlistsearch.c
--- Courier-imap-3.0.8/authlib/authstaticlistsearch.c	2004-06-09 04:14:17.000000000 +0530
+++ courier-imap-3.0.8/authlib/authstaticlistsearch.c	2009-06-04 00:16:45.000000000 +0530
@@ -3,10 +3,8 @@
 ** distribution information.
 */
 
-#include	"auth.h"
-#include	"authstaticlist.h"
-#include	"debug.h"
 #include	<stdio.h>
+#include	<fcntl.h>
 #include	<errno.h>
 #include	<ctype.h>
 #include	<stdlib.h>
@@ -17,6 +15,9 @@
 #if	HAVE_UNISTD_H
 #include	<unistd.h>
 #endif
+#include	"auth.h"
+#include	"authstaticlist.h"
+#include	"debug.h"
 
 static const char rcsid[]="$Id: authstaticlistsearch.c,v 1.7 2004/05/09 03:32:01 mrsam Exp $";
 
diff -Naur Courier-imap-3.0.8/authlib/authtest.c courier-imap-3.0.8/authlib/authtest.c
--- Courier-imap-3.0.8/authlib/authtest.c	2004-06-09 04:14:18.000000000 +0530
+++ courier-imap-3.0.8/authlib/authtest.c	2009-06-04 09:30:43.000000000 +0530
@@ -3,11 +3,6 @@
 ** distribution information.
 */
 
-#include	"auth.h"
-#include	"authmod.h"
-#include	"authstaticlist.h"
-#include	"authsasl.h"
-#include	"debug.h"
 #include	<stdio.h>
 #include	<stdlib.h>
 #include	<string.h>
@@ -15,6 +10,11 @@
 #if	HAVE_UNISTD_H
 #include	<unistd.h>
 #endif
+#include	"auth.h"
+#include	"authmod.h"
+#include	"authstaticlist.h"
+#include	"authsasl.h"
+#include	"debug.h"
 
 static const char rcsid[]="$Id: authtest.c,v 1.11 2004/04/20 01:34:44 mrsam Exp $";
 
diff -Naur Courier-imap-3.0.8/authlib/debug.c courier-imap-3.0.8/authlib/debug.c
--- Courier-imap-3.0.8/authlib/debug.c	2004-06-09 04:14:18.000000000 +0530
+++ courier-imap-3.0.8/authlib/debug.c	2009-06-04 08:16:48.000000000 +0530
@@ -3,13 +3,13 @@
 ** distribution information.
 */
 
-#include "auth.h"
-#include "debug.h"
+#include <stdio.h>
 #include <ctype.h>
 #include <stdarg.h>
-#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include "auth.h"
+#include "debug.h"
 
 static const char rcsid[]="$Id: debug.c,v 1.5 2004/05/09 02:52:23 mrsam Exp $";
 
diff -Naur Courier-imap-3.0.8/authlib/mod.h courier-imap-3.0.8/authlib/mod.h
--- Courier-imap-3.0.8/authlib/mod.h	2004-06-09 04:14:18.000000000 +0530
+++ courier-imap-3.0.8/authlib/mod.h	2009-06-04 08:44:34.000000000 +0530
@@ -3,12 +3,12 @@
 ** distribution information.
 */
 
-#include	"auth.h"
-#include	"authmod.h"
-#include	"debug.h"
 #include	<stdio.h>
 #include	<stdlib.h>
 #include	<errno.h>
+#include	"auth.h"
+#include	"authmod.h"
+#include	"debug.h"
 
 extern char *MODULE(const char *, const char *, char *, int,
 	void (*)(struct authinfo *, void *), void *);
diff -Naur Courier-imap-3.0.8/authlib/authmod.c courier-imap-3.0.8/authlib/authmod.c
--- Courier-imap-3.0.8/authlib/authmod.c	2001-11-29 08:27:15.000000000 +0530
+++ courier-imap-3.0.8/authlib/authmod.c	2009-05-30 20:58:20.000000000 +0530
@@ -7,6 +7,7 @@
 #include	"authmod.h"
 #include	"authwait.h"
 #include	<stdio.h>
+#include	<errno.h>
 #include	<string.h>
 #include	<stdlib.h>
 #include	<signal.h>
diff -Naur Courier-imap-3.0.8/authlib/authpam.c courier-imap-3.0.8/authlib/authpam.c
--- Courier-imap-3.0.8/authlib/authpam.c	2004-06-09 04:14:17.000000000 +0530
+++ courier-imap-3.0.8/authlib/authpam.c	2009-05-30 20:58:20.000000000 +0530
@@ -1,7 +1,7 @@
 /*
-** Copyright 1998 - 2001 Double Precision, Inc.  See COPYING for
-** distribution information.
-*/
+ * Copyright 1998 - 2001 Double Precision, Inc.  See COPYING for
+ * distribution information.
+ */
 
 #if	HAVE_CONFIG_H
 #include	"config.h"
@@ -28,29 +28,25 @@
 #include	<Pam/pam_appl.h>
 #endif
 
-static const char rcsid[]="$Id: authpam.c,v 1.17 2004/04/18 15:54:38 mrsam Exp $";
+static const char rcsid[] = "$Id: authpam.c,v 1.17 2004/04/18 15:54:38 mrsam Exp $";
 
 static const char *pam_username, *pam_password, *pam_service;
 
-extern void auth_pwd_enumerate( void(*cb_func)(const char *name,
-					       uid_t uid,
-					       gid_t gid,
-					       const char *homedir,
-					       const char *maildir,
-					       void *void_arg),
-				void *void_arg);
+extern void    auth_pwd_enumerate(void (*cb_func)
+				   (const char *name, uid_t uid, gid_t gid, const char *homedir, const char *maildir, void *void_arg),
+				   void *void_arg);
 
-static int pam_conv(int num_msg, const struct pam_message **msg,
-                    struct pam_response **resp, void *appdata_ptr)
+static int
+pam_conv(int num_msg, const struct pam_message **msg, struct pam_response **resp, void *appdata_ptr)
 {
-int i = 0;
-struct pam_response *repl = NULL;
+	int             i = 0;
+	struct pam_response *repl = NULL;
 
-	repl = malloc(sizeof(struct pam_response) * num_msg);
-	if (!repl) return PAM_CONV_ERR;
-
-	for (i=0; i<num_msg; i++)
-		switch (msg[i]->msg_style) {
+	if (!(repl = malloc(sizeof(struct pam_response) * num_msg)))
+		return PAM_CONV_ERR;
+	for (i = 0; i < num_msg; i++)
+		switch (msg[i]->msg_style)
+		{
 		case PAM_PROMPT_ECHO_ON:
 			repl[i].resp_retcode = PAM_SUCCESS;
 			repl[i].resp = strdup(pam_username);
@@ -77,58 +73,61 @@
 			repl[i].resp = NULL;
 			break;
 		default:
-			free (repl);
+			free(repl);
 			return PAM_CONV_ERR;
 		}
 
-	*resp=repl;
+	*resp = repl;
 	return PAM_SUCCESS;
 }
 
 static struct pam_conv conv = {
-          pam_conv,
-          NULL
-      };
+	pam_conv,
+	NULL
+};
 
-static int dopam(pam_handle_t **pamh)
+static int
+dopam(pam_handle_t ** pamh)
 {
-int	retval;
+	int             retval;
 
-	dprintf("pam_service=%s, pam_username=%s",
-		pam_service ? pam_service : "<null>",
-		pam_username ? pam_username : "<null>");
+	dprintf("pam_service=%s, pam_username=%s", pam_service ? pam_service : "<null>", pam_username ? pam_username : "<null>");
 
-	retval=pam_start(pam_service, pam_username, &conv, pamh);
-	if (retval != PAM_SUCCESS) dprintf("pam_start failed, result %d [Hint: bad PAM configuration?]", retval);
+	retval = pam_start(pam_service, pam_username, &conv, pamh);
+	if (retval != PAM_SUCCESS)
+		dprintf("pam_start failed, result %d [Hint: bad PAM configuration?][%s]", retval, pam_strerror(*pamh, retval));
 
 #if 0
 	if (retval == PAM_SUCCESS)
 	{
-		retval=pam_set_item(*pamh, PAM_AUTHTOK, pam_password);
-		if (retval != PAM_SUCCESS) dprintf("pam_set_item failed, result %d", retval);
+		retval = pam_set_item(*pamh, PAM_AUTHTOK, pam_password);
+		if (retval != PAM_SUCCESS)
+			dprintf("pam_set_item failed, result %d", retval);
 	}
 #endif
 
 	if (retval == PAM_SUCCESS)
 	{
-		retval=pam_authenticate(*pamh, 0);
-		if (retval != PAM_SUCCESS) dprintf("pam_authenticate failed, result %d", retval);
+		retval = pam_authenticate(*pamh, 0);
+		if (retval != PAM_SUCCESS)
+			dprintf("pam_authenticate: %s", pam_strerror(*pamh, retval));
 	}
-
 #if 0
 
 #if	HAVE_PAM_SETCRED
 	if (retval == PAM_SUCCESS)
 	{
-		retval=pam_setcred(*pamh, PAM_ESTABLISH_CRED);
-		if (retval != PAM_SUCCESS) dprintf("pam_setcred failed, result %d", retval);
+		retval = pam_setcred(*pamh, PAM_ESTABLISH_CRED);
+		if (retval != PAM_SUCCESS)
+			dprintf("pam_setcred failed, result %d", retval);
 	}
 #endif
 
 	if (retval == PAM_SUCCESS)
 	{
-		retval=pam_acct_mgmt(*pamh, 0);
-		if (retval != PAM_SUCCESS) dprintf("pam_acct_mgmt failed, result %d", retval);
+		retval = pam_acct_mgmt(*pamh, 0);
+		if (retval != PAM_SUCCESS)
+			dprintf("pam_acct_mgmt failed, result %d", retval);
 	}
 #endif
 	if (retval == PAM_SUCCESS)
@@ -137,80 +136,77 @@
 	return (retval);
 }
 
-struct callback_info {
-	char *username;
-	int issession;
-	void (*callback_func)(struct authinfo *, void *);
-	void *callback_arg;
-	} ;
+struct callback_info
+{
+	char           *username;
+	int             issession;
+	void            (*callback_func) (struct authinfo *, void *);
+	void           *callback_arg;
+};
 
-static int callback_pam(struct authinfo *a, void *argptr)
+static int
+callback_pam(struct authinfo *a, void *argptr)
 {
-struct callback_info *ci=(struct callback_info *)argptr;
-pam_handle_t	*pamh=NULL;
-int	pipefd[2];
-int	retval;
-pid_t	p;
-int	waitstat;
-char	*s;
+	struct callback_info *ci = (struct callback_info *) argptr;
+	pam_handle_t   *pamh = NULL;
+	int             pipefd[2];
+	int             retval;
+	pid_t           p;
+	int             waitstat;
+	char           *s;
 
-	s=strdup(a->sysusername);
+	s = strdup(a->sysusername);
 	if (!s)
 	{
 		perror("malloc");
 		return (1);
 	}
 
-	if (!ci->issession &&	/* Thankfully, no session voodoo needed this time */
+	if (!ci->issession &&		/* Thankfully, no session voodoo needed this time */
 		ci->callback_func == 0)
 	{
-		retval=dopam(&pamh);
+		retval = dopam(&pamh);
 
 		if (retval == PAM_SUCCESS)
 		{
 			if (pam_end(pamh, retval) != PAM_SUCCESS)
-				perror("Unable to release PAM tokens");
+				dprintf("pam_end: %s", pam_strerror(pamh, retval));
 			if (ci->callback_func == 0)
-				authsuccess(a->homedir,
-					    s,
-					    0,
-					    &a->sysgroupid,
-					    a->address,
-					    a->fullname);
+				authsuccess(a->homedir, s, 0, &a->sysgroupid, a->address, a->fullname);
 
-			ci->username=s;
+			ci->username = s;
 			putenv("MAILDIR=");
 			return (0);
 		}
 		free(s);
 		if (pam_end(pamh, retval) != PAM_SUCCESS)
-			perror("Unable to release PAM tokens");
+			dprintf("pam_end: %s", pam_strerror(pamh, retval));
 		return (-1);
 	}
 
 /*
-**	OK, in order to transparently support PAM sessions inside this
-**	authentication module, what we need to do is to fork(), and let
-**	the child run in its parent place.  Once the child process exits,
-**	the parent calls pam_end_session, and clears the PAM library.
-**
-**	This means that upon return from auth_pam(), your process ID
-**	might've changed!!!
-**
-**	However, if the authentication fails, we can simply exit, without
-**	running as a child process.
-**
-**	Additionally, the PAM library might allocate some resources that
-**	authenticated clients should not access.  Therefore, we fork
-**	*before* we try to authenticate.  If the authentication succeeds,
-**	the child process will run in the parent's place.  The child
-**	process waits until the parent tells it whether the authentication
-**	worked.  If it worked, the child keeps running.  If not, the child
-**	exits, which the parent waits for.
-**
-**	The authentication status is communicated to the child process via
-**	a pipe.
-*/
+ * OK, in order to transparently support PAM sessions inside this
+ * authentication module, what we need to do is to fork(), and let
+ * the child run in its parent place.  Once the child process exits,
+ * the parent calls pam_end_session, and clears the PAM library.
+ *
+ * This means that upon return from auth_pam(), your process ID
+ * might've changed!!!
+ *
+ * However, if the authentication fails, we can simply exit, without
+ * running as a child process.
+ *
+ * Additionally, the PAM library might allocate some resources that
+ * authenticated clients should not access.  Therefore, we fork
+ * *before* we try to authenticate.  If the authentication succeeds,
+ * the child process will run in the parent's place.  The child
+ * process waits until the parent tells it whether the authentication
+ * worked.  If it worked, the child keeps running.  If not, the child
+ * exits, which the parent waits for.
+ *
+ * The authentication status is communicated to the child process via
+ * a pipe.
+ */
 	if (pipe(pipefd) < 0)
 	{
 		perror("pipe");
@@ -218,7 +214,7 @@
 		return (1);
 	}
 
-	if ((p=fork()) == -1)
+	if ((p = fork()) == -1)
 	{
 		perror("fork");
 		free(s);
@@ -227,12 +223,12 @@
 
 	if (p == 0)
 	{
-	char	dummy;
+		char            dummy;
 
 		if (ci->callback_func)	/* PAM memory leak */
 		{
 			close(pipefd[0]);
-			retval=dopam(&pamh);
+			retval = dopam(&pamh);
 			if (retval == PAM_SUCCESS)
 				write(pipefd[1], "", 1);
 			close(pipefd[1]);
@@ -242,28 +238,23 @@
 		close(pipefd[1]);
 
 		if (read(pipefd[0], &dummy, 1) != 1 || dummy)
-			authexit(1);	/* Authentication failed by parent */
+			authexit(1);		/* Authentication failed by parent */
 		close(pipefd[0]);
 
 		putenv("MAILDIR=");
-		authsuccess(a->homedir,
-			    s,
-			    0,
-			    &a->sysgroupid,
-			    a->address,
-			    a->fullname);
-		ci->username=s;
+		authsuccess(a->homedir, s, 0, &a->sysgroupid, a->address, a->fullname);
+		ci->username = s;
 		if (ci->callback_func)
 		{
-			a->address=s;
-			(*ci->callback_func)(a, ci->callback_arg);
+			a->address = s;
+			(*ci->callback_func) (a, ci->callback_arg);
 		}
 		return (0);
 	}
 
 	if (ci->callback_func)
 	{
-	char	buf[1];
+		char            buf[1];
 
 		close(pipefd[1]);
 		while (wait(&waitstat) != p)
@@ -271,9 +262,9 @@
 		if (read(pipefd[0], buf, 1) > 0)
 		{
 			close(pipefd[0]);
-			a->address=s;
-			ci->username=s;
-			(*ci->callback_func)(a, ci->callback_arg);
+			a->address = s;
+			ci->username = s;
+			(*ci->callback_func) (a, ci->callback_arg);
 			return (0);
 		}
 		close(pipefd[0]);
@@ -284,92 +275,83 @@
 	free(s);
 	close(pipefd[0]);
 
-	retval=dopam(&pamh);
-
+	retval = dopam(&pamh);
 	if (retval == PAM_SUCCESS)
-		retval=pam_open_session(pamh, 0);
-
+	{
+		if ((retval = pam_open_session(pamh, 0)) != PAM_SUCCESS)
+			dprintf("pam_open_session: %s", pam_strerror(pamh, retval));
+	}
 	if (retval != PAM_SUCCESS)
 	{
 		if (pam_end(pamh, retval) != PAM_SUCCESS)
-			perror("Unable to release PAM tokens");
+			dprintf("pam_end: %s", pam_strerror(pamh, retval));
 
-		/* Wait for child to terminate */
-
-		close(pipefd[1]); /* Tell the child to shut down */
+		/*- Wait for child to terminate */
+		close(pipefd[1]);		/* Tell the child to shut down */
 		while (wait(&waitstat) != p)
 			;
 		return (-1);
 	}
-
-	/* Tell child process to run in authenticated state */
-
+	/*- Tell child process to run in authenticated state */
 	write(pipefd[1], "", 1);
 	close(pipefd[1]);
-
-	/* Wait for child process to finish */
-
+	/*- Wait for child process to finish */
 	while (wait(&waitstat) != p)
 		;
-
-	retval=pam_close_session(pamh, 0);
+	retval = pam_close_session(pamh, 0);
 	if (retval != PAM_SUCCESS)
-		perror("pam_close_session");
-
+		dprintf("pam_close_session: %s", pam_strerror(pamh, retval));
 	if (pam_end(pamh, retval) != PAM_SUCCESS)
-		perror("Unable to release PAM tokens");
-
+		dprintf("pam_end: %s", pam_strerror(pamh, retval));
 	if (WIFEXITED(waitstat))
 		authexit(WEXITSTATUS(waitstat));
 	authexit(255);
 	return (1);
 }
 
-extern int auth_pam_pre(const char *userid, const char *service,
-        int (*callback)(struct authinfo *, void *),
-                        void *arg);
-
-char *auth_pam(const char *service, const char *type, char *authdata,
-	int issession,
-	void (*callback_func)(struct authinfo *, void *), void *callback_arg)
+extern int      auth_pam_pre(const char *userid, const char *service, int (*callback) (struct authinfo *, void *), void *arg);
+
+char           *
+auth_pam(const char *service, const char *type, char *authdata, int issession, void (*callback_func) (struct authinfo *, void *),
+		 void *callback_arg)
 {
-struct	callback_info	ci;
-int	rc;
+	struct callback_info ci;
+	int             rc;
 
 	if (strcmp(type, AUTHTYPE_LOGIN))
 	{
 		dprintf("authpam only handles authtype=" AUTHTYPE_LOGIN);
-		errno=EPERM;
+		errno = EPERM;
 		return (0);
 	}
 
-	if ((pam_username=strtok(authdata, "\n")) == 0 ||
-		(pam_password=strtok(0, "\n")) == 0)
+	if ((pam_username = strtok(authdata, "\n")) == 0 || (pam_password = strtok(0, "\n")) == 0)
 	{
 		dprintf("incomplete username or missing password");
-		errno=EPERM;
+		errno = EPERM;
 		return (0);
 	}
-
-	pam_service=service;
-
-	ci.issession=issession;
-	ci.callback_func=callback_func;
-	ci.callback_arg=callback_arg;
-        rc=auth_pam_pre(pam_username, service, &callback_pam, &ci);
-	if (rc)	return (0);
+	pam_service = service;
+	ci.issession = issession;
+	ci.callback_func = callback_func;
+	ci.callback_arg = callback_arg;
+	rc = auth_pam_pre(pam_username, service, &callback_pam, &ci);
+	if (rc)
+		return (0);
 	return (ci.username);
 }
 
-static void auth_pam_cleanup()
+static void
+auth_pam_cleanup()
 {
 }
 
-struct authstaticinfo authpam_info={
+struct authstaticinfo authpam_info = {
 	"authpam",
 	auth_pam,
 	auth_pam_pre,
 	auth_pam_cleanup,
 	auth_syspasswd,
 	NULL,
-	auth_pwd_enumerate};
+	auth_pwd_enumerate
+};
diff -Naur Courier-imap-3.0.8/authlib/preauthpam.c courier-imap-3.0.8/authlib/preauthpam.c
--- Courier-imap-3.0.8/authlib/preauthpam.c	2004-06-09 04:14:19.000000000 +0530
+++ courier-imap-3.0.8/authlib/preauthpam.c	2009-05-30 20:58:20.000000000 +0530
@@ -26,15 +26,21 @@
 {
 struct authinfo auth;
 struct passwd *pw;
+char *p;
 #if	HAVE_GETSPENT
 struct spwd *spw;
 #endif
 
 	memset(&auth, 0, sizeof(auth));
-
-	if ((pw=getpwnam(userid)) == 0)
+	/*
+	if ((p = strchr(userid, '@')))
+		pw = getpwnam("indimail");
+	else*/
+		pw = getpwnam(userid);
+	if (!pw)
 	{
-		if (errno == ENOMEM)	return (1);
+		if (errno == ENOMEM)
+			return (1);
 		dprintf("authpam: username '%s' not found in password file", userid);
 		errno=EPERM;
 		return (-1);
@@ -52,6 +58,5 @@
 		auth.passwd=spw->sp_pwdp;
 #endif
 	auth_debug_authinfo("DEBUG: authpam: ", &auth, 0, pw->pw_passwd);
-
 	return ((*callback)(&auth, arg));
 }
diff -Naur Courier-imap-3.0.8/authlib/README.authdebug.html.in courier-imap-3.0.8/authlib/README.authdebug.html.in
--- Courier-imap-3.0.8/authlib/README.authdebug.html.in	2004-04-21 06:35:34.000000000 +0530
+++ courier-imap-3.0.8/authlib/README.authdebug.html.in	2009-05-30 20:58:20.000000000 +0530
@@ -291,7 +291,7 @@
 <li>If you didn't build it yourself, where you got the package from (and if
 possible, find out from the packager what options they used to build it)</li>
 <li>The versions of any other relevant software which you are linking
-against, e.g. vpopmail, openldap, mysql, pgsql</li>
+against, e.g. indimail, openldap, mysql, pgsql</li>
 <li>The transcript of the 'telnet' session you used to test [courier-imap]</li>
 <li>The corresponding debug output which was generated for that session</li>
 <li>The contents of the 'pop3d' and 'imapd' configuration files [courier-imap]</li>
@@ -312,28 +312,6 @@
 <p>See also the <a href="http://www.courier-mta.org/FAQ.html">Courier MTA
 FAQ</a></p>
 
-<h3>I get intermittent authentication problems with vpopmail</h3>
-<p>This is a known problem with vpopmail 5.2.1 and earlier. You need to
-upgrade to 5.2.2 or later, and then recompile courier-imap/sqwebmail.
-<br />
-As a workaround, instead you can just recompile courier-imap/sqwebmail with
-the flag "--without-authdaemon". However that's less efficient.
-</p>
-
-<h3>Compiling fails with "cannot find -lvpopmail"</h3>
-<p>This is usually a permissions problem on the vpopmail library. Try:
-<pre>
-# chmod +rx /home/vpopmail /home/vpopmail/lib
-</pre>
-Alternatively, it might be a problem finding the vpopmail headers or
-library, in which case try:
-<pre>
-# CPPFLAGS="-I/home/vpopmail/include"; export CPPFLAGS
-# LDFLAGS="-L/home/vpopmail/lib"; export LDFLAGS
-# ./configure ...
-</pre>
-</p>
-
 <h3>When I try to login with POP3 using telnet, the server disconnects
 immediately after the "PASS" command, without giving a -ERR response</h3>
 <p>
diff -Naur Courier-imap-3.0.8/authlib/README.authmysql.html courier-imap-3.0.8/authlib/README.authmysql.html
--- Courier-imap-3.0.8/authlib/README.authmysql.html	2004-06-09 04:14:17.000000000 +0530
+++ courier-imap-3.0.8/authlib/README.authmysql.html	2009-05-30 20:58:20.000000000 +0530
@@ -28,7 +28,7 @@
 set up your MySQL authentication.</p>
 
 <p><strong>NOTE: this authentication module should NOT be used if you are
-using the vpopmail virtual mailing list manager. You should select the
+using the indimail virtual mailing list manager. You should select the
 <code>authvchkpw</code> authentication module instead (which should happen
 automatically). It may be necessary to use the
 <code>--without-authmysql</code> flag to the <code>configure</code> script,
diff -Naur Courier-imap-3.0.8/authlib/success.c courier-imap-3.0.8/authlib/success.c
--- Courier-imap-3.0.8/authlib/success.c	2003-02-27 10:18:52.000000000 +0530
+++ courier-imap-3.0.8/authlib/success.c	2009-05-30 20:58:20.000000000 +0530
@@ -31,7 +31,10 @@
 	{
 		if (gid)
 			libmail_changegroup(*gid);
-		libmail_changeusername(username, gid);
+		if ((p = strchr(username, '@')))
+			libmail_changeusername("indimail", gid);
+		else
+			libmail_changeusername(username, gid);
 	}
 	else
 	{
diff -Naur Courier-imap-3.0.8/ChangeLog courier-imap-3.0.8/ChangeLog
--- Courier-imap-3.0.8/ChangeLog	2004-01-13 07:19:58.000000000 +0530
+++ courier-imap-3.0.8/ChangeLog	2009-05-30 20:58:20.000000000 +0530
@@ -1 +1,72 @@
 Look in imap/ChangeLog for the real ChangeLog :-)
+Files Changed
+================
+imap/pop3login.c
+imap/pop3dserver.c
+imap/pop3dcapa.c
+imap/imapd.c
+imap/imaplogin.c
+imap/mainloop.c
+imap/imapscanclient.c
+imap/mailboxlist.c
+numlib/changeuidgid.c
+authlib/authvchkpw.c
+authlib/preauthvchkpw.c
+authlib/authvchkpwlib.c
+authlib/libauth.sh
+authlib/authmod.c
+================
+
+imap/pop3login.c (setting TCPREMOTEIP)
+imap/pop3dserver.c (Bye and NOOP)
+imap/pop3dcapa.c (CAPABILITY)
+imap/imapd.c (Bye Message)
+imap/imaplogin.c (setting TCPREMOTEIP and Bye Message)
+imap/mainloop.c (Bye Message)
+imap/smap.c (compilation problems)
+authlib/authvchkpw.c (inquery, etc)
+authlib/preauthvchkpw.c (inquery, etc)
+authlib/authvchkpwlib.c (using ATCHARS)
+numlib/changeuidgid.c (improved error message)
+authlib/authtest.c
+authlib/libauth.sh
+
+8/12/2001
+
+imaplogin.c and pop3login.c
+1. tcpremoteip
+
+29/12/2001
+imapscanclient.c - do not update recent if filename has char after the last ',' char
+ (to prevent moving messages between folder to be shown as new)
+
+30/11/2002
+Makefile - Added chmod 4755 for authpam
+09/07/2003
+imap/imapd.c (mdcreate(".", dot_trash)
+
+11/11/2003
+authlib/authmod.c (set uid back to non-privileged user)
+
+07/01/2004
+imap/pop3dserver.c (replace authaddr with getenv("AUTHENTICATED")
+
+05/05/2004
+authlib/configure for indimail, INDIMAIL to indimail, INDIMAIL
+authlib/Makefile.in for indimail, INDIMAIL to indimail, INDIMAIL
+
+12/06/2004
+authlib/authvchkpw.c (auth_vchk_enumerate()) function
+authlib/auth_vchk
+
+13/06/2004
+imap/mailboxlist.c
+added check for regular files
+
+23/05/2008
+pop3dserver.c
+added printed, printchar() functions
+
+27/05/2008
+use getuid, setuid in imapd.c pop3dserver.c to prevent root privileges
+update to courier-imap 4.5.0
diff -Naur Courier-imap-3.0.8/imap/capability.c courier-imap-3.0.8/imap/capability.c
--- Courier-imap-3.0.8/imap/capability.c	2004-06-09 04:14:20.000000000 +0530
+++ courier-imap-3.0.8/imap/capability.c	2009-05-31 10:17:34.000000000 +0530
@@ -16,6 +16,15 @@
 
 static const char rcsid[]="$Id: capability.c,v 1.10 2004/05/25 02:16:05 mrsam Exp $";
 
+static int capa_keywords=0;
+
+void initcapability()
+{
+	const char *p=getenv("IMAP_KEYWORDS");
+
+	if (p) capa_keywords=atoi(p);
+}
+
 int have_starttls()
 {
 const char *p;
@@ -40,12 +49,15 @@
 
 int keywords()
 {
-	const char *p=getenv("IMAP_KEYWORDS");
+	return capa_keywords != 0;
+}
 
-	if (p && atoi(p))       return (1);
-	return (0);
+int fastkeywords()
+{
+	return capa_keywords == 1;
 }
 
+
 int magictrash()
 {
 	const char *p;
@@ -82,7 +94,8 @@
 	}
 #endif
 
-	writes(" ACL ACL2=UNION");
+	if ((p=getenv("IMAP_ACL")) && atoi(p))
+		writes(" ACL ACL2=UNION");
 	if (have_starttls())
 	{
 		writes(" STARTTLS");
diff -Naur Courier-imap-3.0.8/imap/fetch.c courier-imap-3.0.8/imap/fetch.c
--- Courier-imap-3.0.8/imap/fetch.c	2004-06-09 04:14:20.000000000 +0530
+++ courier-imap-3.0.8/imap/fetch.c	2009-05-30 20:58:20.000000000 +0530
@@ -1,5 +1,5 @@
 /*
-** Copyright 1998 - 2002 Double Precision, Inc.
+** Copyright 1998 - 2009 Double Precision, Inc.
 ** See COPYING for distribution information.
 */
 
@@ -33,6 +33,7 @@
 #if SMAP
 extern int smapflag;
 #endif
+static const char unavailable[]= "From: System Administrator <root@localhost>\nSubject: message unavailable\n\nThis message is no longer available on the server.\n";
 
 unsigned long header_count=0, body_count=0;	/* Total transferred */
 
@@ -1543,7 +1544,16 @@
 	if (fd < 0 || (cached_fp=fdopen(fd, "r")) == 0)
 	{
 		if (fd >= 0)	close(fd);
-		return (0);
+		if ((cached_fp=tmpfile()) != 0)
+		{
+			fprintf(cached_fp, unavailable);
+			if (fseek(cached_fp, 0L, SEEK_SET) < 0 ||
+				ferror(cached_fp))
+			{
+				fclose(cached_fp);
+				cached_fp=0;
+			}
+		}
 	}
 
 	if ((cached_fp_filename=strdup(current_maildir_info.
diff -Naur Courier-imap-3.0.8/imap/imapd.c courier-imap-3.0.8/imap/imapd.c
--- Courier-imap-3.0.8/imap/imapd.c	2004-09-13 04:55:56.000000000 +0530
+++ courier-imap-3.0.8/imap/imapd.c	2009-05-31 10:20:58.000000000 +0530
@@ -101,6 +101,7 @@
 
 extern void mainloop();
 extern void imapcapability();
+extern void initcapability();
 extern int magictrash();
 
 #if SMAP
@@ -134,7 +135,8 @@
 
 void rfc2045_error(const char *p)
 {
-	write(2, p, strlen(p));
+	if (write(2, p, strlen(p)) < 0)
+		_exit(1);
 	_exit(0);
 }
 
@@ -612,6 +614,7 @@
 
 	maildir_tmpcreate_init(&createInfo);
 
+	createInfo.openmode=0666;
 	createInfo.maildir=mailbox;
 	createInfo.uniq=uniqbuf;
 	createInfo.msgsize=s;
@@ -993,7 +996,8 @@
 		{
 			do
 			{
-				if (i > current_maildir_info.nmessages)
+				if (i == 0 ||
+				    i > current_maildir_info.nmessages)
 				{
 					writes("* NO Invalid message sequence number: ");
 					writen(i);
@@ -1180,8 +1184,8 @@
 						writen(smap_last + smap_range
 						       - smap_expunge_bias
 						       + 1);
-						writes("\n");
 					}
+					writes("\n");
 					smap_expunge_count=0;
 				}
 
@@ -1608,14 +1612,24 @@
 						      -file_counted);
 			}
 
-			/* Don't mark it as deleted in the Trash */
-
 			if ((p=strrchr(new_name, '/')) &&
-				(p=strrchr(p, MDIRSEP[0])) &&
-				strncmp(p, MDIRSEP "2,", 3) == 0 &&
-				(p=strchr(p, 'T')))
-				while ((*p=p[1]) != 0)
-					++p;
+			    (p=strrchr(p, MDIRSEP[0])) &&
+			    strncmp(p, MDIRSEP "2,", 3) == 0)
+			{
+				char *q;
+
+				/* Don't mark it as deleted in the Trash */
+
+				if ((q=strchr(p, 'T')) != NULL)
+					while ((*q=q[1]) != 0)
+						++q;
+
+				/* Don't mark it as a draft msg in the Trash */
+
+				if ((q=strchr(p, 'D')) != NULL)
+					while ((*q=q[1]) != 0)
+						++q;
+			}
 
 			if (rename(old_name, new_name))
 			{
@@ -1754,7 +1768,12 @@
 
 static int do_count(unsigned long n, int byuid, void *voidptr)
 {
+	const char *p=getenv("OUTBOX_MULTIPLE_SEND");
+
 	++ *(int *)voidptr;
+
+	if (p && atoi(p))
+		*(int *)voidptr=1; /* Suppress the error, below */
 	return 0;
 }
 
@@ -4007,7 +4026,7 @@
 	{
 		if (nexttoken()->tokentype != IT_EOL)	return (-1);
 		fetch_free_cache();
-		writes("* BYE Courier-IMAP server shutting down\r\n");
+		writes("* BYE IMAP4rev1 server shutting down\r\n");
 		writes(tag);
 		writes(" OK LOGOUT completed\r\n");
 		writeflush();
@@ -6167,7 +6186,7 @@
 }
 #endif
 
-static void chkdisabled(const char *ip)
+static void chkdisabled(const char *ip, const char *port)
 {
 	char *p;
 
@@ -6181,18 +6200,79 @@
 	}
 
 	free(p);
-	fprintf(stderr, "INFO: LOGIN, user=%s, ip=[%s], protocol=%s\n",
-		getenv("AUTHENTICATED"), ip,
-		protocol);
+	fprintf(stderr, "INFO: LOGIN, user=%s, ip=[%s], port=[%s], protocol=%s\n",
+		getenv("AUTHENTICATED"), ip, port, protocol);
 }
 
+static int chk_clock_skew()
+{
+	static const char fn[]="tmp/courier-imap.clockskew.chk";
+	struct stat stat_buf;
+	int fd;
+	time_t t;
+
+	unlink(fn);
+	fd=open(fn, O_RDWR|O_TRUNC|O_CREAT, 0666);
+	time(&t);
+
+	if (fd < 0)
+		return 0; /* Something else is wrong */
+
+	if (fstat(fd, &stat_buf) < 0)
+	{
+		close(fd);
+		return -1; /* Something else is wrong */
+	}
+	close(fd);
+	unlink(fn);
+
+	if (stat_buf.st_mtime < t - 30 || stat_buf.st_mtime > t+30)
+		return -1;
+	return 0;
+}
+
+#if SMAP
+
+static int is_smap()
+{
+	const char *p;
+
+	p=getenv("PROTOCOL");
+
+	if (p && strcmp(p, "SMAP1") == 0)
+		return 1;
+	return 0;
+}
+
+#else
+
+#define is_smap() 0
+
+#endif
+
 int main(int argc, char **argv)
 {
 	const char *ip;
 	const char *p;
 	const char *tag;
+	const char *port;
 	mode_t oldumask;
+	uid_t           euid, uid;
 
+	if (!(euid = geteuid()))
+	{
+		if (euid != (uid = getuid()))
+		{
+			if (setuid(uid))
+			{
+				fprintf(stderr, "imapd: setuid: %s\n", strerror(errno));
+				exit(1);
+			}
+		}
+	}
+#ifdef HAVE_SETVBUF_IOLBF
+	setvbuf(stderr, NULL, _IOLBF, BUFSIZ);
+#endif
 	time(&start_time);
 	if (argc > 1 && strcmp(argv[1], "--version") == 0)
 	{
@@ -6209,6 +6289,7 @@
 		const char *p;
 
 		putenv("TCPREMOTEIP=127.0.0.1");
+		putenv("TCPREMOTEPORT=0");
 
 		p=getenv("AUTHENTICATED");
 		if (!p || !*p)
@@ -6239,6 +6320,8 @@
 
 	ip=getenv("TCPREMOTEIP");
 	if (!ip || !*ip)	exit(0);
+	port=getenv("TCPREMOTEPORT");
+	if (!port || !*port)	exit(0);
 
 	protocol=getenv("PROTOCOL");
 
@@ -6261,21 +6344,29 @@
 
 		if ( stat(".", &buf) < 0 || buf.st_mode & S_ISVTX)
 		{
-			fprintf(stderr, "INFO: LOCKED, user=%s, ip=[%s]\n",
-				getenv("AUTHENTICATED"), ip);
+			fprintf(stderr, "INFO: LOCKED, user=%s, ip=[%s], port=[%s]\n",
+				getenv("AUTHENTICATED"), ip, port);
+			if (is_smap())
+				writes("-ERR ");
+			else
+				writes("* BYE ");
 			writes("* BYE Your account is temporarily unavailable (+t bit set on home directory).\r\n");
 			writeflush();
 			exit(0);
 		}
 	}
 
-	p=getenv("MAILDIR");
+	if (argc > 1)
+		p=argv[1];
+	else
+		p=getenv("MAILDIR");
+	if (!p)
+		p="./Maildir";
 
-	if ((p == 0 || *p == 0) && argc > 1)	p=argv[1];
 #if 0
 	imapscanpath=getimapscanpath(argv[0]);
 #endif
-	if (p && *p && chdir(p))
+	if (chdir(p))
 	{
 		fprintf(stderr, "chdir %s: %s\n", p, strerror(errno));
 		write_error_exit(p);
@@ -6292,6 +6383,21 @@
 
 		homedir_dev=buf.st_dev;
 		homedir_ino=buf.st_ino;
+		errno=0;
+
+		p=getenv("IMAP_MAILBOX_SANITY_CHECK");
+
+		if (!p || !*p) p="1";
+
+		if (atoi(p))
+		{
+			if ( buf.st_uid != geteuid() ||
+			     buf.st_gid != getegid())
+			{
+				fprintf(stderr, "uid %d euid %d\n", getuid(), geteuid());
+				write_error_exit("Account's mailbox directory is not owned by the correct uid or gid");
+			}
+		}
 	}
 
 	p=getenv("HOSTNAME");
@@ -6305,19 +6411,21 @@
 		dot_trash[0] = '.';
 		strcpy(&dot_trash[1], trash); 
 	}
+	mdcreate(dot_trash);
 	
 #if 0
 	mdcreate("." DRAFTS);
 #endif
 
 	if ((p=getenv("IMAPDEBUGFILE")) != 0 && *p)
-       {
+    {
 		oldumask = umask(027);
 		debugfile=fopen(p, "a");
 		umask(oldumask);
 		if (debugfile==NULL)
 			write_error_exit(0);
-       }
+    }
+	initcapability();
 
 	emptytrash();
 	signal(SIGPIPE, SIG_IGN);
@@ -6334,10 +6442,14 @@
 				   atoi(p));
 
 #if SMAP
-	p=getenv("PROTOCOL");
-
-	if (p && strcmp(p, "SMAP1") == 0)
+	if (is_smap())
 	{
+		if (chk_clock_skew())
+		{
+			writes("-ERR Clock skew detected. Check the clock on the file server\r\n");
+			writeflush();
+			exit(0);
+		}
 		writes("+OK SMAP1 LOGIN Ok.\n");
 
 		smapflag=1;
@@ -6345,7 +6457,7 @@
 		libmail_kwVerbotten=KEYWORD_SMAPVERBOTTEN;
 		libmail_kwCaseSensitive=1;
 
-		chkdisabled(ip);
+		chkdisabled(ip, port);
 		smap();
 		logoutmsg();
 		emptytrash();
@@ -6353,6 +6465,13 @@
 	}
 #endif
 
+	if (chk_clock_skew())
+	{
+		writes("* BYE Clock skew detected. Check the clock on the file server\r\n");
+		writeflush();
+		exit(0);
+	}
+
 	if ((tag=getenv("IMAPLOGINTAG")) != 0)
 	{
 		writes(tag);
@@ -6361,7 +6480,7 @@
 	else
 		writes("* PREAUTH Ready.\r\n");
 	writeflush();
-	chkdisabled(ip);
+	chkdisabled(ip, port);
 	imapscan_init(&current_maildir_info);
 	mainloop();
 	bye();
diff -Naur Courier-imap-3.0.8/imap/imaplogin.c courier-imap-3.0.8/imap/imaplogin.c
--- Courier-imap-3.0.8/imap/imaplogin.c	2004-09-13 04:55:56.000000000 +0530
+++ courier-imap-3.0.8/imap/imaplogin.c	2009-05-31 10:21:09.000000000 +0530
@@ -33,13 +33,18 @@
 FILE *debugfile=0;
 extern void mainloop();
 extern void imapcapability();
+extern void initcapability();
 extern int have_starttls();
 extern int tlsrequired();
 extern int authenticate(const char *);
 unsigned long header_count=0, body_count=0;	/* Dummies */
 
+extern unsigned long bytes_received_count; /* counter for received bytes (imaptoken.c) */
+extern unsigned long bytes_sent_count; /* counter for sent bytes (imapwrite.c) */
+
 int main_argc;
 char **main_argv;
+char tcpremoteip[28];
 extern time_t start_time;
 
 void rfc2045_error(const char *p)
@@ -151,11 +156,11 @@
 	if (strcmp(curtoken->tokenbuf, "LOGOUT") == 0)
 	{
 		if (nexttoken()->tokentype != IT_EOL)   return (-1);
-		writes("* BYE Courier-IMAP server shutting down\r\n");
+		writes("* BYE IMAP4rev1 server shutting down\r\n");
 		cmdsuccess(tag, "LOGOUT completed\r\n");
 		writeflush();
-		fprintf(stderr, "INFO: LOGOUT, ip=[%s]\n",
-			getenv("TCPREMOTEIP"));
+		fprintf(stderr, "INFO: LOGOUT, ip=[%s], port=%s, rcvd=%lu, sent=%lu\n",
+			getenv("TCPREMOTEIP"), getenv("TCPREMOTEPORT"), bytes_received_count, bytes_sent_count);
 		exit(0);
 	}
 	if (strcmp(curtoken->tokenbuf, "NOOP") == 0)
@@ -189,7 +194,7 @@
 	if (strcmp(curtoken->tokenbuf, "LOGIN") == 0)
 	{
 	struct imaptoken *tok=nexttoken_nouc();
-	char	*userid;
+	char	*userid, *ptr;
 	char	*tagenv;
 	char	*passwd;
 	const char *p;
@@ -212,6 +217,12 @@
 		userid=strdup(tok->tokenbuf);
 		if (!userid)
 			write_error_exit(0);
+		if((ptr = strchr(userid, ':')) != (char *) 0)
+		{
+			*ptr = 0;
+			snprintf(tcpremoteip, 28, "TCPREMOTEIP=%s", ptr + 1);
+			putenv(tcpremoteip);
+		}
 		tok=nexttoken_nouc_okbracket();
 		switch (tok->tokentype)	{
 		case IT_ATOM:
@@ -270,13 +281,17 @@
 int main(int argc, char **argv)
 {
 const char	*tag=getenv("IMAPLOGINTAG");
-const char	*ip;
+const char	*ip, *port;
 
+#ifdef HAVE_SETVBUF_IOLBF
+	setvbuf(stderr, NULL, _IOLBF, BUFSIZ);
+#endif
 	ip=getenv("TCPREMOTEIP");
 	if (!ip)	exit(9);
-
+	if(!(port = getenv("TCPREMOTEPORT")))
+		exit(9);
 	time(&start_time);
-
+	initcapability();
 #if	IMAP_CLIENT_BUGS
 
 	ignorepunct();
@@ -296,25 +311,18 @@
 
 	if (authmoduser(argc, argv, 60, 5))
 	{
-		writes("* OK [CAPABILITY ");
-		imapcapability();
-		writes("] Courier-IMAP ready. "
-		       "Copyright 1998-2004 Double Precision, Inc.  "
-		       "See COPYING for distribution information.\r\n");
-		fprintf(stderr, "DEBUG: Connection, ip=[%s]\n", ip);
+		writes("* OK IMAP4rev1 Server Ready.\r\n");
+		fprintf(stderr, "INFO: Connection, ip=[%s], port=%s\n", ip, port);
 	}
 	else
 	{
 		cmdfail(tag ? tag:"", "Login failed.\r\n");
-		fprintf(stderr, "ERR: LOGIN FAILED, ip=[%s]\n", ip);
+		fprintf(stderr, "ERR: LOGIN FAILED, ip=[%s], port=%s\n", ip, port);
 	}
-
 	writeflush();
 	main_argc=argc;
 	main_argv=argv;
-
 	putenv("PROTOCOL=IMAP");
-
 	mainloop();
 	return (0);
 }
diff -Naur Courier-imap-3.0.8/imap/imapscanclient.c courier-imap-3.0.8/imap/imapscanclient.c
--- Courier-imap-3.0.8/imap/imapscanclient.c	2004-07-20 05:24:14.000000000 +0530
+++ courier-imap-3.0.8/imap/imapscanclient.c	2009-05-30 20:58:20.000000000 +0530
@@ -603,6 +603,14 @@
 		newtmpl->next=newtempinfo_list;
 		newtmpl->found=0;
 		newtmpl->isrecent=1;
+		/** begin change by mbhangui */
+		for(;*q;q++);
+		q--;
+		if(*q == ',')
+			newtmpl->isrecent=1;
+		else
+			newtmpl->isrecent=0;
+		/** end change by mbhangui */
 		newtempinfo_list=newtmpl;
 		dowritecache=1;
 	}
@@ -787,6 +795,7 @@
 	/* bk: ignore if failed to open file */
 	if (!ro && dowritecache && fp)
 	{
+		int need_fclose;
 	/* Step 7 - write out the new cache file */
 
 		version=IMAPDBVERSION;
@@ -800,32 +809,19 @@
 				tempinfo_array[i]->filename);
 			if (q)	*q=MDIRSEP[0];
 		}
-		if (fflush(fp) || ferror(fp) || fclose(fp))
+		need_fclose = 1;
+		if (fflush(fp) || ferror(fp) || (need_fclose = 0,fclose(fp)))
 		{
 			imapscanfail(dir);
-			fclose(fp);
+			if(need_fclose)
+				fclose(fp);
 			/* bk: ignore if failed */
 			unlink(newdbfilepath);
 			unlink(dbfilepath);
-			/*
-			free(tempinfo_array);
-			free(dbfilepath);
-			unlink(newdbfilepath);
-			free(newdbfilepath);
-			while (tempinfo_list)
-			{
-				tempinfoptr=tempinfo_list;
-				tempinfo_list=tempinfoptr->next;
-				free(tempinfoptr->filename);
-				free(tempinfoptr);
-			}
-			return (-1);
-			*/
 		}
 		/* bk */
 		else
-
-		rename(newdbfilepath, dbfilepath);
+			rename(newdbfilepath, dbfilepath);
 	}
 	else
 	{
diff -Naur Courier-imap-3.0.8/imap/imaptoken.c courier-imap-3.0.8/imap/imaptoken.c
--- Courier-imap-3.0.8/imap/imaptoken.c	2004-09-13 04:55:56.000000000 +0530
+++ courier-imap-3.0.8/imap/imaptoken.c	2009-05-30 20:58:20.000000000 +0530
@@ -1,5 +1,5 @@
 /*
-** Copyright 1998 - 2003 Double Precision, Inc.
+** Copyright 1998 - 2005 Double Precision, Inc.
 ** See COPYING for distribution information.
 */
 
@@ -24,7 +24,7 @@
 #define	BUFSIZ	8192
 #endif
 
-static const char rcsid[]="$Id: imaptoken.c,v 1.18 2004/09/12 23:25:56 mrsam Exp $";
+static const char rcsid[]="$Id: imaptoken.c,v 1.20 2005/10/01 03:23:44 mrsam Exp $";
 
 static struct imaptoken curtoken;
 static char readbuf[BUFSIZ];
@@ -39,6 +39,9 @@
 
 extern unsigned long header_count, body_count;
 
+unsigned long bytes_received_count = 0; /* counter for received bytes */
+unsigned long bytes_sent_count; /* counter for sent bytes (imapwrite.c) */
+
 extern void bye();
 
 void bye_msg(const char *type)
@@ -56,20 +59,27 @@
 
 	if (a && *a)
 		fprintf(stderr, "%s, user=%s, "
-			"ip=[%s], headers=%lu, body=%lu, time=%s%s\n",
+			"ip=[%s], headers=%lu, body=%lu, rcvd=%lu, sent=%lu, time=%s%s\n",
 			type,
-			a, getenv("TCPREMOTEIP"), header_count, body_count,
+			a, getenv("TCPREMOTEIP"), header_count, body_count, bytes_received_count, bytes_sent_count,
 			buf, tls);
 	else
-		fprintf(stderr, "%s, ip=[%s], time=%s%s\n",
-			type,
+		fprintf(stderr, "DEBUG: Disconnected, ip=[%s], time=%s%s\n",
 			getenv("TCPREMOTEIP"),
 			buf, tls);
 }
 
 void disconnected()
 {
-	bye_msg("ERR: DISCONNECTED");
+	bye_msg("INFO: DISCONNECTED");
+	bye();
+}
+
+static void disconnected_timeout(void)
+{
+	writes("* BYE Disconnected for inactivity.\r\n");
+	writeflush();
+	bye_msg("INFO: TIMEOUT");
 	bye();
 }
 
@@ -80,7 +90,7 @@
 time_t t;
 
        time(&t);
-       if (t >= readtimeout)   disconnected();
+       if (t >= readtimeout)   disconnected_timeout();
        if (imap_readptrleft > 0) return 1;
 
        FD_ZERO(&fds);
@@ -107,24 +117,30 @@
 fd_set	fds;
 struct	timeval	tv;
 time_t	t;
-int n;
+int n = 0;
 
 	time(&t);
-	if (t >= readtimeout)	disconnected();
+	if (t >= readtimeout)	disconnected_timeout();
 
 	FD_ZERO(&fds);
 	FD_SET(0, &fds);
 	tv.tv_sec=readtimeout - t;
 	tv.tv_usec=0;
 
-	if (select(1, &fds, 0, 0, &tv) <= 0 || !FD_ISSET(0, &fds) ||
-		(n=read(0, buf, bufsiz)) <= 0)
+	if (select(1, &fds, 0, 0, &tv) <= 0)
+	{
+		disconnected_timeout();
+		return (0);
+	}
+	if (!FD_ISSET(0, &fds) || (n=read(0, buf, bufsiz)) <= 0)
 	{
-		writes("* BYE Disconnected for inactivity.\r\n");
-		writeflush();
+		if ( n > 0 )
+			bytes_received_count += n; /* count received bytes */
 		disconnected();
 		return (0);
 	}
+	if ( n > 0 )
+		bytes_received_count += n; /* count received bytes */
 	return (n);
 }
 
diff -Naur Courier-imap-3.0.8/imap/imapwrite.c courier-imap-3.0.8/imap/imapwrite.c
--- Courier-imap-3.0.8/imap/imapwrite.c	2001-03-23 08:52:11.000000000 +0530
+++ courier-imap-3.0.8/imap/imapwrite.c	2009-05-30 20:58:20.000000000 +0530
@@ -1,5 +1,5 @@
 /*
-** Copyright 1998 - 1999 Double Precision, Inc.
+** Copyright 1998 - 2006 Double Precision, Inc.
 ** See COPYING for distribution information.
 */
 
@@ -27,13 +27,15 @@
 
 #include	"imapwrite.h"
 
-static const char rcsid[]="$Id: imapwrite.c,v 1.4 2001/03/23 03:22:11 mrsam Exp $";
+static const char rcsid[]="$Id: imapwrite.c,v 1.8 2008/07/20 16:58:32 mrsam Exp $";
 
 static char outbuf[BUFSIZ];	/* Ye olde output buffer */
 static size_t outbuf_cnt=0;	/* How much stuff's in ye olde output buffer */
 
 extern FILE *debugfile;
 
+extern unsigned long bytes_sent_count; /* counter for sent bytes (imapwrite.c) */
+
 extern void disconnected();
 
 void writeflush()
@@ -51,8 +53,8 @@
 	if (debugfile)
 	{
 		fprintf(debugfile, "WRITE: ");
-		fwrite(p, 1, s, debugfile);
-		fprintf(debugfile, "\n");
+		if (fwrite(p, 1, s, debugfile) == 1)
+			fprintf(debugfile, "\n");
 		fflush(debugfile);
 	}
 	while (t < tend)
@@ -61,13 +63,22 @@
 		FD_SET(1, &fds);
 		tv.tv_sec=tend-t;
 		tv.tv_usec=0;
-		if (select(2, 0, &fds, 0, &tv) <= 0 ||
-			!FD_ISSET(1, &fds) ||
-			(n=write(1, p, s)) <= 0)
+		/* BUG: if client closes connection BEFORE we flush it, select "stucks"
+		 * until timeout. To workaround this, we should "write" first, and then
+		 * if we get EPIPE connection is already closed. Othervise, try select
+		 */
+		if ((n=write(1, p, s)) <= 0)
 		{
-			disconnected();
-			return;
+			if (errno == EPIPE ||
+				select(2, 0, &fds, 0, &tv) <= 0 ||
+				!FD_ISSET(1, &fds) ||
+				(n=write(1, p, s)) <= 0)
+			{
+				disconnected();
+				return;
+			}
 		}
+		bytes_sent_count += n;
 		p += n;
 		s -= n;
 		if (s == 0)	break;
@@ -204,5 +215,12 @@
 	}
 	writes("\r\n");
 	writeflush();
+
+	if (funcname && *funcname)
+	{
+		fprintf(stderr, "ERR: %s: %s\n", getenv("AUTHENTICATED"),
+			funcname);
+		fflush(stderr);
+	}
 	_exit(1);
 }
diff -Naur Courier-imap-3.0.8/imap/mailboxlist.c courier-imap-3.0.8/imap/mailboxlist.c
--- Courier-imap-3.0.8/imap/mailboxlist.c	2004-06-09 04:14:21.000000000 +0530
+++ courier-imap-3.0.8/imap/mailboxlist.c	2009-05-31 10:09:21.000000000 +0530
@@ -1,5 +1,5 @@
 /*
-** Copyright 1998 - 2003 Double Precision, Inc.
+** Copyright 1998 - 2007 Double Precision, Inc.
 ** See COPYING for distribution information.
 */
 
@@ -67,7 +67,7 @@
 #include	"unicode/unicode.h"
 #include	"authlib/auth.h"
 
-static const char rcsid[]="$Id: mailboxlist.c,v 1.18 2004/05/25 02:08:40 mrsam Exp $";
+static const char rcsid[]="$Id: mailboxlist.c,v 1.20 2007/07/27 02:41:01 mrsam Exp $";
 
 static const char hierchs[]={HIERCH, 0};
 
@@ -183,6 +183,7 @@
 }
 
 static int match_mailbox(char *, char *, int flags);
+static void match_mailbox_prep(char *);
 
 /* Check if a folder has any new messages */
 
@@ -282,24 +283,79 @@
 	return (0);
 }
 
+static int has_hier_entry(char *folder,
+			  struct hierlist **hierarchies);
+
 static void hier_entry(char *folder,
 		       struct hierlist **hierarchies);
 
-static void folder_entry(char *folder, char *hier,
+static void folder_entry(char *folder, char *pattern,
 			 int list_options,
 			 struct hierlist **folders,
 			 struct hierlist **hierarchies)
 {
+	size_t i;
+	size_t folder_l=strlen(folder);
+
+	int need_add_hier;
+	int need_add_folders;
+
+	match_mailbox_prep(folder);
+
+	/* Optimize away folders we don't care about */
+
+	for (i=0; pattern[i]; i++)
+	{
+		if ((!(list_options & LIST_CHECK1FOLDER)) &&
+		    (pattern[i] == '%' || pattern[i] == '*'))
+		{
+			while (i)
+			{
+				if (pattern[i] == HIERCH)
+					break;
+				--i;
+			}
+			break;
+		}
+	}
+
+	if (folder_l <= i)
+	{
+		if (memcmp(folder, pattern, folder_l))
+			return;
+
+		if (folder_l != i && pattern[folder_l] != HIERCH)
+			return;
+	}
+	else if (i)
+	{
+		if (memcmp(folder, pattern, i))
+			return;
+		if (folder[i] != HIERCH)
+			return;
+	}
+
+	need_add_folders=0;
+
+	if (match_mailbox(folder, pattern, list_options) == 0)
+		need_add_folders=1;
+
+	need_add_hier=0;
+	if (!has_hier_entry(folder, hierarchies))
+		need_add_hier=1;
+
+	if (!need_add_folders && !need_add_hier)
+		return; /* Nothing to do */
+
 	CHECK_RIGHTSM(folder, have_rights, ACL_LOOKUP);
 	if (!have_rights[0])
 		return;
 
-	if (match_mailbox(folder, hier, list_options) == 0)
-	{
+	if (need_add_folders)
 		(void) add_hier(folders, folder);
-	}
 
-	hier_entry(folder, hierarchies);
+	if (need_add_hier)
+		hier_entry(folder, hierarchies);
 }
 
 static void hier_entry(char *folder,
@@ -316,6 +372,25 @@
 	}
 }
 
+static int has_hier_entry(char *folder,
+			  struct hierlist **hierarchies)
+{
+	unsigned i;
+
+	for (i=0; folder[i]; i++)
+	{
+		if (folder[i] != HIERCH)	continue;
+		folder[i]=0;
+		if (!search_hier(*hierarchies, folder))
+		{
+			folder[i]=HIERCH;
+			return (0);
+		}
+		folder[i]=HIERCH;
+	}
+	return (1);
+}
+
 struct list_sharable_info {
 	char *pattern;
 	struct hierlist **folders, **hierarchies;
@@ -384,6 +459,7 @@
 {
 	DIR	*dirp;
 	struct	dirent *de;
+	struct stat statbuf;
 
 	/* Scan maildir, looking for .subdirectories */
 
@@ -395,6 +471,13 @@
 		if (de->d_name[0] != '.' ||
 		    strcmp(de->d_name, "..") == 0)
 			continue;
+		/*
+		 * Skip regular files - mbhangui
+		 */
+		if (stat(de->d_name, &statbuf))
+			continue;
+		if (S_ISREG(statbuf.st_mode))
+			continue;
 
 		if ((p=malloc(strlen(de->d_name)+strlen(inbox_name)+10)) == 0)
 					/* A bit too much, that's OK */
@@ -787,6 +870,8 @@
 	hierarchies=0;
 	folders=0;
 
+	match_mailbox_prep(pattern);
+
 	shared_info.pattern=pattern;
 	shared_info.folders= &folders;
 	shared_info.hierarchies= &hierarchies;
@@ -874,6 +959,8 @@
 	{
 		hierarchies=hp->next;
 
+		match_mailbox_prep(hp->hier);
+
 		if (match_mailbox(hp->hier, pattern, list_options) == 0
 		    && hp->flag == 0)
 		{
@@ -919,7 +1006,7 @@
 
 static int match_recursive(char *, char *, int);
 
-static int match_mailbox(char *name, char *pattern, int list_options)
+static void match_mailbox_prep(char *name)
 {
 	size_t	i;
 
@@ -935,26 +1022,16 @@
 		for (i=0; name[i] && name[i] != HIERCH; i++)
 			name[i]=toupper( (int)(unsigned char)name[i] );
 
-	if (
-#if	HAVE_STRNCASECMP
-	    strncasecmp(pattern, INBOX, sizeof(INBOX)-1) == 0
-#else
-	    strnicmp(pattern, INBOX, sizeof(INBOX)-1) == 0
-#endif
-	    )
-		for (i=0; pattern[i] && pattern[i] != HIERCH; i++)
-			pattern[i]=toupper( (int)(unsigned char)pattern[i] );
-
 	/* ... except that "shared" should be lowercase ... */
 
 	if (memcmp(name, "SHARED", 6) == 0)
 		memcpy(name, "shared", 6);
+}
 
-	if (memcmp(pattern, "SHARED", 6) == 0)
-		memcpy(pattern, "shared", 6);
-
-	if (list_options & LIST_CHECK1FOLDER)
-		return strcmp(name, pattern);
+static int match_mailbox(char *name, char *pattern, int list_options)
+{
+        if (list_options & LIST_CHECK1FOLDER)
+                return strcmp(name, pattern);
 
 	return (match_recursive(name, pattern, HIERCH));
 }
diff -Naur Courier-imap-3.0.8/imap/mainloop.c courier-imap-3.0.8/imap/mainloop.c
--- Courier-imap-3.0.8/imap/mainloop.c	2003-05-27 21:25:10.000000000 +0530
+++ courier-imap-3.0.8/imap/mainloop.c	2009-05-30 20:58:20.000000000 +0530
@@ -1,5 +1,5 @@
 /*
-** Copyright 1998 - 1999 Double Precision, Inc.
+** Copyright 1998 - 2006 Double Precision, Inc.
 ** See COPYING for distribution information.
 */
 
@@ -16,16 +16,51 @@
 #include	<unistd.h>
 #include	"imaptoken.h"
 #include	"imapwrite.h"
+#include	"numlib/numlib.h"
 
-static const char rcsid[]="$Id: mainloop.c,v 1.7 2003/05/27 15:55:10 mrsam Exp $";
+static const char rcsid[]="$Id: mainloop.c,v 1.10 2006/07/07 23:17:18 mrsam Exp $";
 
 extern int do_imap_command(const char *);
 
+extern unsigned long header_count, body_count;
+extern unsigned long bytes_received_count, bytes_sent_count;
+extern time_t start_time;
+
 static RETSIGTYPE sigexit(int n)
 {
-static char byemsg[]="* BYE Courier-IMAP server shut down by signal.\r\n";
+	static char byemsg[]="* BYE IMAP4erv1 server shut down by signal.\r\n";
+	const char *a=getenv("AUTHENTICATED");
+	char buf[NUMBUFSIZE];
+	char msg[1024];
+	int l = 0;
+	const char *tls=getenv("IMAP_TLS");
+	const char *ip=getenv("TCPREMOTEIP");
+
+	if (write(1, byemsg, sizeof(byemsg)-1) < 0)
+		exit(1);
+
+	bytes_sent_count += sizeof(byemsg);
+
+	libmail_str_time_t(time(NULL)-start_time, buf);
+
+	if (tls && atoi(tls))
+		tls=", starttls=1";
+	else
+		tls="";
+
+	if (a && *a)
+		l = snprintf(msg, sizeof(msg) - 1, "NOTICE: Disconnected during shutdown by signal, user=%s, "
+			"ip=[%s], headers=%lu, body=%lu, rcvd=%lu, sent=%lu, time=%s%s\n",
+			a, ip, header_count, body_count, bytes_received_count, bytes_sent_count,
+			buf, tls);
+	else
+		l = snprintf(msg, sizeof(msg) - 1, "NOTICE: Disconnected during shutdown by signal, ip=[%s], time=%s%s\n",
+			getenv("TCPREMOTEIP"),
+			buf, tls);
+
+	if (l > 0 && write(2, msg, l))
+		; /* Suppress gcc warning */
 
-	write(1, byemsg, sizeof(byemsg)-1);
 	exit(0);
 #if	RETSIGTYPE != void
 	return (0);
diff -Naur Courier-imap-3.0.8/imap/msgbodystructure.c courier-imap-3.0.8/imap/msgbodystructure.c
--- Courier-imap-3.0.8/imap/msgbodystructure.c	2002-09-20 17:52:48.000000000 +0530
+++ courier-imap-3.0.8/imap/msgbodystructure.c	2009-05-30 20:58:20.000000000 +0530
@@ -15,7 +15,7 @@
 #include	<stdlib.h>
 #include	<string.h>
 
-static const char rcsid[]="$Id: msgbodystructure.c,v 1.13 2002/09/20 12:22:48 mrsam Exp $";
+static const char rcsid[]="$Id: msgbodystructure.c,v 1.14 2005/02/26 18:32:50 mrsam Exp $";
 
 extern void msgenvelope(void (*)(const char *, size_t),
 		FILE *, struct rfc2045 *);
@@ -206,7 +206,8 @@
 		(content_type_s[1] == 'e' || content_type_s[1] == 'E') &&
 		(content_type_s[2] == 'x' || content_type_s[2] == 'X') &&
 		(content_type_s[3] == 't' || content_type_s[3] == 'T') &&
-			content_type_s[4] == '/')
+			(content_type_s[4] == '/' ||
+			 content_type_s[4] == 0))
 		{
 			(*writefunc)(" ", 1);
 			sprintf(buf, "%lu", (unsigned long)nbodylines);
diff -Naur Courier-imap-3.0.8/imap/msgenvelope.c courier-imap-3.0.8/imap/msgenvelope.c
--- Courier-imap-3.0.8/imap/msgenvelope.c	2004-06-09 04:14:21.000000000 +0530
+++ courier-imap-3.0.8/imap/msgenvelope.c	2009-05-31 10:08:30.000000000 +0530
@@ -15,7 +15,7 @@
 #include	<stdlib.h>
 #include	<string.h>
 
-static const char rcsid[]="$Id: msgenvelope.c,v 1.14 2004/04/11 17:35:35 mrsam Exp $";
+static const char rcsid[]="$Id: msgenvelope.c,v 1.15 2008/06/14 14:12:50 mrsam Exp $";
 
 #define	MAX_HEADER_SIZE	8192
 
@@ -158,9 +158,6 @@
 	for (i=0; i<a->naddrs; i++)
 	{
 		(*writefunc)("(", 1);
-		if (a->addrs[i].name && a->addrs[i].name->token == '"' &&
-			a->addrs[i].name->next == 0)
-			a->addrs[i].name->token=0;
 
 		q=rfc822_getname_orlist(a, i);
 		if (!q)
diff -Naur Courier-imap-3.0.8/imap/pop3dcapa.c courier-imap-3.0.8/imap/pop3dcapa.c
--- Courier-imap-3.0.8/imap/pop3dcapa.c	2002-10-25 17:49:50.000000000 +0530
+++ courier-imap-3.0.8/imap/pop3dcapa.c	2009-05-30 20:58:20.000000000 +0530
@@ -59,6 +59,6 @@
 	if (have_starttls())
 		printf("STLS\r\n");
 
-	printf("TOP\r\nUSER\r\nLOGIN-DELAY 10\r\nPIPELINING\r\nUIDL\r\nIMPLEMENTATION Courier Mail Server\r\n.\r\n");
+	printf("TOP\r\nUSER\r\nLOGIN-DELAY 10\r\nPIPELINING\r\nUIDL\r\n.\r\n");
 	fflush(stdout);
 }
diff -Naur Courier-imap-3.0.8/imap/pop3d.dist.in courier-imap-3.0.8/imap/pop3d.dist.in
--- Courier-imap-3.0.8/imap/pop3d.dist.in	2004-06-09 04:14:21.000000000 +0530
+++ courier-imap-3.0.8/imap/pop3d.dist.in	2009-05-30 20:58:20.000000000 +0530
@@ -85,7 +85,7 @@
 #
 # For use by webadmin
 
-POP3AUTH_ORIG="LOGIN CRAM-MD5 CRAM-SHA1"
+POP3AUTH_ORIG="PLAIN LOGIN CRAM-MD5 CRAM-SHA1"
 
 ##NAME: POP3AUTH_TLS:1
 #
diff -Naur Courier-imap-3.0.8/imap/pop3dserver.c courier-imap-3.0.8/imap/pop3dserver.c
--- Courier-imap-3.0.8/imap/pop3dserver.c	2004-09-13 04:55:56.000000000 +0530
+++ courier-imap-3.0.8/imap/pop3dserver.c	2009-05-30 20:58:20.000000000 +0530
@@ -60,82 +60,90 @@
 
 #define POP3DLIST "courierpop3dsizelist"
 
-extern void pop3dcapa();
-static void acctout(const char *disc);
+extern void     pop3dcapa();
+static void     acctout(const char *disc);
 
-static const char *authaddr, *remoteip;
+static const char *authaddr, *remoteip, *remoteport;
 
-struct msglist {
+struct msglist
+{
 	struct msglist *next;
-	char *filename;
-	int isdeleted;
-	int isnew;
-	off_t size;
-
-	struct {
-		unsigned long uidv;
-		unsigned long n;
-	} uid;
-	} ;
+	char           *filename;
+	int             isdeleted;
+	int             isnew;
+	off_t           size;
+
+	struct
+	{
+		unsigned long   uidv;
+		unsigned long   n;
+	}
+	uid;
+};
 
 static struct msglist *msglist_l;
 static struct msglist **msglist_a;
 static unsigned msglist_cnt;
 
 static struct stat enomem_stat;
-static int enomem_1msg;
+static int      enomem_1msg;
 
 /*
-** When a disk error occurs while saving an updated courierpop3dsizelist
-** file, proceed to recover as follows:
-**
-** If there's at least one existing message that's found in the old
-** courierpop3dsizelist, then ignore all new messages that were not found
-** in the old courierpop3dsizelist, and a new uid/uidv was assigned to them.
-** Therefore, the client doesn't see any new messages.  Hopefully, after
-** at least one existing message gets deleted, there'll be room to create
-** a new courierpop3dsizelist file next time, and record new messages.
-**
-** If none of the messages in the maildir could be found in the
-** courierpop3dsizelist, take the first message in the maildir only, and
-** use a UIDL that's derived from the message's dev_t/ino_t.  The client
-** will see that message only.  After deleting it, hopefully a new
-** courierpop3dsizelist file could be written out next time.
+ * When a disk error occurs while saving an updated courierpop3dsizelist
+ * file, proceed to recover as follows:
+ *
+ * If there's at least one existing message that's found in the old
+ * courierpop3dsizelist, then ignore all new messages that were not found
+ * in the old courierpop3dsizelist, and a new uid/uidv was assigned to them.
+ * Therefore, the client doesn't see any new messages.  Hopefully, after
+ * at least one existing message gets deleted, there'll be room to create
+ * a new courierpop3dsizelist file next time, and record new messages.
+ *
+ * If none of the messages in the maildir could be found in the
+ * courierpop3dsizelist, take the first message in the maildir only, and
+ * use a UIDL that's derived from the message's dev_t/ino_t.  The client
+ * will see that message only.  After deleting it, hopefully a new
+ * courierpop3dsizelist file could be written out next time.
 */
 
 
-static unsigned long top_count=0;
-static unsigned long retr_count=0;
+static unsigned long top_count = 0;
+static unsigned long retr_count = 0;
+unsigned long   bytes_sent_count = 0;
+unsigned long   bytes_received_count = 0;
 
-static unsigned long uidv=0;
-static int convert_v0=0;
+static unsigned long uidv = 0;
+static int      convert_v0 = 0;
 
-static time_t start_time;
+static time_t   start_time;
 
 /*
-** The RFC is pretty strict in stating that octet size must count the CR
-** in the CRLF endofline.
+ * The RFC is pretty strict in stating that octet size must count the CR
+ * in the CRLF endofline.
 */
 
-static void calcsize(struct msglist *m)
+static void
+calcsize(struct msglist *m)
 {
-FILE	*f=fopen(m->filename, "r");
-int	c, lastc;
+	FILE           *f = fopen(m->filename, "r");
+	int             c, lastc;
 
-	m->size=0;
+	m->size = 0;
 	if (f == 0)
 	{
 		perror("calcsize fopen");
 		return;
 	}
-	lastc='\n';
-	while ((c=getc(f)) >= 0)
+	lastc = '\n';
+	while ((c = getc(f)) >= 0)
 	{
-		if (c == '\n')	++m->size;
+		if (c == '\n')
+			++m->size;
 		++m->size;
-		lastc=c;
+		lastc = c;
 	}
-	if (lastc != '\n')	m->size += 2;
+	if (lastc != '\n')
+		m->size += 2;
 
 	if (ferror(f))
 	{
@@ -150,43 +158,42 @@
 ** Read courierpop3dsizelist
 */
 
-static int cmpmsgs(const void *a, const void *b);
+static int      cmpmsgs(const void *a, const void *b);
 
-static struct msglist **readpop3dlist(unsigned long *uid)
+static struct msglist **
+readpop3dlist(unsigned long *uid)
 {
 	struct msglist **a;
-	struct msglist *list=NULL;
-	size_t mcnt=0;
+	struct msglist *list = NULL;
+	size_t          mcnt = 0;
 
-	char linebuf[1024];
+	char            linebuf[1024];
 
-	FILE *fp=fopen(POP3DLIST, "r");
+	FILE           *fp = fopen(POP3DLIST, "r");
 
-	size_t i;
-	int vernum=0;
+	size_t          i;
+	int             vernum = 0;
 
-	uidv=time(NULL);
+	uidv = time(NULL);
 
-	convert_v0=0;
+	convert_v0 = 0;
 
-	if (fp == NULL ||
-	    fgets(linebuf, sizeof(linebuf)-1, fp) == NULL ||
-	    linebuf[0] != '/' || sscanf(linebuf+1, "%d %lu %lu", &vernum,
-					uid, &uidv)
-	    < 2 || (vernum != 1 && vernum != 2))
+	if (fp == NULL || fgets(linebuf, sizeof(linebuf) - 1, fp) == NULL || linebuf[0] != '/' ||
+		sscanf(linebuf + 1, "%d %lu %lu", &vernum, uid, &uidv) < 2 || (vernum != 1 && vernum != 2))
 	{
 		if (fp == NULL)
-			convert_v0=1;
+			convert_v0 = 1;
 
 		if (vernum == 0 && fp && fseek(fp, 0L, SEEK_SET) >= 0)
 		{
-			/* Old version 0 format courierpop3dsizelist file */
-		}
-		else
+			/*
+			 * Old version 0 format courierpop3dsizelist file 
+			 */
+		} else
 		{
 			if (fp)
 				fclose(fp);
-			fp=NULL;
+			fp = NULL;
 		}
 	}
 
@@ -194,62 +201,65 @@
 	{
 		struct msglist *m;
 
-		char *p, *q;
+		char           *p, *q;
 
-		size_t n=0;
-		int ch;
+		size_t          n = 0;
+		int             ch;
 
-		while ((ch=getc(fp)) != EOF)
+		while ((ch = getc(fp)) != EOF)
 		{
-			unsigned long sz;
+			unsigned long   sz;
 
 			if (ch != '\n')
 			{
-				if (n < sizeof(linebuf)-3)
-					linebuf[n++]=ch;
+				if (n < sizeof(linebuf) - 3)
+					linebuf[n++] = ch;
 				continue;
 			}
-			linebuf[n]=0;
-			n=0;
+			linebuf[n] = 0;
+			n = 0;
 
 			if (vernum == 0)
 				strcat(linebuf, " 0");
-			/* Convert version 0 to version 1 format - PRESTO! */
+			/*
+			 * Convert version 0 to version 1 format - PRESTO! 
+			 */
 
-			if ((p=strrchr(linebuf, ' ')) == NULL)
+			if ((p = strrchr(linebuf, ' ')) == NULL)
 				continue;
-			*p=0;
-			if ((q=strrchr(linebuf, ' ')) == NULL)
+			*p = 0;
+			if ((q = strrchr(linebuf, ' ')) == NULL)
 				continue;
-			*p=' ';
-			p=q;
-			*p++=0;
+			*p = ' ';
+			p = q;
+			*p++ = 0;
 
 			if (linebuf[0] == 0)
 				continue;
 
-			if ((m=(struct msglist *)malloc(sizeof(struct
-							       msglist))) == 0)
+			if ((m = (struct msglist *) malloc(sizeof(struct msglist))) == 0)
 			{
 				perror("malloc");
 				exit(1);
 			}
 
-			if ((m->filename=strdup(linebuf)) == NULL)
+			if ((m->filename = strdup(linebuf)) == NULL)
 			{
 				perror("malloc");
 				exit(1);
 			}
 
-			switch (sscanf(p, "%lu %lu:%lu", &sz,
-				       &m->uid.n, &m->uid.uidv)) {
+			switch (sscanf(p, "%lu %lu:%lu", &sz, &m->uid.n, &m->uid.uidv))
+			{
 			case 2:
-				m->uid.uidv=0;
-				/* FALLTHROUGH */
+				m->uid.uidv = 0;
+				/*
+				 * FALLTHROUGH 
+				 */
 			case 3:
-				m->size=sz;
-				m->next=list;
-				list=m;
+				m->size = sz;
+				m->next = list;
+				list = m;
 				++mcnt;
 				break;
 			default:
@@ -259,53 +269,48 @@
 		}
 		fclose(fp);
 	}
-	if ((a=(struct msglist **)malloc((mcnt+1)
-					 *sizeof(struct msglist *))) == 0)
+	if ((a = (struct msglist **) malloc((mcnt + 1) * sizeof(struct msglist *))) == 0)
 	{
 		perror("malloc");
 		exit(1);
 	}
 
-	for (i=0; list; list=list->next)
-		a[i++]=list;
+	for (i = 0; list; list = list->next)
+		a[i++] = list;
 
-	a[i]=NULL;
+	a[i] = NULL;
 	qsort(a, i, sizeof(*a), cmpmsgs);
 
 	return a;
 }
 
-static int savepop3dlist(struct msglist **a, size_t cnt,
-			  unsigned long uid)
+static int
+savepop3dlist(struct msglist **a, size_t cnt, unsigned long uid)
 {
-	FILE *fp;
-	size_t i;
+	FILE           *fp;
+	size_t          i;
 
 	struct maildir_tmpcreate_info createInfo;
 
 	maildir_tmpcreate_init(&createInfo);
 
-	createInfo.uniq="pop3";
-	createInfo.doordie=1;
-
-	if ((fp=maildir_tmpcreate_fp(&createInfo)) == NULL)
+	createInfo.uniq = "pop3";
+	createInfo.doordie = 1;
+	if ((fp = maildir_tmpcreate_fp(&createInfo)) == NULL)
 	{
 		maildir_tmpcreate_free(&createInfo);
 		return -1;
 	}
-
 	fprintf(fp, "/2 %lu %lu\n", uid, uidv);
-
-	for (i=0; i<cnt; i++)
+	for (i = 0; i < cnt; i++)
 	{
-		char *p=a[i]->filename;
-		char *q;
+		char           *p = a[i]->filename;
+		char           *q;
 
-		if ((q=strrchr(p, '/')) != NULL)
-			p=q+1;
+		if ((q = strrchr(p, '/')) != NULL)
+			p = q + 1;
 
-		fprintf(fp, "%s %lu %lu:%lu\n", p, (unsigned long)a[i]->size,
-			a[i]->uid.n, a[i]->uid.uidv);
+		fprintf(fp, "%s %lu %lu:%lu\n", p, (unsigned long) a[i]->size, a[i]->uid.n, a[i]->uid.uidv);
 	}
 
 	if (fflush(fp) || ferror(fp))
@@ -315,9 +320,7 @@
 		maildir_tmpcreate_free(&createInfo);
 		return -1;
 	}
-
-	if (fclose(fp) ||
-	    rename(createInfo.tmpname, POP3DLIST) < 0)
+	if (fclose(fp) || rename(createInfo.tmpname, POP3DLIST) < 0)
 	{
 		unlink(createInfo.tmpname);
 		maildir_tmpcreate_free(&createInfo);
@@ -330,37 +333,39 @@
 
 /* Scan cur, and pick up all messages contained therein */
 
-static int scancur()
+static int
+scancur()
 {
-DIR	*dirp;
-struct	dirent *de;
-struct	msglist *m;
+	DIR            *dirp;
+	struct dirent  *de;
+	struct msglist *m;
 
-	if ((dirp=opendir("cur")) == 0)
+	if ((dirp = opendir("cur")) == 0)
 	{
 		perror("scancur opendir(\"cur\")");
 		return 1;
 	}
 
-	while ((de=readdir(dirp)) != 0)
+	while ((de = readdir(dirp)) != 0)
 	{
-		if ( de->d_name[0] == '.' )	continue;
+		if (de->d_name[0] == '.')
+			continue;
 
-		if ((m=(struct msglist *)malloc(sizeof(struct msglist))) == 0)
+		if ((m = (struct msglist *) malloc(sizeof(struct msglist))) == 0)
 		{
 			perror("malloc");
 			exit(1);
 		}
-		if ((m->filename=(char *)malloc(strlen(de->d_name)+5)) == 0)
+		if ((m->filename = (char *) malloc(strlen(de->d_name) + 5)) == 0)
 		{
-			free( (char *)m);
+			free((char *) m);
 			perror("malloc");
 			exit(1);
 		}
 		strcat(strcpy(m->filename, "cur/"), de->d_name);
-		m->isdeleted=0;
-		m->next=msglist_l;
-		msglist_l=m;
+		m->isdeleted = 0;
+		m->next = msglist_l;
+		msglist_l = m;
 		msglist_cnt++;
 	}
 	closedir(dirp);
@@ -368,33 +373,36 @@
 }
 
 /*
-** When sorting messages, sort on the arrival date - the first part of the
-** name of the file in the maildir is the timestamp.
+ * When sorting messages, sort on the arrival date - the first part of the
+ * name of the file in the maildir is the timestamp.
 */
 
-static int cmpmsgs(const void *a, const void *b)
+static int
+cmpmsgs(const void *a, const void *b)
 {
-	const char *aname=(*(struct msglist **)a)->filename;
-	const char *bname=(*(struct msglist **)b)->filename;
-	const char *ap=strrchr(aname, '/');
-	const char *bp=strrchr(bname, '/');
-	long	na, nb;
+	const char     *aname = (*(struct msglist **) a)->filename;
+	const char     *bname = (*(struct msglist **) b)->filename;
+	const char     *ap = strrchr(aname, '/');
+	const char     *bp = strrchr(bname, '/');
+	long            na, nb;
 
 	if (ap)
 		++ap;
 	else
-		ap=aname;
+		ap = aname;
 
 	if (bp)
 		++bp;
 	else
-		bp=bname;
- 
-	na=atol(ap);
-	nb=atol(bp);
+		bp = bname;
 
-	if (na < nb)	return (-1);
-	if (na > nb)	return (1);
+	na = atol(ap);
+	nb = atol(bp);
+
+	if (na < nb)
+		return (-1);
+	if (na > nb)
+		return (1);
 
 	while (*ap || *bp)
 	{
@@ -412,71 +420,69 @@
 	return 0;
 }
 
-static void sortmsgs()
+static void
+sortmsgs()
 {
-	size_t i, n;
+	size_t          i, n;
 	struct msglist *m;
 	struct msglist **prev_list;
-	int savesizes=0;
+	int             savesizes = 0;
 
-	unsigned long nextuid;
+	unsigned long   nextuid;
 
-	if (msglist_cnt == 0)	return;
+	if (msglist_cnt == 0)
+		return;
 
-	if ((msglist_a=(struct msglist **)malloc(
-			msglist_cnt*sizeof(struct msglist *))) == 0)
+	if ((msglist_a = (struct msglist **) malloc(msglist_cnt * sizeof(struct msglist *))) == 0)
 	{
 		perror("malloc");
-		msglist_cnt=0;
+		msglist_cnt = 0;
 		return;
 	}
 
-	for (i=0, m=msglist_l; m; m=m->next, i++)
+	for (i = 0, m = msglist_l; m; m = m->next, i++)
 	{
-		m->isnew=0;
-		msglist_a[i]=m;
+		m->isnew = 0;
+		msglist_a[i] = m;
 	}
 	qsort(msglist_a, msglist_cnt, sizeof(*msglist_a), cmpmsgs);
 
-	nextuid=1;
+	nextuid = 1;
 
-	prev_list=readpop3dlist(&nextuid);
+	prev_list = readpop3dlist(&nextuid);
 
-	n=0;
+	n = 0;
 
-	for (i=0; i<msglist_cnt; i++)
+	for (i = 0; i < msglist_cnt; i++)
 	{
-		while (prev_list[n] &&
-		       cmpmsgs(&prev_list[n], &msglist_a[i]) < 0)
+		while (prev_list[n] && cmpmsgs(&prev_list[n], &msglist_a[i]) < 0)
 		{
 			++n;
-			savesizes=1;
+			savesizes = 1;
 		}
 
-		if (prev_list[n] &&
-		    cmpmsgs(&prev_list[n], &msglist_a[i]) == 0)
+		if (prev_list[n] && cmpmsgs(&prev_list[n], &msglist_a[i]) == 0)
 		{
-			msglist_a[i]->size=prev_list[n]->size;
-			msglist_a[i]->uid=prev_list[n]->uid;
+			msglist_a[i]->size = prev_list[n]->size;
+			msglist_a[i]->uid = prev_list[n]->uid;
 			n++;
-		}
-		else
+		} else
 		{
-			msglist_a[i]->uid.n=nextuid++;
-			msglist_a[i]->uid.uidv=uidv;
-			msglist_a[i]->isnew=1;
+			msglist_a[i]->uid.n = nextuid++;
+			msglist_a[i]->uid.uidv = uidv;
+			msglist_a[i]->isnew = 1;
 			if (convert_v0)
-				msglist_a[i]->uid.n=0;
+				msglist_a[i]->uid.n = 0;
 
 			calcsize(msglist_a[i]);
-			savesizes=1;
-		}      
+			savesizes = 1;
+		}
 	}
 
 	if (prev_list[n])
-		savesizes=1;
+		savesizes = 1;
 
-	for (i=0; prev_list[i]; i++)
+	for (i = 0; prev_list[i]; i++)
 	{
 		free(prev_list[i]->filename);
 		free(prev_list[i]);
@@ -486,65 +492,65 @@
 
 	if (savesizes && savepop3dlist(msglist_a, msglist_cnt, nextuid) < 0)
 	{
-		fprintf(stderr, "ERR: Error while saving courierpop3dsizelist"
-			", user=%s\n", authaddr);
+		fprintf(stderr, "ERR: Error while saving courierpop3dsizelist" ", user=%s\n", authaddr);
 
-		for (i=n=0; i<msglist_cnt; i++)
+		for (i = n = 0; i < msglist_cnt; i++)
 		{
 			if (msglist_a[i]->isnew)
 				continue;
 
-			msglist_a[n]=msglist_a[i];
+			msglist_a[n] = msglist_a[i];
 			++n;
 		}
 
-		if (n == 0 && n < msglist_cnt &&
-		    stat(msglist_a[0]->filename, &enomem_stat) == 0)
+		if (n == 0 && n < msglist_cnt && stat(msglist_a[0]->filename, &enomem_stat) == 0)
 		{
-			enomem_1msg=1;
+			enomem_1msg = 1;
 			++n;
 		}
-		msglist_cnt=n;
+		msglist_cnt = n;
 
 	}
 }
 
-static void mkupper(char *p)
+static void
+mkupper(char *p)
 {
 	while (*p)
 	{
-		*p=toupper(*p);
+		*p = toupper(*p);
 		p++;
 	}
 }
 
-static void cleanup()
+static void
+cleanup()
 {
-	unsigned i;
+	unsigned        i;
 
-	long deleted_bytes=0;
-	long deleted_messages=0;
+	long            deleted_bytes = 0;
+	long            deleted_messages = 0;
 
-	for (i=0; i<msglist_cnt; i++)
+	for (i = 0; i < msglist_cnt; i++)
 		if (msglist_a[i]->isdeleted)
 		{
-			unsigned long un=0;
+			unsigned long   un = 0;
 
-			const char *filename=msglist_a[i]->filename;
+			const char     *filename = msglist_a[i]->filename;
 
 			if (maildirquota_countfile(filename))
 			{
 				if (maildir_parsequota(filename, &un))
 				{
-					struct stat stat_buf;
+					struct stat     stat_buf;
 
 					if (stat(filename, &stat_buf) == 0)
-						un=stat_buf.st_size;
+						un = stat_buf.st_size;
 				}
 			}
 
 			if (unlink(msglist_a[i]->filename))
-				un=0;
+				un = 0;
 
 			if (un)
 			{
@@ -559,34 +565,50 @@
 	return;
 }
 
+static void
+printed(int cnt)
+{
+	if (cnt > 0)
+		bytes_sent_count += cnt;
+}
+
+static void
+printchar(int ch)
+{
+	putchar(ch);
+	printed(1);
+}
+
 /* POP3 STAT */
 
-static void do_stat()
+static void
+do_stat()
 {
-off_t	n=0;
-unsigned i, j;
-char	buf[NUMBUFSIZE];
+	off_t           n = 0;
+	unsigned        i, j;
+	char            buf[NUMBUFSIZE];
 
-	j=0;
-	for (i=0; i<msglist_cnt; i++)
+	j = 0;
+	for (i = 0; i < msglist_cnt; i++)
 	{
-		if (msglist_a[i]->isdeleted)	continue;
+		if (msglist_a[i]->isdeleted)
+			continue;
 		n += msglist_a[i]->size;
 		++j;
 	}
 
-	printf("+OK %u %s\r\n", j, libmail_str_off_t(n, buf));
+	printed(printf("+OK %u %s\r\n", j, libmail_str_off_t(n, buf)));
 	fflush(stdout);
 }
 
-static unsigned getmsgnum(const char *p)
+static unsigned
+getmsgnum(const char *p)
 {
-unsigned i;
+	unsigned        i;
 
-	if (!p || (i=atoi(p)) > msglist_cnt || i == 0 ||
-		msglist_a[i-1]->isdeleted)
+	if (!p || (i = atoi(p)) > msglist_cnt || i == 0 || msglist_a[i - 1]->isdeleted)
 	{
-		printf("-ERR Invalid message number.\r\n");
+		printed(printf("-ERR Invalid message number.\r\n"));
 		fflush(stdout);
 		return (0);
 	}
@@ -595,57 +617,58 @@
 
 /* POP3 LIST */
 
-static void do_list(const char *msgnum)
+static void
+do_list(const char *msgnum)
 {
-unsigned i;
-char	buf[NUMBUFSIZE];
+	unsigned        i;
+	char            buf[NUMBUFSIZE];
 
 	if (msgnum)
 	{
-		if ((i=getmsgnum(msgnum)) != 0)
+		if ((i = getmsgnum(msgnum)) != 0)
 		{
-			printf("+OK %u %s\r\n", i,
-				libmail_str_off_t(msglist_a[i-1]->size, buf));
+			printed(printf("+OK %u %s\r\n", i, libmail_str_off_t(msglist_a[i - 1]->size, buf)));
 			fflush(stdout);
 		}
 		return;
 	}
 
-	printf("+OK POP3 clients that break here, they violate STD53.\r\n");
-	for (i=0; i<msglist_cnt; i++)
+	printed(printf("+OK POP3 clients that break here, they violate STD53.\r\n"));
+	for (i = 0; i < msglist_cnt; i++)
 	{
-		if (msglist_a[i]->isdeleted)	continue;
-		printf("%u %s\r\n", i+1, libmail_str_off_t(msglist_a[i]->size, buf));
+		if (msglist_a[i]->isdeleted)
+			continue;
+		printed(printf("%u %s\r\n", i + 1, libmail_str_off_t(msglist_a[i]->size, buf)));
 	}
-	printf(".\r\n");
+	printed(printf(".\r\n"));
 	fflush(stdout);
 }
 
 /* RETR and TOP POP3 commands */
 
-static void do_retr(unsigned i, unsigned *lptr)
+static void
+do_retr(unsigned i, unsigned *lptr)
 {
-FILE	*f=fopen(msglist_a[i]->filename, "r");
-char	*p;
-int	c, lastc='\n';
-int	inheader=1;
-char	buf[NUMBUFSIZE];
-unsigned long *cntr;
+	FILE           *f = fopen(msglist_a[i]->filename, "r");
+	char           *p;
+	int             c, lastc = '\n';
+	int             inheader = 1;
+	char            buf[NUMBUFSIZE];
+	unsigned long  *cntr;
 
 	if (!f)
 	{
-		printf("-ERR Can't open the message file - it's gone!\r\n");
+		printed(printf("-ERR Can't open the message file - it's gone!\r\n"));
 		fflush(stdout);
 		return;
 	}
-	printf( (lptr ? "+OK headers follow.\r\n":"+OK %s octets follow.\r\n"),
-		libmail_str_off_t(msglist_a[i]->size, buf));
+	printed(printf((lptr ? "+OK headers follow.\r\n" : "+OK %s octets follow.\r\n"), libmail_str_off_t(msglist_a[i]->size, buf)));
 
-	cntr= &retr_count;
+	cntr = &retr_count;
 	if (lptr)
-		cntr= &top_count;
+		cntr = &top_count;
 
-	for (lastc=0; (c=getc(f)) >= 0; lastc=c)
+	for (lastc = 0; (c = getc(f)) >= 0; lastc = c)
 	{
 		if (lastc == '\n')
 		{
@@ -653,171 +676,187 @@
 			{
 				if (inheader)
 				{
-					if (c == '\n')	inheader=0;
-				}
-				else if ( (*lptr)-- == 0)	break;
+					if (c == '\n')
+						inheader = 0;
+				} else
+				if ((*lptr)-- == 0)
+					break;
 			}
 
 			if (c == '.')
-				putchar('.');
+				printchar('.');
 		}
-		if (c == '\n')	putchar('\r');
-		putchar(c);
+		if (c == '\n')
+			printchar('\r');
+		printchar(c);
 		++*cntr;
 	}
-	if (ferror(f)) {
-		/* Oops! All we can do is drop the connection */
-		fprintf(stderr, "ERR: I/O error while reading message file %s: %s\n",
-			msglist_a[i]->filename, strerror(errno));
+	if (ferror(f))
+	{
+		/*
+		 * Oops! All we can do is drop the connection 
+		 */
+		fprintf(stderr, "ERR: I/O error while reading message file %s: %s\n", msglist_a[i]->filename, strerror(errno));
 		acctout("INFO: I/O error disconnect");
 		exit(1);
 	}
-	if (lastc != '\n')	printf("\r\n");
-	printf(".\r\n");
+	if (lastc != '\n')
+		printed(printf("\r\n"));
+	printed(printf(".\r\n"));
 	fflush(stdout);
 	fclose(f);
-	if (lptr)	return;
+	if (lptr)
+		return;
 
-	if ((p=strchr(msglist_a[i]->filename, MDIRSEP[0])) != 0 &&
-		(p[1] != '2' || p[2] != ',' || strchr(p, 'S') != 0))
+	if ((p = strchr(msglist_a[i]->filename, MDIRSEP[0])) != 0 && (p[1] != '2' || p[2] != ',' || strchr(p, 'S') != 0))
 		return;
 
-	if ((p=malloc(strlen(msglist_a[i]->filename)+5)) == 0)
+	if ((p = malloc(strlen(msglist_a[i]->filename) + 5)) == 0)
 		return;
 
 	strcpy(p, msglist_a[i]->filename);
-	if (strchr(p, MDIRSEP[0]) == 0)	strcat(p, MDIRSEP "2,");
+	if (strchr(p, MDIRSEP[0]) == 0)
+		strcat(p, MDIRSEP "2,");
 	strcat(p, "S");
 
-	if (lptr	/* Don't mark as seen for TOP */
-	    || rename(msglist_a[i]->filename, p))
+	/*- Don't mark as seen for TOP */
+	if (lptr || rename(msglist_a[i]->filename, p))
 	{
 		free(p);
 		return;
 	}
 	free(msglist_a[i]->filename);
-	msglist_a[i]->filename=p;
+	msglist_a[i]->filename = p;
 }
 
-/*
-** The UIDL of the message is really just its filename, up to the first MDIRSEP character
-*/
+/*- The UIDL of the message is really just its filename, up to the first MDIRSEP character */
 
-static void print_uidl(unsigned i)
+static void
+print_uidl(unsigned i)
 {
-	const char *p;
+	const char     *p;
 
+	/*
+	 * Error recovery - out of disk space, see comments
+	 * at the beginning of this file.
+	 */
 	if (enomem_1msg)
-		/* Error recovery - out of disk space, see comments
-		** at the beginning of this file.
-		*/
-	{
-		char dev_buf[NUMBUFSIZE];
-		char ino_buf[NUMBUFSIZE];
-		char mtime_buf[NUMBUFSIZE];
-
-		printf("ENOMEM-%s-%s-%s\r\n",
-		       libmail_strh_time_t(enomem_stat.st_mtime, mtime_buf),
-		       libmail_strh_dev_t(enomem_stat.st_dev, dev_buf),
-		       libmail_strh_ino_t(enomem_stat.st_ino, ino_buf));
+	{
+		char            dev_buf[NUMBUFSIZE];
+		char            ino_buf[NUMBUFSIZE];
+		char            mtime_buf[NUMBUFSIZE];
+
+		printed(printf
+				("ENOMEM-%s-%s-%s\r\n", libmail_strh_time_t(enomem_stat.st_mtime, mtime_buf),
+				 libmail_strh_dev_t(enomem_stat.st_dev, dev_buf), libmail_strh_ino_t(enomem_stat.st_ino, ino_buf)));
 		return;
 	}
 
 	if (msglist_a[i]->uid.n != 0)
 	{
-		/* VERSION 1 and VERSION 2 UIDL */
+		/*- VERSION 1 and VERSION 2 UIDL */
 
-		printf((msglist_a[i]->uid.uidv ?
-			"UID%lu-%lu\r\n":"UID%lu\r\n"),
-		       msglist_a[i]->uid.n, msglist_a[i]->uid.uidv);
+		printed(printf((msglist_a[i]->uid.uidv ? "UID%lu-%lu\r\n" : "UID%lu\r\n"), msglist_a[i]->uid.n, msglist_a[i]->uid.uidv));
 		return;
 	}
 
-	/* VERSION 0 UIDL */
-
-	p=strchr(msglist_a[i]->filename, '/')+1;
+	/*- VERSION 0 UIDL */
+	p = strchr(msglist_a[i]->filename, '/') + 1;
 
 	while (*p && *p != MDIRSEP[0])
 	{
-		if (*p < 0x21 || *p > 0x7E || *p == '\'' || *p == '"' ||
-			*p == '+')
-			printf("+%02X", (int)(unsigned char)*p);
+		if (*p < 0x21 || *p > 0x7E || *p == '\'' || *p == '"' || *p == '+')
+			printed(printf("+%02X", (int) (unsigned char) *p));
 		else
-			putchar(*p);
+			printchar(*p);
 		++p;
 	}
-	printf("\r\n");
+	printed(printf("\r\n"));
 }
 
-static void do_uidl(const char *msgnum)
+static void
+do_uidl(const char *msgnum)
 {
-unsigned i;
+	unsigned        i;
 
 	if (msgnum)
 	{
-		if ((i=getmsgnum(msgnum)) != 0)
+		if ((i = getmsgnum(msgnum)) != 0)
 		{
-			printf("+OK %u ", i);
-			print_uidl(i-1);
+			printed(printf("+OK %u ", i));
+			print_uidl(i - 1);
 			fflush(stdout);
 		}
 		return;
 	}
-	printf("+OK\r\n");
-	for (i=0; i<msglist_cnt; i++)
+	printed(printf("+OK\r\n"));
+	for (i = 0; i < msglist_cnt; i++)
 	{
-		if (msglist_a[i]->isdeleted)	continue;
-		printf("%u ", i+1);
+		if (msglist_a[i]->isdeleted)
+			continue;
+		printed(printf("%u ", i + 1));
 		print_uidl(i);
 	}
-	printf(".\r\n");
+	printed(printf(".\r\n"));
 	fflush(stdout);
 }
 
-static void acctout(const char *disc)
+static void
+acctout(const char *disc)
 {
-	static const char msg2[]=", user=";
-	static const char msg3[]=", ip=[";
-	static const char msg4[]="], top=";
-	static const char msg5[]=", retr=";
-	static const char msg6[]=", time=";
-	static const char msg7[]=", stls=1";
-
-	char num1[NUMBUFSIZE];
-	char num2[NUMBUFSIZE];
-	char num3[NUMBUFSIZE];
+	static const char msg2[] = ", user=";
+	static const char msg3[] = ", ip=[";
+	static const char msgport[] = "], port=[";
+	static const char msg4[] = "], top=";
+	static const char msg5[] = ", retr=";
+	static const char msg6[] = ", time=";
+	static const char msg7[] = ", stls=1";
+	static const char msgAR[] = ", rcvd=";
+	static const char msgAS[] = ", sent=";
+
+	char            num1[NUMBUFSIZE];
+	char            num2[NUMBUFSIZE];
+	char            num3[NUMBUFSIZE];
+	char            numAR[NUMBUFSIZE];
+	char            numAS[NUMBUFSIZE];
 
-	char *p;
-	const char *q;
+	char           *p;
+	const char     *q;
 
 	libmail_str_size_t(top_count, num1);
 	libmail_str_size_t(retr_count, num2);
-	libmail_str_time_t(time(NULL)-start_time, num3);
-
-	p=malloc(strlen(authaddr)+strlen(remoteip)+strlen(disc)+
-		 strlen(num1)+strlen(num2)+200);	/* Should be enough */
+	libmail_str_time_t(time(NULL) - start_time, num3);
+	libmail_str_size_t(bytes_received_count, numAR);
+	libmail_str_size_t(bytes_sent_count, numAS);
 
+	p = malloc(strlen(authaddr) + strlen(remoteip) + strlen(remoteport) + strlen(disc) + strlen(num1) + strlen(num2) +
+			   strlen(num3) + strlen(numAR) + strlen(numAS) + 200);	/*- Should be enough */
 	strcpy(p, disc);
 	strcat(p, msg2);
 	strcat(p, authaddr);
 	strcat(p, msg3);
 	strcat(p, remoteip);
+	strcat(p, msgport);
+	strcat(p, remoteport);
 	strcat(p, msg4);
 	strcat(p, num1);
 	strcat(p, msg5);
 	strcat(p, num2);
+	strcat(p, msgAR);
+	strcat(p, numAR);
+	strcat(p, msgAS);
+	strcat(p, numAS);
 	strcat(p, msg6);
 	strcat(p, num3);
-
-	if ((q=getenv("POP3_STLS")) && atoi(q))
+	if ((q = getenv("POP3_TLS")) && atoi(q))
 		strcat(p, msg7);
-
 	strcat(p, "\n");
 	write(2, p, strlen(p));
 	free(p);
 }
 
-static RETSIGTYPE bye(int signum)
+static RETSIGTYPE
+bye(int signum)
 {
 	acctout("ERR: TIMEOUT");
 	exit(0);
@@ -826,27 +865,31 @@
 #endif
 }
 
-static void loop()
+static void
+loop()
 {
-char	buf[BUFSIZ];
-char	*p;
-int	c;
+	char            buf[BUFSIZ];
+	char           *p;
+	int             c;
 
 	signal(SIGALRM, bye);
 	while (alarm(300), fgets(buf, sizeof(buf), stdin))
 	{
+		bytes_received_count += strlen(buf);
 		alarm(0);
-		if ((p=strchr(buf, '\n')) != 0)
-			*p=0;
-		else while ((c=getc(stdin)) >= 0 && c != '\n')
-			;
-		p=strtok(buf, " \t\r");
-		if (!p)	p="";
+		if ((p = strchr(buf, '\n')) != 0)
+			*p = 0;
+		else
+			while ((c = getc(stdin)) >= 0 && c != '\n')
+				;
+		p = strtok(buf, " \t\r");
+		if (!p)
+			p = "";
 
 		mkupper(p);
 		if (strcmp(p, "QUIT") == 0)
 		{
-			printf("+OK Bye-bye.\r\n");
+			printed(printf("+OK Phir Khab Miloge2.\r\n"));
 			fflush(stdout);
 			cleanup();
 			acctout("INFO: LOGOUT");
@@ -867,12 +910,12 @@
 
 		if (strcmp(p, "RETR") == 0)
 		{
-		unsigned	i;
+			unsigned        i;
 
-			if ((i=getmsgnum(strtok(NULL, " \t\r"))) == 0)
+			if ((i = getmsgnum(strtok(NULL, " \t\r"))) == 0)
 				continue;
 
-			do_retr(i-1, 0);
+			do_retr(i - 1, 0);
 			continue;
 		}
 
@@ -884,49 +927,50 @@
 
 		if (strcmp(p, "DELE") == 0)
 		{
-		unsigned	i;
+			unsigned        i;
 
-			if ((i=getmsgnum(strtok(NULL, " \t\r"))) == 0)
+			if ((i = getmsgnum(strtok(NULL, " \t\r"))) == 0)
 				continue;
 
-			msglist_a[i-1]->isdeleted=1;
-			printf("+OK Deleted.\r\n");
+			msglist_a[i - 1]->isdeleted = 1;
+			printed(printf("+OK Deleted.\r\n"));
 			fflush(stdout);
 			continue;
 		}
 
 		if (strcmp(p, "NOOP") == 0)
 		{
-			printf("+OK Yup.\r\n");
+			printed(printf("+OK NOOP.\r\n"));
 			fflush(stdout);
 			continue;
 		}
 
 		if (strcmp(p, "RSET") == 0)
 		{
-		unsigned i;
+			unsigned        i;
 
-			for (i=0; i<msglist_cnt; i++)
-				msglist_a[i]->isdeleted=0;
-			printf("+OK Resurrected.\r\n");
+			for (i = 0; i < msglist_cnt; i++)
+				msglist_a[i]->isdeleted = 0;
+			printed(printf("+OK Resurrected.\r\n"));
 			fflush(stdout);
 			continue;
 		}
 
 		if (strcmp(p, "TOP") == 0)
 		{
-		unsigned	i, j;
-		const	char *q;
+			unsigned        i, j;
+			const char     *q;
 
-			if ((i=getmsgnum(strtok(NULL, " \t\r"))) == 0)
+			if ((i = getmsgnum(strtok(NULL, " \t\r"))) == 0)
 				continue;
 
-			q=strtok(NULL, " \t\r");
+			q = strtok(NULL, " \t\r");
 
-			if (!q)	goto error;
+			if (!q)
+				goto error;
 
-			j=atoi(q);
-			do_retr(i-1, &j);
+			j = atoi(q);
+			do_retr(i - 1, &j);
 			continue;
 		}
 
@@ -936,8 +980,8 @@
 			continue;
 		}
 
-error:
-		printf("-ERR Invalid command.\r\n");
+	  error:
+		printed(printf("-ERR Invalid command.\r\n"));
 		fflush(stdout);
 	}
 	acctout("ERR: DISCONNECTED");
@@ -945,23 +989,27 @@
 
 /* Like every good Maildir reader, we purge the tmp subdirectory */
 
-static void purgetmp()
+static void
+purgetmp()
 {
-DIR	*p=opendir("tmp");
-time_t	t;
-struct	dirent *de;
-struct	stat	stat_buf;
-char	*n;
+	DIR            *p = opendir("tmp");
+	time_t          t;
+	struct dirent  *de;
+	struct stat     stat_buf;
+	char           *n;
 
-	if (!p)	return;
-	time (&t);
+	if (!p)
+		return;
+	time(&t);
 	t -= 48L * 60L * 60L;
 
-	while ((de=readdir(p)) != 0)
+	while ((de = readdir(p)) != 0)
 	{
-		if (de->d_name[0] == '.')	continue;
-		n=malloc(strlen(de->d_name)+5);
-		if (!n)	continue;
+		if (de->d_name[0] == '.')
+			continue;
+		n = malloc(strlen(de->d_name) + 5);
+		if (!n)
+			continue;
 		strcat(strcpy(n, "tmp/"), de->d_name);
 		if (stat(n, &stat_buf) == 0 && stat_buf.st_mtime < t)
 			unlink(n);
@@ -973,79 +1021,93 @@
 
 #include	<unistd.h>
 
-int main(int argc, char **argv)
+int
+main(int argc, char **argv)
 {
-char	*p;
+	char           *p, *protocol;
+	uid_t           euid, uid;
 
+#ifdef HAVE_SETVBUF_IOLBF
+	setvbuf(stderr, NULL, _IOLBF, BUFSIZ);
+#endif
+	if (!(euid = geteuid()))
+	{
+		if (euid != (uid = getuid()))
+		{
+			if (setuid(uid))
+			{
+				fprintf(stderr, "imapd: setuid: %s\n", strerror(errno));
+				exit(1);
+			}
+		}
+	}
 	authmodclient();
-
 	time(&start_time);
-
-	if ((authaddr=getenv("AUTHADDR")) == 0 ||
-		(remoteip=getenv("TCPREMOTEIP")) == 0)
+	if (!(remoteip = getenv("TCPREMOTEIP")))
 	{
 		fprintf(stderr, "ERROR: Required environment variables not initialized.\n");
 		fflush(stderr);
-		exit (1);
+		exit(1);
+	}
+	if (!(remoteport = getenv("TCPREMOTEPORT")))
+		remoteport = "0";
+	if (!(authaddr = getenv("AUTHADDR")) || !*authaddr)
+	{
+		authaddr = getenv("AUTHENTICATED");
+		if (authaddr == NULL || *authaddr == 0)
+			authaddr = "nobody";
 	}
+	protocol = getenv("PROTOCOL");
+	if (!protocol || !*protocol)
+		protocol = "POP3";
 
 	{
-	struct	stat	buf;
+		struct stat     buf;
 
-		if ( stat(".", &buf) < 0 || buf.st_mode & S_ISVTX)
+		if (stat(".", &buf) < 0 || buf.st_mode & S_ISVTX)
 		{
-			fprintf(stderr, "INFO: LOCKED, user=%s, ip=[%s]\n",
-				authaddr, remoteip);
-			printf("-ERR Your account is temporarily unavailable (+t bit set on home directory).\r\n");
+			fprintf(stderr, "INFO: LOCKED, user=%s, ip=[%s], port=[%s]\n", authaddr, remoteip, remoteport);
+			printed(printf("-ERR Your account is temporarily unavailable (+t bit set on home directory).\r\n"));
 			exit(0);
 		}
 	}
-
-	if ((p=getenv("MAILDIR")) != 0 && *p)
+	if ((p = getenv("MAILDIR")) != 0 && *p)
 	{
 		if (chdir(p))
 		{
-			printf("-ERR Maildir: %s\r\n",strerror(errno));
+			printed(printf("-ERR Maildir: %s\r\n", strerror(errno)));
 			exit(1);
 		}
-	}
-	else if (argc > 1 && chdir(argv[1]))
+	} else
+	if (argc > 1 && chdir(argv[1]))
 	{
-		printf("-ERR Maildir: %s\r\n",strerror(errno));
+		printed(printf("-ERR Maildir: %s\r\n", strerror(errno)));
 		exit(1);
 	}
-	
 	maildir_loginexec();
-
-	p=authgetoptionenv("disablepop3");
-
+	p = authgetoptionenv("disablepop3");
 	if (p && atoi(p))
 	{
-		printf("-ERR POP3 access disabled for this account.\r\n");
+		printed(printf("-ERR POP3 access disabled for this account.\r\n"));
 		fflush(stdout);
 		exit(1);
 	}
-
 	free(p);
-
-
-	fprintf(stderr, "INFO: LOGIN, user=%s, ip=[%s]\n",
-			authaddr,
-			remoteip);
+	fprintf(stderr, "INFO: LOGIN, user=%s, ip=[%s], port=[%s], protocol=%s\n", authaddr, remoteip, remoteport, protocol);
 	fflush(stderr);
 
-	msglist_cnt=0;
-	msglist_l=0;
-	msglist_a=0;
+	msglist_cnt = 0;
+	msglist_l = 0;
+	msglist_a = 0;
 	purgetmp();
 	maildir_getnew(".", INBOX, NULL, NULL);
 	if (scancur())
 	{
-		printf("-ERR Maildir invalid (no 'cur' directory)\r\n");
+		printed(printf("-ERR Maildir invalid (no 'cur' directory)\r\n"));
 		return (0);
 	}
 	sortmsgs();
-	printf("+OK logged in.\r\n");
+	printed(printf("+OK logged in.\r\n"));
 	fflush(stdout);
 	loop();
 	return (0);
diff -Naur Courier-imap-3.0.8/imap/pop3login.c courier-imap-3.0.8/imap/pop3login.c
--- Courier-imap-3.0.8/imap/pop3login.c	2004-09-13 04:55:56.000000000 +0530
+++ courier-imap-3.0.8/imap/pop3login.c	2009-05-30 20:58:20.000000000 +0530
@@ -23,67 +23,76 @@
 #include	"tcpd/spipe.h"
 #include	"authlib/debug.h"
 
-static const char rcsid[]="$Id: pop3login.c,v 1.11 2004/09/12 23:25:56 mrsam Exp $";
+static const char rcsid[] = "$Id: pop3login.c,v 1.11 2004/09/12 23:25:56 mrsam Exp $";
 
-extern void pop3dcapa();
-extern int have_starttls();
-extern int tls_required();
+extern void     pop3dcapa();
+extern int      have_starttls();
+extern int      tls_required();
+static unsigned long bytes_sent_count = 0;
+static unsigned long bytes_received_count = 0;
 
-static int	starttls()
+char            tcpremoteip[28];
+
+static void
+printed(int cnt)
+{
+	if (cnt > 0)
+		bytes_sent_count += cnt;
+}
+
+static int
+starttls()
 {
-	int	pipefd[2];
-	pid_t	p;
-	int	waitstat;
+	int             pipefd[2];
+	pid_t           p;
+	int             waitstat;
 
 	if (libmail_streampipe(pipefd))
 	{
 		printf("-ERR libmail_streampipe() failed.");
 		return (-1);
 	}
-
-	p=fork();
-	if (p == -1)
+	if ((p = fork()) == -1)
 	{
 		close(pipefd[0]);
 		close(pipefd[1]);
 		printf("-ERR fork() failed.");
 		return (-1);
 	}
-
 	if (p == 0)
 	{
-	char	buf1[100];
-	char	dummy;
+		char            buf1[100];
+		char            dummy;
 
 		/*
-		** Fork once more, and let the parent exit,
-		** so that courieresmtpd doesn't have this
-		** child process.
-		*/
+		 * Fork once more, and let the parent exit,
+		 * so that courieresmtpd doesn't have this
+		 * child process.
+		 */
 
-		p=fork();
+		p = fork();
 		if (p == -1)
 		{
 			perror("fork");
 			exit(1);
 		}
-		if (p)	exit(0);
-
+		if (p)
+			exit(0);
 		close(pipefd[0]);
-		sprintf(buf1, "-localfd=%d", (int)pipefd[1]);
+		sprintf(buf1, "-localfd=%d", (int) pipefd[1]);
 		if (read(pipefd[1], &dummy, 1) != 1)
 			exit(0);
 
-		/* couriertls will have the socket on fd 0,
-		** and dup stderr on fd 1 */
+		/*
+		 * couriertls will have the socket on fd 0,
+		 * and dup stderr on fd 1 
+		 */
 
 		close(1);
 		dup(2);
-		execl( getenv("COURIERTLS"), "couriertls",
-			buf1, "-tcpd", "-server", (char *)0);
+		execl(getenv("COURIERTLS"), "couriertls", buf1, "-tcpd", "-server", (char *) 0);
 	}
-
-	printf("+OK Begin SSL/TLS negotiation now.\r\n");
+	printed(printf("+OK Begin SSL/TLS negotiation now.\r\n"));
 	fflush(stdout);
 	close(pipefd[1]);
 	close(0);
@@ -94,7 +103,7 @@
 		exit(1);
 	}
 	close(pipefd[0]);
-	write(1, "", 1);	/* child - exec OK now */
+	write(1, "", 1);			/*- child - exec OK now */
 	while (wait(&waitstat) != p)
 		;
 	putenv("POP3_STARTTLS=NO");
@@ -103,20 +112,23 @@
 	return (0);
 }
 
-static char *authresp(const char *s)
+static char    *
+authresp(const char *s)
 {
-char	*p;
-char	buf[BUFSIZ];
+	char           *p;
+	char            buf[BUFSIZ];
 
-	printf("+ %s\r\n", s);
+	printed(printf("+ %s\r\n", s));
 	fflush(stdout);
+	if (fgets(buf, sizeof(buf), stdin) == 0)
+		return (0);
+	if ((p = strchr(buf, '\n')) == 0)
+		return (0);
+	if (p > buf && p[-1] == '\r')
+		--p;
+	*p = 0;
 
-	if (fgets(buf, sizeof(buf), stdin) == 0)	return (0);
-	if ((p=strchr(buf, '\n')) == 0)	return (0);
-	if (p > buf && p[-1] == '\r')	--p;
-	*p=0;
-
-	p=strdup(buf);
+	p = strdup(buf);
 	if (!p)
 	{
 		perror("malloc");
@@ -125,166 +137,180 @@
 	return (p);
 }
 
-int main(int argc, char **argv)
+int
+main(int argc, char **argv)
 {
-char	*user=0;
-char	*p;
-char	buf[BUFSIZ];
-int	c;
-const	char *ip=getenv("TCPREMOTEIP");
-char authservice[40];
-char *q ;
-
+	int             c;
+	char            buf[BUFSIZ], authservice[40];
+	char           *user = 0, *p, *ptr, *q;
+	const char     *ip = getenv("TCPREMOTEIP");
+	const char     *port = getenv("TCPREMOTEPORT");
+
+#ifdef HAVE_SETVBUF_IOLBF
+	setvbuf(stderr, NULL, _IOLBF, BUFSIZ);
+#endif
 	if (!ip || !*ip)
 	{
 		fprintf(stderr, "ERR: No IP address\n");
 		fflush(stderr);
 		exit(1);
 	}
+	if (!port || !*port)
+	{
+		fprintf(stderr, "ERR: No TCPREMOTEPORT\n");
+		fflush(stderr);
+		exit(1);
+	}
 
 	auth_debug_login_init();
-
+	putenv("PROTOCOL=POP3");
 	if (authmoduser(argc, argv, 60, 5))
 	{
-		fprintf(stderr, "DEBUG: Connection, ip=[%s]\n", ip);
-		printf("+OK Hello there.\r\n");
-	}
-	else
+		fprintf(stderr, "INFO: Connection, ip=[%s]\n", ip);
+		printed(printf("+OK POP3 Server Ready.\r\n"));
+	} else
 	{
 		fprintf(stderr, "ERR: LOGIN FAILED, ip=[%s]\n", ip);
-		printf("-ERR Login failed.\r\n");
+		printed(printf("-ERR Login failed.\r\n"));
 	}
-
 	fflush(stdout);
 	fflush(stderr);
 	while (fgets(buf, sizeof(buf), stdin))
 	{
-		c=1;
-		for (p=buf; *p; p++)
+		bytes_received_count += strlen(buf);
+		c = 1;
+		for (p = buf; *p; p++)
 		{
 			if (*p == '\n')
 				break;
 
-			if (*p == ' ' || *p == '\t')	c=0;
+			if (*p == ' ' || *p == '\t')
+				c = 0;
 			if (c)
-				*p=toupper((int)(unsigned char)*p);
+				*p = toupper((int) (unsigned char) *p);
 		}
 
 		if (*p)
-			*p=0;
-		else while ((c=getchar()) != EOF && c != '\n')
-			;
-		p=strtok(buf, " \t\r");
+			*p = 0;
+		else
+			while ((c = getchar()) != EOF && c != '\n')
+				bytes_received_count++;
+		p = strtok(buf, " \t\r");
 		if (p)
 		{
-			auth_debug_login( 1, "command=%s", p );
-
-			if ( strcmp(p, "QUIT") == 0)
+			auth_debug_login(1, "command=%s", p);
+			if (strcmp(p, "QUIT") == 0)
 			{
-				fprintf(stderr, "INFO: LOGOUT, ip=[%s]\n",
-					ip);
-				fflush(stderr);
-				printf("+OK Better luck next time.\r\n");
+				printed(printf("+OK Phir Khab Miloge.\r\n"));
 				fflush(stdout);
+				fprintf(stderr, "INFO: LOGOUT, ip=[%s], port=%s, rcvd=%lu, sent=%lu\n", ip, port, bytes_received_count,
+						bytes_sent_count);
+				fflush(stderr);
 				break;
 			}
-
-			if ( strcmp(p, "USER") == 0)
+			if (strcmp(p, "USER") == 0)
 			{
 				if (tls_required())
 				{
-					printf("-ERR TLS required to log in.\r\n");
+					printed(printf("-ERR TLS required to log in.\r\n"));
 					fflush(stdout);
 					continue;
 				}
 
-				p=strtok(0, "\r\n");
+				p = strtok(0, "\r\n");
 				if (p)
 				{
-					if (user)	free(user);
-					if ((user=malloc(strlen(p)+1)) == 0)
+					if (user)
+						free(user);
+					if ((user = malloc(strlen(p) + 1)) == 0)
 					{
-						printf("-ERR Server out of memory, aborting connection.\r\n");
+						printed(printf("-ERR Server out of memory, aborting connection.\r\n"));
 						fflush(stdout);
 						perror("malloc");
 						exit(1);
 					}
 					strcpy(user, p);
-					printf("+OK Password required.\r\n");
+					if ((ptr = strchr(user, ':')) != (char *) 0)
+					{
+						*ptr = 0;
+						snprintf(tcpremoteip, 28, "TCPREMOTEIP=%s", ptr + 1);
+						putenv(tcpremoteip);
+					}
+					printed(printf("+OK Password required.\r\n"));
 					fflush(stdout);
 					continue;
 				}
-			} else if (strcmp(p, "CAPA") == 0)
+			} else
+			if (strcmp(p, "CAPA") == 0)
 			{
 				pop3dcapa();
 				continue;
-			} else if (strcmp(p, "STLS") == 0)
+			} else
+			if (strcmp(p, "STLS") == 0)
 			{
 				if (!have_starttls())
 				{
-					printf("-ERR TLS support not available.\r\n");
+					printed(printf("-ERR TLS support not available.\r\n"));
 					fflush(stdout);
 					continue;
 				}
 				starttls();
 				fflush(stdout);
 				continue;
-			} else if (strcmp(p, "AUTH") == 0)
+			} else
+			if (strcmp(p, "AUTH") == 0)
 			{
-				char *authtype, *authdata;
-				char	*method=strtok(0, " \t\r");
+				char           *authtype, *authdata;
+				char           *method = strtok(0, " \t\r");
 
 				if (tls_required())
 				{
-					printf("-ERR TLS required to log in.\r\n");
+					printed(printf("-ERR TLS required to log in.\r\n"));
 					fflush(stdout);
 					continue;
 				}
-
 				if (method)
 				{
-				char *initreply=strtok(0, " \t\r");
-				int	rc=authsasl(method, initreply,
-						authresp, &authtype, &authdata);
-
+					char           *initreply = strtok(0, " \t\r");
+					int             rc = authsasl(method, initreply,
+												  authresp, &authtype, &authdata);
 					if (rc == 0)
 					{
-						strcat(strcpy(authservice, "AUTHSERVICE"),getenv("TCPLOCALPORT"));
-						q=getenv(authservice);
+						strcat(strcpy(authservice, "AUTHSERVICE"), getenv("TCPLOCALPORT"));
+						q = getenv(authservice);
 						if (!q || !*q)
-							q="pop3";
-
-						authmod(argc-1, argv+1,	q, authtype, authdata);
+							q = "pop3";
+						authmod(argc - 1, argv + 1, q, authtype, authdata);
 					}
-
 					if (rc == AUTHSASL_ABORTED)
-					    printf("-ERR Authentication aborted.\r\n");
+						printed(printf("-ERR Authentication aborted.\r\n"));
 					else
-					    printf("-ERR Authentication failed.\r\n");
+						printed(printf("-ERR Authentication failed.\r\n"));
 
 					fflush(stdout);
 					continue;
 				}
-			} else if (strcmp(p, "PASS") == 0)
+			} else
+			if (strcmp(p, "PASS") == 0)
 			{
-				p=strtok(0, "\r\n");
+				p = strtok(0, "\r\n");
 
 				if (!user || p == 0)
 				{
-					printf("-ERR USER/PASS required.\r\n");
+					printed(printf("-ERR USER/PASS required.\r\n"));
 					fflush(stdout);
 					continue;
 				}
 
-				strcat(strcpy(authservice, "AUTHSERVICE"),getenv("TCPLOCALPORT"));
-				q=getenv(authservice);
+				strcat(strcpy(authservice, "AUTHSERVICE"), getenv("TCPLOCALPORT"));
+				q = getenv(authservice);
 				if (!q || !*q)
-					q="pop3";
+					q = "pop3";
 
-				authmod_login(argc-1, argv+1, q, user, p);
+				authmod_login(argc - 1, argv + 1, q, user, p);
 			}
 		}
-		printf("-ERR Invalid command.\r\n");
+		printed(printf("-ERR Invalid command.\r\n"));
 		fflush(stdout);
 	}
 	exit(0);
diff -Naur Courier-imap-3.0.8/imap/search.c courier-imap-3.0.8/imap/search.c
--- Courier-imap-3.0.8/imap/search.c	2004-09-03 06:49:08.000000000 +0530
+++ courier-imap-3.0.8/imap/search.c	2009-05-31 10:10:51.000000000 +0530
@@ -1,5 +1,5 @@
 /*
-** Copyright 1998 - 2003 Double Precision, Inc.
+** Copyright 1998 - 2008 Double Precision, Inc.
 ** See COPYING for distribution information.
 */
 
@@ -28,7 +28,7 @@
 #include	"imaptoken.h"
 #include	"imapscanclient.h"
 
-static const char rcsid[]="$Id: search.c,v 1.31 2004/09/02 01:35:04 mrsam Exp $";
+static const char rcsid[]="$Id: search.c,v 1.33 2008/09/20 12:48:29 mrsam Exp $";
 
 extern time_t rfc822_parsedt(const char *);
 extern struct imapscaninfo current_maildir_info;
@@ -236,6 +236,16 @@
 
 				fill_search_body(sihead, mycharset, rfcp, fp,
 					current_maildir_info.msgs+i);
+
+				/*
+				** If there are still UNKNOWN nodes, change
+				** them to fail.
+				*/
+
+				for (p=sihead; p; p=p->next)
+					if (p->value < 0)
+						p->value=0;
+
 				rc=search_evaluate(si);
                                 rfc2045_free(rfcp);
 			}
@@ -1034,6 +1044,15 @@
 	}
 	rfc2045_cdecode_start(rfcp, search_body_func, &slb);
 
+	for (sip=si; sip; sip=sip->next)
+		if ((sip->type == search_text || sip->type == search_body)
+		    && sip->bs
+		    && sip->value <= 0)
+		{
+			si->value=0;
+			maildir_search_reset(&si->sei);
+		}
+
 	rc=0;
 	while (start_body < end_pos)
 	{
diff -Naur Courier-imap-3.0.8/imap/smap.c courier-imap-3.0.8/imap/smap.c
--- Courier-imap-3.0.8/imap/smap.c	2004-06-26 20:41:50.000000000 +0530
+++ courier-imap-3.0.8/imap/smap.c	2009-05-31 10:13:04.000000000 +0530
@@ -44,7 +44,6 @@
 #include	"mailboxlist.h"
 #include	"thread.h"
 #include	"outbox.h"
-#include	"authlib/authmod.h"
 
 #include	"imapwrite.h"
 #include	"imaptoken.h"
@@ -67,7 +66,7 @@
 
 #define SMAP_BUFSIZ 8192
 
-static const char rcsid[]="$Id: smap.c,v 1.23 2004/06/13 19:20:04 mrsam Exp $";
+static const char rcsid[]="$Id: smap.c,v 1.27 2005/11/21 23:36:47 mrsam Exp $";
 #define SHARED "shared"
 
 #define LIST_FOLDER 1
@@ -366,28 +365,21 @@
 
 	if (maildir_acl_read(&l, utf8->homedir, strchr(f, '.')) == 0)
 	{
-		const char *owner_array[3];
-		maildir_aclt aa;
-		char *o;
-
-		owner_array[0]=o=malloc(sizeof("user=")+
-					strlen(getenv("AUTHENTICATED")));
-		if (o == NULL)
+		char *myrights;
+		char *owner=malloc(sizeof("user=")+strlen(utf8->owner));
+
+		if (!owner)
 			write_error_exit(0);
-		strcat(strcpy(o, "user="), getenv("AUTHENTICATED"));
-		owner_array[1]= strcmp(utf8->owner, getenv("AUTHENTICATED"))
-			? NULL:"owner";
-		owner_array[2]=NULL;
-
-		if (maildir_acl_compute_array(&aa, &l, owner_array) == 0)
-		{
-			if (strchr(maildir_aclt_ascstr(&aa),
-				   ACL_LOOKUP[0]) != NULL)
-				(*utf8->callback_func)(f, fn,
-						       utf8->callback_arg);
-			maildir_aclt_destroy(&aa);
-		}
-		free(o);
+
+		strcat(strcpy(owner, "user="), utf8->owner);
+		myrights=compute_myrights(&l, owner);
+		free(owner);
+
+		if (myrights && strchr(myrights, ACL_LOOKUP[0]) != NULL)
+			(*utf8->callback_func)(f, fn, utf8->callback_arg);
+		if (myrights)
+			free(myrights);
+
 		maildir_aclt_list_destroy(&l);
 	}
 	maildir_smapfn_free(fn);
@@ -2334,7 +2326,7 @@
 
 	q=strrchr(strrchr(p, '/'), MDIRSEP[0]);
 
-	if (strcmp(q, ":2,") == 0)
+	if (strcmp(q, MDIRSEP "2,") == 0)
 	{
 		*q=0;
 		memcpy(strrchr(p, '/')-3, "new", 3);
@@ -3136,7 +3128,7 @@
 			aclminimum(err_failedrights);
 			writes("\n");
 		}
-		writes("+ERR ACL update failed\n");
+		writes("-ERR ACL update failed\n");
 		maildir_aclt_list_destroy(&aclt_list);
 		return 0;
 	}
@@ -4144,6 +4136,7 @@
 				if (q) free(q);
 				maildir_info_destroy(&minfo);
 				accessdenied(ACL_READ);
+				maildir_info_destroy(&minfo);
 				continue;
 			}
 			current_mailbox_acl=q;
@@ -4156,8 +4149,10 @@
 					" in maildir_name2dir(%s,%s)\n",
 					minfo.homedir,
 					minfo.maildir);
+				maildir_info_destroy(&minfo);
 				continue;
 			}
+			maildir_info_destroy(&minfo);
 
 			snapshot_select(snapshot != NULL);
 
diff -Naur Courier-imap-3.0.8/imap/smapsnapshot.c courier-imap-3.0.8/imap/smapsnapshot.c
--- Courier-imap-3.0.8/imap/smapsnapshot.c	2004-01-20 08:22:03.000000000 +0530
+++ courier-imap-3.0.8/imap/smapsnapshot.c	2009-05-30 20:58:20.000000000 +0530
@@ -66,7 +66,7 @@
 #endif
 #endif
 
-static const char rcsid[]="$Id: smapsnapshot.c,v 1.3 2004/01/20 02:52:03 mrsam Exp $";
+static const char rcsid[]="$Id: smapsnapshot.c,v 1.4 2005/11/21 23:36:47 mrsam Exp $";
 
 extern int keywords();
 
@@ -372,6 +372,7 @@
 		}
 	}
 
+	fclose(courierimapuiddb);
 	if (keywords())
 		imapscan_restoreKeywordSnapshot(fp, new_index);
 	return 1;
@@ -570,6 +571,8 @@
 			free(n);
 		}
 	}
+	if (dirp)
+		closedir(dirp);
 
 	/* Step 2: drop snapshots that are definitely obsolete */
 
diff -Naur Courier-imap-3.0.8/imap/storeinfo.c courier-imap-3.0.8/imap/storeinfo.c
--- Courier-imap-3.0.8/imap/storeinfo.c	2004-01-20 08:22:03.000000000 +0530
+++ courier-imap-3.0.8/imap/storeinfo.c	2009-05-31 10:13:41.000000000 +0530
@@ -40,7 +40,7 @@
 #endif
 #endif
 
-static const char rcsid[]="$Id: storeinfo.c,v 1.26 2004/01/20 02:52:03 mrsam Exp $";
+static const char rcsid[]="$Id: storeinfo.c,v 1.27 2008/06/21 16:01:23 mrsam Exp $";
 
 #if SMAP
 extern int smapflag;
@@ -65,6 +65,7 @@
 extern struct imapscaninfo current_maildir_info;
 extern char *current_mailbox;
 extern char *current_mailbox_acl;
+extern int fastkeywords();
 
 int storeinfo_init(struct storeinfo *si)
 {
@@ -173,6 +174,8 @@
 
 			if (rc == 0)
 			{
+				if (fastkeywords())
+					changedKeywords=1;
 				current_maildir_info.msgs[n].changedflags=1;
 			}
 		}
@@ -201,6 +204,8 @@
 						 .keywordMsg,
 						 kme->libmail_keywordEntryPtr)==0)
 				{
+					if (fastkeywords())
+						changedKeywords=1;
 					current_maildir_info.msgs[n]
 						.changedflags=1;
 				}
diff -Naur Courier-imap-3.0.8/imap/thread.c courier-imap-3.0.8/imap/thread.c
--- Courier-imap-3.0.8/imap/thread.c	2004-06-09 04:14:22.000000000 +0530
+++ courier-imap-3.0.8/imap/thread.c	2009-05-30 20:58:20.000000000 +0530
@@ -3,7 +3,7 @@
 ** See COPYING for distribution information.
 */
 
-static const char rcsid[]="$Id: thread.c,v 1.13 2004/04/11 22:45:04 mrsam Exp $";
+static const char rcsid[]="$Id: thread.c,v 1.14 2006/01/13 01:29:36 mrsam Exp $";
 
 #include	"config.h"
 #include	"imapd.h"
@@ -409,7 +409,7 @@
 			break;
 		}
 	search_internal(si, sihead, mycharset, isuid, sort_callback, &sm);
-	if (sm.nmsgs >= 0)
+	if (sm.nmsgs > 0)
 	{
 	size_t	i;
 	struct sortmsginfo *o;
diff -Naur Courier-imap-3.0.8/INSTALL courier-imap-3.0.8/INSTALL
--- Courier-imap-3.0.8/INSTALL	2004-09-19 00:26:10.000000000 +0530
+++ courier-imap-3.0.8/INSTALL	2009-05-30 20:58:20.000000000 +0530
@@ -261,7 +261,7 @@
        Your PAM library may use pam_pwdb.so instead of pam_unix.so; consult
        the documentation for your PAM library for more information.
 
-   configure should automatically detect if you use vpopmail, and compile and
+   configure should automatically detect if you use indimail, and compile and
    install the authvchkpw authentication module.
 
    After running make install or make install-strip you will then have to
@@ -551,8 +551,8 @@
        databases), but implements CRAM-MD5 authentication. See below for more
        information.
      * authvchkpw - this is another virtual mail database lookup module,
-       except that it uses the vpopmail vpasswd files. This module is
-       provided for a quick way to use your existing vpopmail vpasswd files.
+       except that it uses the indimail vpasswd files. This module is
+       provided for a quick way to use your existing indimail vpasswd files.
        Where possible, you should convert over to /etc/userdb. The included
        script vchkpw2userdb(8) might be of some help in doing so.
      * authldap - authenticates against an LDAP server. This is a new module
@@ -593,7 +593,7 @@
        modules are usually not necessary, because the PAM library, or the
        LDAP server, provides this functionality. If PAM support is
        unavailable, these modules will be installed by default.
-     * authvchkpw - this module is compiled by default only if the vpopmail
+     * authvchkpw - this module is compiled by default only if the indimail
        account is defined.
      * authmysql - this module is compiled if MySQL client libraries are
        available.
@@ -798,7 +798,7 @@
 
    This authentication module is provided for legacy support. New installs
    should use the authuserdb module. It is possible to convert
-   vpopmail/vchkpw single userid authentication passwd files to /etc/userdb
+   indimail/vchkpw single userid authentication passwd files to /etc/userdb
    using the vchkpw2userdb script. See vchkpw2userdb(8) for more information.
 
 LDAP AUTHENTICATION MODULE
diff -Naur Courier-imap-3.0.8/INSTALL.html.in courier-imap-3.0.8/INSTALL.html.in
--- Courier-imap-3.0.8/INSTALL.html.in	2004-07-28 06:48:19.000000000 +0530
+++ courier-imap-3.0.8/INSTALL.html.in	2009-05-30 20:58:20.000000000 +0530
@@ -291,7 +291,7 @@
 </ul>
 
 <p><code>configure</code> should automatically detect if you use
-<code>vpopmail</code>, and compile and install the <code>authvchkpw</code>
+<code>indimail</code>, and compile and install the <code>authvchkpw</code>
 authentication module.</p>
 
 <p>After running <code>make install</code> or <code>make install-strip</code>
@@ -601,8 +601,8 @@
     <code>authuserdb</code> (it uses the same databases), but implements
     CRAM-MD5 authentication. See below for more information.</li>
   <li><code>authvchkpw</code> - this is another virtual mail database lookup
-    module, except that it uses the vpopmail vpasswd files. This module is
-    provided for a quick way to use your existing vpopmail vpasswd files.
+    module, except that it uses the indimail vpasswd files. This module is
+    provided for a quick way to use your existing indimail vpasswd files.
     Where possible, you should convert over to <code>/etc/userdb</code>. The
     included script <code>vchkpw2userdb(8)</code> might be of some help in
     doing so.</li>
@@ -652,7 +652,7 @@
     server, provides this functionality. If PAM support is unavailable, these
     modules will be installed by default.</li>
   <li><code>authvchkpw</code> - this module is compiled by default only if
-    the <code>vpopmail</code> account is defined.</li>
+    the <code>indimail</code> account is defined.</li>
   <li><code>authmysql</code> - this module is compiled if MySQL client
     libraries are available.</li>
   <li><code>authpgsql</code> - this module is compiled if PostgreSQL client
@@ -859,7 +859,7 @@
 
 <p>This authentication module is provided for legacy support. New installs
 should use the <code>authuserdb</code> module. It is possible to convert
-vpopmail/vchkpw single userid authentication passwd files to
+indimail/vchkpw single userid authentication passwd files to
 <code>@userdb@</code> using the <code>vchkpw2userdb</code> script. See
 <code>vchkpw2userdb(8)</code> for more information.</p>
 
diff -Naur Courier-imap-3.0.8/libhmac/hmac.c courier-imap-3.0.8/libhmac/hmac.c
--- Courier-imap-3.0.8/libhmac/hmac.c	1999-12-07 05:11:55.000000000 +0530
+++ courier-imap-3.0.8/libhmac/hmac.c	2009-05-30 20:58:20.000000000 +0530
@@ -9,7 +9,7 @@
 
 #include	"hmac.h"
 
-static const char rcsid[]="$Id: hmac.c,v 1.3 1999/12/06 23:41:55 mrsam Exp $";
+static const char rcsid[]="$Id: hmac.c,v 1.4 2006/01/22 03:37:04 mrsam Exp $";
 
 struct hmac_hashinfo *hmac_list[]= {HMAC_LIST};
 
@@ -62,7 +62,7 @@
 	(*i->hh->hh_hash)(i->context, i->k, i->kl);
 	(*i->hh->hh_endhash)(i->context, i->kl);
 	(*i->hh->hh_getdigest)(i->context, keybuf);
-	i->k=keybuf;
+	i->k=(char *)keybuf;
 	i->kl=i->hh->hh_L;
 	dokeycalc(i);
 }
diff -Naur Courier-imap-3.0.8/liblock/lockdaemon.c courier-imap-3.0.8/liblock/lockdaemon.c
--- Courier-imap-3.0.8/liblock/lockdaemon.c	2003-01-05 09:31:16.000000000 +0530
+++ courier-imap-3.0.8/liblock/lockdaemon.c	2009-05-30 20:58:20.000000000 +0530
@@ -1,5 +1,5 @@
 /*
-** Copyright 2000-2001 Double Precision, Inc.  See COPYING for
+** Copyright 2000-2007 Double Precision, Inc.  See COPYING for
 ** distribution information.
 */
 
@@ -7,9 +7,11 @@
 #include	"liblock.h"
 #include	<stdio.h>
 #include	<signal.h>
+#include	<limits.h>
 #include	<stdlib.h>
 #include	<string.h>
 #include	<unistd.h>
+#include	<ctype.h>
 #include	<errno.h>
 #if	HAVE_FCNTL_H
 #include	<fcntl.h>
@@ -31,7 +33,7 @@
 
 #define exit(_a_) _exit(_a_)
 
-static const char rcsid[]="$Id: lockdaemon.c,v 1.7 2003/01/05 04:01:16 mrsam Exp $";
+static const char rcsid[]="$Id: lockdaemon.c,v 1.14 2007/10/11 01:46:34 mrsam Exp $";
 
 static int start1(const char *, int);
 
@@ -109,7 +111,7 @@
 
 static int start1(const char *lockfile, int fd)
 {
-int	lockfd;
+int	lockfd, maxfd;
 
 #if     HAVE_SETPGRP
 #if     SETPGRP_VOID
@@ -134,12 +136,38 @@
 
 	/* Attempt to obtain a lock */
 
-	if ((lockfd=open(lockfile, O_RDWR|O_CREAT, 0600)) < 0)
+	lockfd=open(lockfile, O_RDWR|O_CREAT, 0600);
+
+	if (lockfd < 0)
+	{
+		/* Perhaps an upgraded daemon runs under new uid? */
+
+		unlink(lockfile);
+		lockfd=open(lockfile, O_RDWR|O_CREAT, 0600);
+	}
+
+#if HAVE_GETDTABLESIZE
+	maxfd=getdtablesize()-1;
+#elif defined(OPEN_MAX)
+	maxfd=OPEN_MAX-1;
+#elif HAVE_SYSCONF && defined(_SC_OPEN_MAX)
+	if ((maxfd=sysconf(_SC_OPEN_MAX)) < 0)
+		maxfd=63;
+	else if (maxfd > 0)
+		maxfd--;
+#else
+	maxfd=63;
+#endif
+
+	if (lockfd < 0 || dup2(lockfd, maxfd) != maxfd)
 	{
 		perror(lockfile);
 		exit(1);
 	}
 
+	close(lockfd);
+	lockfd=maxfd;
+
 #ifdef	FD_CLOEXEC
 	if (fcntl(lockfd, F_SETFD, FD_CLOEXEC) < 0)
 	{
@@ -151,7 +179,9 @@
 
 	if (ll_lock_ex_test(lockfd))
 	{
-		write(fd, "", 1);
+		if (write(fd, "", 1) != 1)
+			exit(1); /* Shouldn't happen */
+
 		close(fd);
 		exit (0);	/* Already running, pretend success */
 	}
@@ -187,9 +217,9 @@
 {
 char	buf[NUMBUFSIZE+1];
 char	*p=strcat(libmail_str_pid_t(getpid(), buf), "\n");
-size_t	l=strlen(p);
 FILE	*fp;
 
+	unlink(pidfile); 
 	if ((fp=fopen(pidfile, "w")) == NULL ||
 		fprintf(fp, "%s", p) < 0 || fflush(fp) < 0 || fclose(fp))
 	{
@@ -197,7 +227,8 @@
 		exit(1);
 	}
 
-	write(fd, "", 1);	/* Signal waiting parent */
+	if (write(fd, "", 1) != 1)	/* Signal waiting parent */
+		exit(1); /* Shouldn't happen */
 	close(fd);
 }
 
diff -Naur Courier-imap-3.0.8/maildir/maildirkeywords2.c courier-imap-3.0.8/maildir/maildirkeywords2.c
--- Courier-imap-3.0.8/maildir/maildirkeywords2.c	2004-01-11 08:17:33.000000000 +0530
+++ courier-imap-3.0.8/maildir/maildirkeywords2.c	2009-05-30 20:58:20.000000000 +0530
@@ -1,5 +1,5 @@
 /*
-** Copyright 2003 Double Precision, Inc.
+** Copyright 2003-2007 Double Precision, Inc.
 ** See COPYING for distribution information.
 */
 
@@ -39,7 +39,7 @@
 #endif
 #endif
 
-static const char rcsid[]="$Id: maildirkeywords2.c,v 1.7 2004/01/11 02:47:33 mrsam Exp $";
+static const char rcsid[]="$Id: maildirkeywords2.c,v 1.8 2007/04/16 22:31:53 mrsam Exp $";
 
 int libmail_kwEnabled=1;
 
@@ -199,8 +199,6 @@
 
 	if (!updateInfo)
 	{
-		if (updateInfo)
-			free(updateInfo);
 		free(kwname);
 		return;
 	}
@@ -248,6 +246,7 @@
 		{
 			rki->errorOccured=-1;
 			rl_free(&rl);
+			libmail_kwmDestroy(tmpMsg);
 			return 0;
 		}
 
diff -Naur Courier-imap-3.0.8/maildir/maildirnewshared2.c courier-imap-3.0.8/maildir/maildirnewshared2.c
--- Courier-imap-3.0.8/maildir/maildirnewshared2.c	2004-01-20 08:22:04.000000000 +0530
+++ courier-imap-3.0.8/maildir/maildirnewshared2.c	2009-05-30 20:58:20.000000000 +0530
@@ -1,5 +1,5 @@
 /*
-** Copyright 2004 Double Precision, Inc.
+** Copyright 2004-2007 Double Precision, Inc.
 ** See COPYING for distribution information.
 */
 
@@ -35,7 +35,7 @@
 #include	"config.h"
 #include	"maildir/maildirnewshared.h"
 
-static const char rcsid[]="$Id: maildirnewshared2.c,v 1.1 2004/01/20 02:52:04 mrsam Exp $";
+static const char rcsid[]="$Id: maildirnewshared2.c,v 1.2 2007/04/16 22:31:53 mrsam Exp $";
 
 static struct maildir_shindex_cache *shared_cache=NULL;
 
@@ -89,6 +89,12 @@
 		subhierarchy="";
 	}
 
+
+	if (!subhierarchy)
+		return NULL;
+	/* Should not happen, bad usage. subhierarchy allowed to be NULL only
+	** when indexfile is also NULL */
+
 	p=do_shared_cache_read(indexfile, subhierarchy);
 
 	if (!p)
diff -Naur Courier-imap-3.0.8/maildir/maildirpurgetmp.c courier-imap-3.0.8/maildir/maildirpurgetmp.c
--- Courier-imap-3.0.8/maildir/maildirpurgetmp.c	2003-03-22 07:16:54.000000000 +0530
+++ courier-imap-3.0.8/maildir/maildirpurgetmp.c	2009-05-30 20:58:20.000000000 +0530
@@ -95,6 +95,9 @@
 	int nfiles;
 	long nbytes;
 
+	int nfiles2;
+	long nbytes2;
+
 	p=strrchr(maildir, '/');
 	if (p)
 		++p;
@@ -106,8 +109,13 @@
 	if (!m)	return;
 	strcat(strcpy(m, maildir), "/cur");
 	dopurge(m, nage, &nfiles, &nbytes);
+	strcat(strcpy(m, maildir), "/new");
+	dopurge(m, nage, &nfiles2, &nbytes2);
 	free(m);
 
+	nfiles += nfiles2;
+	nbytes += nbytes2;
+
 	if (adjustquota && nfiles > 0)
 		maildir_quota_deleted(maildir, -nbytes, -nfiles);
 }
diff -Naur Courier-imap-3.0.8/maildir/maildirquota.c courier-imap-3.0.8/maildir/maildirquota.c
--- Courier-imap-3.0.8/maildir/maildirquota.c	2004-06-26 20:41:50.000000000 +0530
+++ courier-imap-3.0.8/maildir/maildirquota.c	2009-05-30 20:58:20.000000000 +0530
@@ -1,5 +1,5 @@
 /*
-** Copyright 1998 - 2004 Double Precision, Inc.
+** Copyright 1998 - 2006 Double Precision, Inc.
 ** See COPYING for distribution information.
 */
 
@@ -48,7 +48,7 @@
 #include	<ctype.h>
 #include	<numlib/numlib.h>
 
-static const char rcsid[]="$Id: maildirquota.c,v 1.25 2004/06/18 23:43:40 mrsam Exp $";
+static const char rcsid[]="$Id: maildirquota.c,v 1.30 2006/05/28 15:29:52 mrsam Exp $";
 
 static void parsequotastr(const char *, struct maildirquota *);
 
@@ -488,8 +488,8 @@
 	if (doaddquota(info, maildirsize_fd, maildirsize_size,
 		maildirsize_cnt, 1))
 	{
-		free(newmaildirsizename);
 		unlink(newmaildirsizename);
+		free(newmaildirsizename);
 		close(maildirsize_fd);
 		errno=EIO;
 		return (-1);
@@ -691,7 +691,11 @@
 int	n;
 
 	if ( *subdir != '.' || strcmp(subdir, ".") == 0 ||
-		strcmp(subdir, "..") == 0 || strcmp(subdir, "." TRASH) == 0)
+		strcmp(subdir, "..") == 0
+#ifndef TRASHQUOTA
+				|| strcmp(subdir, "." TRASH) == 0
+#endif
+		)
 		return (0);
 
 	p=(char *)malloc(strlen(dir)+strlen(subdir)+2);
@@ -978,7 +982,7 @@
 
 static void do_deliver_warning(const char *msgfile, const char *dir)
 {
-int	fdin, fd;
+int	fdin, fd, ret;
 FILE *fpout;
 time_t	t;
 size_t	l, msg_len;
@@ -1004,7 +1008,9 @@
 
 	strcat(strcpy(qname, dir), "/quotawarn");
 	time(&t);
-	if (stat(qname, &sb) == 0 && ((sb.st_mtime + 86400) > t))
+	ret = stat(qname, &sb);
+	if ((ret == -1 && errno != ENOENT) ||
+	    (ret == 0 && (sb.st_mtime + 86400) > t))
 	{
 		free(qname);
 		close(fdin);
@@ -1013,12 +1019,14 @@
 
 	fd = open(qname, O_WRONLY|O_CREAT|O_TRUNC, 0644);
 	free(qname);
-	if (!fd)
+	if (fd == -1)
 	{
 		close(fdin);
 		return;
 	}
-	write(fd, buf, 1);
+	if (write(fd, buf, 1) < 0)
+		perror(msgfile);
+
 	close(fd);
 
 	strcpy(buf, "Date: ");
@@ -1028,8 +1036,8 @@
 	hostname[0]=0;
 	hostname[sizeof(hostname)-1]=0;
 	gethostname(hostname, sizeof(hostname)-1);
-	sprintf(buf, "%sMessage-Id: <%lu.overquota@%-1.256s>\n",
-		buf, (unsigned long)t, hostname);
+	sprintf(buf+strlen(buf), "Message-Id: <%lu.overquota@%-1.256s>\n",
+		(unsigned long)t, hostname);
 
 	if (stat(msgfile, &sb) < 0) {
 		close(fdin);
@@ -1055,7 +1063,11 @@
 
 	while ((n=read(fdin, buf, sizeof(buf))) > 0)
 	{
-		fwrite(buf, n, 1, fpout);
+		if (fwrite(buf, n, 1, fpout) != 1)
+		{
+			perror(createInfo.tmpname);
+			break;
+		}
 	}
 	close(fdin);
 
diff -Naur Courier-imap-3.0.8/maildir/maildirrename.c courier-imap-3.0.8/maildir/maildirrename.c
--- Courier-imap-3.0.8/maildir/maildirrename.c	2004-03-12 17:35:54.000000000 +0530
+++ courier-imap-3.0.8/maildir/maildirrename.c	2009-05-30 20:58:20.000000000 +0530
@@ -125,9 +125,6 @@
 			rc=0;
 			for (n=0; a[n]; n++)
 			{
-				if (rename_func)
-					(*rename_func)(a[n]->o,
-						       a[n]->n);
 				if (rename(a[n]->o, a[n]->n))
 				{
 					rc= -1;
@@ -141,6 +138,9 @@
 					}
 					break;
 				}
+				if (rename_func)
+					(*rename_func)(a[n]->o,
+						       a[n]->n);
 			}
 			free(a);
 		}
diff -Naur Courier-imap-3.0.8/maildir/maildirshared.c courier-imap-3.0.8/maildir/maildirshared.c
--- Courier-imap-3.0.8/maildir/maildirshared.c	2004-01-11 08:17:33.000000000 +0530
+++ courier-imap-3.0.8/maildir/maildirshared.c	2009-05-30 20:58:20.000000000 +0530
@@ -1,5 +1,5 @@
 /*
-** Copyright 2000-2003 Double Precision, Inc.
+** Copyright 2000-2007 Double Precision, Inc.
 ** See COPYING for distribution information.
 */
 
@@ -41,7 +41,7 @@
 #include	"maildircreate.h"
 #include	"maildirsharedrc.h"
 
-static const char rcsid[]="$Id: maildirshared.c,v 1.20 2004/01/11 02:47:33 mrsam Exp $";
+static const char rcsid[]="$Id: maildirshared.c,v 1.23 2007/04/16 22:31:53 mrsam Exp $";
 
 /* Prerequisited for shared folder support */
 
@@ -754,10 +754,14 @@
 	}
 	if ((fd=maildir_safeopen(shared_update_name, O_RDWR|O_CREAT, 0600))>= 0)
 	{
-		write(fd, "", 1);
+		if (write(fd, "", 1) < 0)
+			perror("write");
 		close(fd);
 	}
 
+	free(cur);
+	free(shared_update_name);
+
 	if (create_db(&obj, dir, &dbname))	return;
 
 	if (build_db(shared, &obj))
@@ -887,11 +891,13 @@
 	return (-1);
 }
 
+#if 0
 char *maildir_shareddir(const char *maildir, const char *sharedname)
 {
 	errno=EINVAL;
 	return (0);
 }
+#endif
 
 void maildir_shared_sync(const char *maildir)
 {
diff -Naur Courier-imap-3.0.8/Makefile.am courier-imap-3.0.8/Makefile.am
--- Courier-imap-3.0.8/Makefile.am	2004-08-30 00:33:28.000000000 +0530
+++ courier-imap-3.0.8/Makefile.am	2009-05-30 20:58:20.000000000 +0530
@@ -209,6 +209,7 @@
 	rm -f $(DESTDIR)$(man8dir)/vchkpw2userdb.8
 	$(LN_S) makeuserdb.8 $(DESTDIR)$(man8dir)/pw2userdb.8
 	$(LN_S) makeuserdb.8 $(DESTDIR)$(man8dir)/vchkpw2userdb.8
+	chmod 4755 $(DESTDIR)/$(prefix)/libexec/authlib/authshadow || true;chown root:root $(DESTDIR)/$(prefix)/man/man7/authlib.7 || true
 	. authlib/authdaemonrc ; test "$$authdaemonvar" = "" && exit 0; \
 		$(mkinstalldirs) $(DESTDIR)$$authdaemonvar ; \
 		chmod 700 $(DESTDIR)$$authdaemonvar
@@ -305,7 +306,7 @@
 
 all-make-check:
 	$(MAKE) all-gmake-check FOO=BAR
-	@test -f authlib/authvchkpw.flag || exit 0; cat authlib/authvchkpw.flag; sleep 15
+	@test -f authlib/authvchkpw.flag || exit 0; cat authlib/authvchkpw.flag
 
 all-gmake-check:
 	@test "$(FOO)" = "BAR" && exit 0 ; echo "" ; \
diff -Naur Courier-imap-3.0.8/Makefile.in courier-imap-3.0.8/Makefile.in
--- Courier-imap-3.0.8/Makefile.in	2004-09-19 00:19:13.000000000 +0530
+++ courier-imap-3.0.8/Makefile.in	2009-05-30 20:58:20.000000000 +0530
@@ -1068,6 +1068,7 @@
 	rm -f $(DESTDIR)$(man8dir)/vchkpw2userdb.8
 	$(LN_S) makeuserdb.8 $(DESTDIR)$(man8dir)/pw2userdb.8
 	$(LN_S) makeuserdb.8 $(DESTDIR)$(man8dir)/vchkpw2userdb.8
+	chmod 4755 $(DESTDIR)/$(prefix)/libexec/authlib/authshadow || true
 	. authlib/authdaemonrc ; test "$$authdaemonvar" = "" && exit 0; \
 		$(mkinstalldirs) $(DESTDIR)$$authdaemonvar ; \
 		chmod 700 $(DESTDIR)$$authdaemonvar
diff -Naur Courier-imap-3.0.8/numlib/changeuidgid.c courier-imap-3.0.8/numlib/changeuidgid.c
--- Courier-imap-3.0.8/numlib/changeuidgid.c	2003-01-05 09:31:17.000000000 +0530
+++ courier-imap-3.0.8/numlib/changeuidgid.c	2009-05-30 20:58:20.000000000 +0530
@@ -25,7 +25,7 @@
 {
 	if ( setgid(gid))
 	{
-		perror("setgid");
+		fprintf(stderr, "authchangegroup: setgid: %d: %s\n", gid, strerror(errno));
 		exit(1);
 	}
 
@@ -83,7 +83,7 @@
 
 	if ( setgid( changegid ))
 	{
-		perror("setgid");
+		fprintf(stderr, "authchangeusername: setgid: %d: %s\n", changegid, strerror(errno));
 		exit(1);
 	}
 
diff -Naur Courier-imap-3.0.8/rfc2045/rfc2045_fromfd.c courier-imap-3.0.8/rfc2045/rfc2045_fromfd.c
--- Courier-imap-3.0.8/rfc2045/rfc2045_fromfd.c	2003-03-07 06:17:31.000000000 +0530
+++ courier-imap-3.0.8/rfc2045/rfc2045_fromfd.c	2009-05-30 20:58:20.000000000 +0530
@@ -1,10 +1,10 @@
 /*
-** Copyright 1998 - 1999 Double Precision, Inc.  See COPYING for
+** Copyright 1998 - 2008 Double Precision, Inc.  See COPYING for
 ** distribution information.
 */
 
 /*
-** $Id: rfc2045_fromfd.c,v 1.7 2003/03/07 00:47:31 mrsam Exp $
+** $Id: rfc2045_fromfd.c,v 1.8 2008/10/12 03:05:49 mrsam Exp $
 */
 #if	HAVE_CONFIG_H
 #include "rfc2045_config.h"
@@ -55,7 +55,7 @@
         if (lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1)        return (NULL);
         if ((rfc=rfc2045_alloc()) == 0)        return (NULL);
 
-        while ((n=read(fd, buf, sizeof(buf))) > 0 && rfc->workinheader)
+        while (rfc->workinheader && (n=read(fd, buf, sizeof(buf))) > 0)
                 rfc2045_parse(rfc, buf, n);
         if (lseek(fd, orig_pos, SEEK_SET) == (off_t)-1)
         {
diff -Naur Courier-imap-3.0.8/rfc822/encode.c courier-imap-3.0.8/rfc822/encode.c
--- Courier-imap-3.0.8/rfc822/encode.c	2004-05-25 08:14:30.000000000 +0530
+++ courier-imap-3.0.8/rfc822/encode.c	2009-05-30 20:58:20.000000000 +0530
@@ -4,7 +4,7 @@
 */
 
 /*
-** $Id: encode.c,v 1.3 2004/05/25 02:44:30 mrsam Exp $
+** $Id: encode.c,v 1.5 2005/11/16 02:23:15 mrsam Exp $
 */
 #include	"encode.h"
 #include	<string.h>
@@ -20,157 +20,6 @@
 static int eflush(struct libmail_encode_info *,
 		 const char *, size_t);
 
-static const char *libmail_encode_autodetect(const char *charset, 
-					     int (*func)(void *), void *arg)
-{
-	const char *encoding="7bit";
-	int	l=0;
-	int	longline=0;
-	int c;
-#if	HAVE_LIBUNICODE
-	const struct unicode_info *ci = unicode_find(charset);
-#endif
-
-	while ((c = (*func)(arg)) != EOF)
-	{
-		unsigned char ch= (unsigned char)c;
-
-		if (ch >= 0x80)
-		{
-
-#if	HAVE_LIBUNICODE
-			if (!charset || !*charset)
-				encoding="8bit";
-			else if (ci && ci->flags & UNICODE_BODY_QUOPRI)
-				encoding="quoted-printable";
-			else if (!ci || ci->flags & UNICODE_BODY_BASE64)
-				encoding="base64";
-			else
-				encoding="8bit";
-#else
-			encoding="8bit";
-#endif
-		}
-
-		if (ch < 0x20 &&
-		    ch != '\t' && ch != '\r' && ch != '\n')
-		{
-#if	HAVE_LIBUNICODE
-			if (!charset || !*charset)
-				;
-			else if (ci && ci->flags & UNICODE_BODY_QUOPRI)
-				encoding="quoted-printable";
-			else if (!ci || ci->flags & UNICODE_BODY_BASE64)
-				encoding="base64";
-#else
-			if (charset && *charset)
-				encoding="quoted-printable";
-#endif
-                }
-
-		if (ch == 0)
-			return "base64";
-
-		if (ch == '\n')	l=0;
-		else if (++l > 990)
-		{
-			longline=1;
-#if	HAVE_LIBUNICODE
-			if (ci && ci->flags & UNICODE_BODY_QUOPRI)
-				encoding="quoted-printable";
-#else
-			if (charset && *charset)
-				encoding="quoted-printable";
-#endif
-		}
-
-	}
-
-	if (longline)
-	{
-#if	HAVE_LIBUNICODE
-		if (ci && ci->flags & UNICODE_BODY_QUOPRI)
-			encoding="quoted-printable";
-		else
-			encoding="base64";
-#else
-		if (charset && *charset)
-			encoding="quoted-printable";
-		else
-			encoding="base64";
-#endif
-	}
-	return encoding;
-}
-
-struct file_info {
-	FILE *fp;
-	off_t pos;
-	off_t end;
-};
-
-static int read_file(void *arg)
-{
-int c;
-struct file_info *fi = (struct file_info *)arg;
-	if (fi->end >= 0 && fi->pos > fi->end)
-		return EOF;
-	c = getc(fi->fp);
-	fi->pos++;
-	return c;
-}
-
-static int read_string(void * arg)
-{
-int c;
-unsigned char **strp = (unsigned char **)arg;
-	if (**strp == 0)
-		return EOF;
-	c = (int)**strp;
-	(*strp)++;
-	return c;
-}
-
-const char *libmail_encode_autodetect_fp(FILE *fp, int okQp)
-{
-	if (okQp)
-		return libmail_encode_autodetect_fppos(fp, "ISO-8859-1", 0, -1);
-	else
-		return libmail_encode_autodetect_fppos(fp, NULL, 0, -1);
-}
-
-const char *libmail_encode_autodetect_fppos(FILE *fp, const char *charset,
-					    off_t start_pos, off_t end_pos)
-{
-struct file_info fi;
-off_t orig_pos = ftell(fp);
-off_t pos = orig_pos;
-const char *rc;
-
-	if (start_pos >= 0)
-	{
-		if (fseek(fp, start_pos, SEEK_SET) == (off_t)-1)
-			return NULL;
-		else
-			pos = start_pos;
-	}
-
-	fi.fp = fp;
-	fi.pos = pos;
-	fi.end = end_pos;
-	rc = libmail_encode_autodetect(charset, &read_file, &fi);
-  
-	if (fseek(fp, orig_pos, SEEK_SET) == (off_t)-1)
-		return NULL;
-	return rc;
-}
-
-const char *libmail_encode_autodetect_str(const char *str, const char *charset)
-{
-	return libmail_encode_autodetect(charset, &read_string, &str);
-}
-
-
 void libmail_encode_start(struct libmail_encode_info *info,
 			  const char *transfer_encoding,
 			  int (*callback_func)(const char *, size_t, void *),
@@ -183,6 +32,7 @@
 	case 'q':
 	case 'Q':
 		info->encoding_func=quoted_printable;
+		info->input_buffer[0]=0; /* Recycle for qp encoding */
 		break;
 	case 'b':
 	case 'B':
@@ -342,6 +192,40 @@
 
 	while (n)
 	{
+
+
+		/*
+		** Repurpose input_buffer[0] as a flag whether the previous
+		** character was a space.
+		**
+		** A space before a newline gets escaped.
+		*/
+
+		if (info->input_buffer[0])
+		{
+			if (*p == '\n')
+			{
+				QPUT('=');
+				QPUT('2');
+				QPUT('0');
+			}
+			else
+			{
+				QPUT(' ');
+			}
+			++info->input_buf_cnt;
+		}
+
+		info->input_buffer[0]=0;
+
+		if (*p == ' ')
+		{
+			info->input_buffer[0]=1;
+			p++;
+			--n;
+			continue;
+		}
+
 		if (info->input_buf_cnt > 72 && *p != '\n')
 		{
 			QPUT('=');
@@ -373,3 +257,153 @@
 
 	return 0;
 }
+
+static const char *libmail_encode_autodetect(const char *charset, 
+					     int (*func)(void *), void *arg)
+{
+	const char *encoding="7bit";
+	int	l=0;
+	int	longline=0;
+	int c;
+#if	HAVE_LIBUNICODE
+	const struct unicode_info *ci = unicode_find(charset);
+#endif
+
+	while ((c = (*func)(arg)) != EOF)
+	{
+		unsigned char ch= (unsigned char)c;
+
+		if (ch >= 0x80)
+		{
+
+#if	HAVE_LIBUNICODE
+			if (!charset || !*charset)
+				encoding="8bit";
+			else if (ci && ci->flags & UNICODE_BODY_QUOPRI)
+				encoding="quoted-printable";
+			else if (!ci || ci->flags & UNICODE_BODY_BASE64)
+				encoding="base64";
+			else
+				encoding="8bit";
+#else
+			encoding="8bit";
+#endif
+		}
+
+		if (ch < 0x20 &&
+		    ch != '\t' && ch != '\r' && ch != '\n')
+		{
+#if	HAVE_LIBUNICODE
+			if (!charset || !*charset)
+				;
+			else if (ci && ci->flags & UNICODE_BODY_QUOPRI)
+				encoding="quoted-printable";
+			else if (!ci || ci->flags & UNICODE_BODY_BASE64)
+				encoding="base64";
+#else
+			if (charset && *charset)
+				encoding="quoted-printable";
+#endif
+                }
+
+		if (ch == 0)
+			return "base64";
+
+		if (ch == '\n')	l=0;
+		else if (++l > 990)
+		{
+			longline=1;
+#if	HAVE_LIBUNICODE
+			if (ci && ci->flags & UNICODE_BODY_QUOPRI)
+				encoding="quoted-printable";
+#else
+			if (charset && *charset)
+				encoding="quoted-printable";
+#endif
+		}
+
+	}
+
+	if (longline)
+	{
+#if	HAVE_LIBUNICODE
+		if (ci && ci->flags & UNICODE_BODY_QUOPRI)
+			encoding="quoted-printable";
+		else
+			encoding="base64";
+#else
+		if (charset && *charset)
+			encoding="quoted-printable";
+		else
+			encoding="base64";
+#endif
+	}
+	return encoding;
+}
+
+struct file_info {
+	FILE *fp;
+	off_t pos;
+	off_t end;
+};
+
+static int read_file(void *arg)
+{
+int c;
+struct file_info *fi = (struct file_info *)arg;
+	if (fi->end >= 0 && fi->pos > fi->end)
+		return EOF;
+	c = getc(fi->fp);
+	fi->pos++;
+	return c;
+}
+
+static int read_string(void * arg)
+{
+int c;
+unsigned char **strp = (unsigned char **)arg;
+	if (**strp == 0)
+		return EOF;
+	c = (int)**strp;
+	(*strp)++;
+	return c;
+}
+
+const char *libmail_encode_autodetect_fp(FILE *fp, int okQp)
+{
+	if (okQp)
+		return libmail_encode_autodetect_fppos(fp, "ISO-8859-1", 0, -1);
+	else
+		return libmail_encode_autodetect_fppos(fp, NULL, 0, -1);
+}
+
+const char *libmail_encode_autodetect_fppos(FILE *fp, const char *charset,
+					    off_t start_pos, off_t end_pos)
+{
+struct file_info fi;
+off_t orig_pos = ftell(fp);
+off_t pos = orig_pos;
+const char *rc;
+
+	if (start_pos >= 0)
+	{
+		if (fseek(fp, start_pos, SEEK_SET) == (off_t)-1)
+			return NULL;
+		else
+			pos = start_pos;
+	}
+
+	fi.fp = fp;
+	fi.pos = pos;
+	fi.end = end_pos;
+	rc = libmail_encode_autodetect(charset, &read_file, &fi);
+  
+	if (fseek(fp, orig_pos, SEEK_SET) == (off_t)-1)
+		return NULL;
+	return rc;
+}
+
+const char *libmail_encode_autodetect_str(const char *str, const char *charset)
+{
+	return libmail_encode_autodetect(charset, &read_string, &str);
+}
diff -Naur Courier-imap-3.0.8/rfc822/imaprefs.c courier-imap-3.0.8/rfc822/imaprefs.c
--- Courier-imap-3.0.8/rfc822/imaprefs.c	2003-07-10 03:03:20.000000000 +0530
+++ courier-imap-3.0.8/rfc822/imaprefs.c	2009-05-30 20:58:20.000000000 +0530
@@ -4,7 +4,7 @@
 */
 
 /*
-** $Id: imaprefs.c,v 1.10 2003/07/09 21:33:20 mrsam Exp $
+** $Id: imaprefs.c,v 1.11 2008/12/02 03:41:19 mrsam Exp $
 */
 
 #include	"config.h"
@@ -254,7 +254,7 @@
 	{
 		char *msgid=rfc822_getaddr(a, n);
 
-		msg=*msgid ? rfc822_threadsearchmsg(mt, msgid ? msgid:""):0;
+		msg=msgid ? rfc822_threadsearchmsg(mt, msgid):0;
 		if (!msg)
 		{
 			msg=rfc822_threadallocmsg(mt, msgid ? msgid:"");
diff -Naur Courier-imap-3.0.8/rfc822/rfc2047.c courier-imap-3.0.8/rfc822/rfc2047.c
--- Courier-imap-3.0.8/rfc822/rfc2047.c	2004-06-09 04:14:29.000000000 +0530
+++ courier-imap-3.0.8/rfc822/rfc2047.c	2009-05-30 20:58:20.000000000 +0530
@@ -11,9 +11,8 @@
 
 #include	"rfc822.h"
 #include	"rfc2047.h"
-#include	"../unicode/unicode.h"
 
-static const char rcsid[]="$Id: rfc2047.c,v 1.18 2004/05/29 15:35:29 mrsam Exp $";
+static const char rcsid[]="$Id: rfc2047.c,v 1.20 2006/01/22 03:33:24 mrsam Exp $";
 
 #define	RFC2047_ENCODE_FOLDLENGTH	76
 
@@ -526,7 +525,8 @@
 			int (*func)(const char *, size_t, void *), void *arg,
 			size_t foldlen, size_t offset)
 {
-	unsigned char ibuf[3], obuf[4];
+	unsigned char ibuf[3];
+	char obuf[4];
 	int	i, rc;
 
 	while (len)
@@ -590,6 +590,9 @@
 			!(*qp_allow)(i))
 
 #if	HAVE_LIBUNICODE
+
+#include	"../unicode/unicode.h"
+
 int rfc2047_encode_callback_base64(const char *str, const char *charset,
 				   int (*qp_allow)(char),
 				   int (*func)(const char *, size_t, void *),
diff -Naur Courier-imap-3.0.8/rfc822/rfc822.c courier-imap-3.0.8/rfc822/rfc822.c
--- Courier-imap-3.0.8/rfc822/rfc822.c	2004-06-09 04:14:29.000000000 +0530
+++ courier-imap-3.0.8/rfc822/rfc822.c	2009-05-30 20:58:20.000000000 +0530
@@ -1,10 +1,10 @@
 /*
-** Copyright 1998 - 2001 Double Precision, Inc.
+** Copyright 1998 - 2007 Double Precision, Inc.
 ** See COPYING for distribution information.
 */
 
 /*
-** $Id: rfc822.c,v 1.18 2004/05/23 14:28:24 mrsam Exp $
+** $Id: rfc822.c,v 1.21 2007/02/26 04:13:41 mrsam Exp $
 */
 #include	<stdio.h>
 #include	<ctype.h>
@@ -29,6 +29,8 @@
 			continue;
 		}
 
+#define SPECIALS "<>@,;:.[]()%!\"\\?=/"
+
 		switch (*p)	{
 		int	level;
 
@@ -113,6 +115,47 @@
 			++p;
 			++i;
 			continue;
+
+		case '=':
+
+			if (p[1] == '?')
+			{
+				int j;
+
+			/* exception: =? ... ?= */
+
+				for (j=2; p[j]; j++)
+				{
+					if (p[j] == '?' && p[j+1] == '=')
+						break;
+
+					if (p[j] == '?' || p[j] == '=')
+						continue;
+
+					if (strchr(SPECIALS, p[j]) ||
+					    isspace(p[j]))
+						break;
+				}
+
+				if (p[j] == '?' && p[j+1] == '=')
+				{
+					j += 2;
+					if (tokp)
+					{
+						tokp->token=0;
+						tokp->ptr=p;
+						tokp->len=j;
+						++tokp;
+					}
+					++*toklen;
+
+					p += j;
+					i += j;
+					continue;
+				}
+			}
+			/* FALLTHROUGH */
+
 		case '<':
 		case '>':
 		case '@':
@@ -125,7 +168,6 @@
 		case '%':
 		case '!':
 		case '?':
-		case '=':
 		case '/':
 
 			if ( (*p == '<' && inbracket) ||
@@ -176,7 +218,7 @@
 				tokp->len=0;
 			}
 			while (*p && !isspace((int)(unsigned char)*p) && strchr(
-				"<>@,;:.[]()%!\"\\?=/", *p) == 0)
+				SPECIALS, *p) == 0)
 			{
 				if (tokp)	++tokp->len;
 				++p;
@@ -207,7 +249,6 @@
 		struct rfc822addr *addrs, int *naddrs)
 {
 int	flag, j, k;
-struct	rfc822token	save_token;
 
 	*naddrs=0;
 
@@ -277,7 +318,7 @@
 			Else, make them all a quoted string. */
 
 			for (j=0; j<i && (tokens[j].token == 0 ||
-					tokens[j].token == '('); j++)
+					  tokens[j].token == '('); j++)
 				;
 
 			if (j == i)
@@ -382,9 +423,9 @@
 
 		if (addrs)
 		{
+			struct	rfc822token	save_token;
 
-			save_token.ptr=0;
-			save_token.len=0;
+			memset(&save_token, 0, sizeof(save_token));
 
 			for (j=k=0; j<i; j++)
 			{
diff -Naur Courier-imap-3.0.8/rfc822/rfc822_getaddr.c courier-imap-3.0.8/rfc822/rfc822_getaddr.c
--- Courier-imap-3.0.8/rfc822/rfc822_getaddr.c	2000-10-22 10:53:50.000000000 +0530
+++ courier-imap-3.0.8/rfc822/rfc822_getaddr.c	2009-05-30 20:58:20.000000000 +0530
@@ -1,10 +1,10 @@
 /*
-** Copyright 1998 - 1999 Double Precision, Inc.
+** Copyright 1998 - 2008 Double Precision, Inc.
 ** See COPYING for distribution information.
 */
 
 /*
-** $Id: rfc822_getaddr.c,v 1.6 2000/10/22 05:23:50 mrsam Exp $
+** $Id: rfc822_getaddr.c,v 1.8 2008/06/14 14:12:50 mrsam Exp $
 */
 #include	"rfc822.h"
 #include	<stdlib.h>
@@ -40,9 +40,30 @@
 	return (addrbuf);
 }
 
+/* Get rid of surrounding quotes */
+
+static void dropquotes(char *addrbuf)
+{
+	char	*p, *q;
+
+	p=q=addrbuf;
+
+	if (*p == '"')
+		++p;
+
+	while (*p)
+	{
+		if (*p == '"' && p[1] == 0)
+			break;
+
+		*q++ = *p++;
+	}
+
+	*q=0;
+}
+
 char *rfc822_getname(const struct rfc822a *rfc, int n)
 {
-char	*p, *q;
 size_t	addrbuflen=0;
 char	*addrbuf, *ptr;
 
@@ -54,17 +75,12 @@
 	rfc822_prname(rfc, n, &saveaddr, &ptr);
 	addrbuf[addrbuflen]=0;
 
-	/* Get rid of surrounding quotes */
-
-	for (p=q=addrbuf; *p; p++)
-		if (*p != '"')	*q++=*p;
-	*q=0;
+	dropquotes(addrbuf);
 	return (addrbuf);
 }
 
 char *rfc822_getname_orlist(const struct rfc822a *rfc, int n)
 {
-char	*p, *q;
 size_t	addrbuflen=0;
 char	*addrbuf, *ptr;
 
@@ -76,11 +92,7 @@
 	rfc822_prname_orlist(rfc, n, &saveaddr, &ptr);
 	addrbuf[addrbuflen]=0;
 
-	/* Get rid of surrounding quotes */
-
-	for (p=q=addrbuf; *p; p++)
-		if (*p != '"')	*q++=*p;
-	*q=0;
+	dropquotes(addrbuf);
 	return (addrbuf);
 }
 
diff -Naur Courier-imap-3.0.8/soxwrap/sconnect.c courier-imap-3.0.8/soxwrap/sconnect.c
--- Courier-imap-3.0.8/soxwrap/sconnect.c	2004-07-27 07:07:53.000000000 +0530
+++ courier-imap-3.0.8/soxwrap/sconnect.c	2009-05-30 20:58:20.000000000 +0530
@@ -17,7 +17,7 @@
 
 #include	"soxwrap.h"
 
-static const char rcsid[]="$Id: sconnect.c,v 1.3 2004/07/24 03:36:53 mrsam Exp $";
+static const char rcsid[]="$Id: sconnect.c,v 1.5 2006/03/04 14:48:32 mrsam Exp $";
 
 int s_connect(int sockfd, const struct sockaddr *addr, size_t addr_s,
 	      time_t connect_timeout)
@@ -62,6 +62,8 @@
                 if (fcntl(sockfd, F_SETFL, 0) < 0)      return (-1);
                 return (0);
         }
+        else
+                if (errno != EINPROGRESS) return (-1);
 
 	/* Wait for the connection to go through, until the timeout expires */
 
@@ -81,7 +83,7 @@
 
 	{
 		int     gserr;
-		int	gslen = sizeof(gserr);
+		socklen_t gslen = sizeof(gserr);
 
 		if (sox_getsockopt(sockfd, SOL_SOCKET,
 				   SO_ERROR,
diff -Naur Courier-imap-3.0.8/unicode/eucjp.c courier-imap-3.0.8/unicode/eucjp.c
--- Courier-imap-3.0.8/unicode/eucjp.c	2004-06-09 04:14:47.000000000 +0530
+++ courier-imap-3.0.8/unicode/eucjp.c	2009-05-30 20:58:20.000000000 +0530
@@ -26,7 +26,10 @@
 	
 	len = strlen(eucjp_str);
 	uc = (unicode_char*)malloc((len+1) * sizeof(unicode_char) *2);
-	
+
+	if (!uc)
+		return NULL;
+
 	for(i=0; i<len;) {
 		/* US-ASCII */
 		if((unsigned char)eucjp_str[i] < 0x80)
@@ -129,7 +132,10 @@
 	while(str[len])
 		len++;
 	s = malloc((len+1)*2);
-	
+
+	if (!s)
+		return NULL;
+
 	for(i=0; str[i]; i++)
 	{
 		int jis_char = 0;
diff -Naur Courier-imap-3.0.8/unicode/ksx1001.c courier-imap-3.0.8/unicode/ksx1001.c
--- Courier-imap-3.0.8/unicode/ksx1001.c	2004-06-09 04:14:47.000000000 +0530
+++ courier-imap-3.0.8/unicode/ksx1001.c	2009-05-30 20:58:20.000000000 +0530
@@ -339,7 +339,10 @@
 
 	len = strlen(euckr_str);
 	uc = (unicode_char*)malloc((len+1) * sizeof(unicode_char) *2);
-	
+
+	if (!uc)
+		return NULL;
+
 	for(i=0; i<len;) {
 		/* 2 Characters replaced by KS X 1003 */
 		if ((compat & EUCKR_CP949_EXTENSION)
@@ -454,7 +457,10 @@
 	while(str[len])
 		len++;
 	s = malloc((len+1)*2);
-	
+
+	if (!s)
+		return NULL;
+
 	for(i=0; str[i]; i++)
 	{
 		int ksx_char = 0;
diff -Naur Courier-imap-3.0.8/unicode/shiftjis.c courier-imap-3.0.8/unicode/shiftjis.c
--- Courier-imap-3.0.8/unicode/shiftjis.c	2004-06-09 04:14:48.000000000 +0530
+++ courier-imap-3.0.8/unicode/shiftjis.c	2009-05-30 20:58:20.000000000 +0530
@@ -28,7 +28,10 @@
 	
 	len = strlen(sjis_str);
 	uc = (unicode_char*)malloc((len+1) * sizeof(unicode_char) *2);
-	
+
+	if (!uc)
+		return NULL;
+
 	for(i=0; i<len;) {
 		/* 2 Characters replaced by JIS X 0201 */
 		if (sjis_str[i] == 0x5C) /* YEN SIGN */
@@ -145,7 +148,10 @@
 	while(str[len])
 		len++;
 	s = malloc((len+1)*2);
-	
+
+	if (!s)
+		return NULL;
+
 	for(i=0; str[i]; i++) {
 		int jis_char = 0;
 		unsigned char hi=0, lo=0;
diff -Naur Courier-imap-3.0.8/waitlib/waitlib.c courier-imap-3.0.8/waitlib/waitlib.c
--- Courier-imap-3.0.8/waitlib/waitlib.c	1999-12-06 19:02:02.000000000 +0530
+++ courier-imap-3.0.8/waitlib/waitlib.c	2009-05-30 20:58:20.000000000 +0530
@@ -1,5 +1,5 @@
 /*
-** Copyright 1998 - 1999 Double Precision, Inc.
+** Copyright 1998 - 2005 Double Precision, Inc.
 ** See COPYING for distribution information.
 */
 
@@ -7,9 +7,23 @@
 #include	"waitlib.h"
 #endif
 #include	<signal.h>
+#include	<stdio.h>
 
-static const char rcsid[]="$Id: waitlib.c,v 1.3 1999/12/06 13:32:02 mrsam Exp $";
+static const char rcsid[]="$Id: waitlib.c,v 1.4 2005/08/20 13:03:30 mrsam Exp $";
 
+#if	HAVE_SIGPROCMASK
+
+#define HOLD_CHILDREN {\
+	sigset_t ss; sigemptyset(&ss); sigaddset(&ss, SIGCHLD); \
+	sigprocmask(SIG_BLOCK, &ss, NULL);\
+	}
+
+#define RELEASE_CHILDREN {\
+	sigset_t ss; sigemptyset(&ss); sigaddset(&ss, SIGCHLD); \
+	sigprocmask(SIG_UNBLOCK, &ss, NULL);\
+	}
+
+#else
 #if	HAVE_SIGHOLD
 
 #define	HOLD_CHILDREN	sighold(SIGCHLD)
@@ -21,6 +35,7 @@
 #define	RELEASE_CHILDREN	sigsetmask(0)
 
 #endif
+#endif
 
 #if	USE_WAIT3
 
