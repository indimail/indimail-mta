/*
 * $Log: dbinfo.c,v $
 * Revision 2.15  2016-05-17 15:39:42+05:30  Cprogrammer
 * use control directory set by configure
 *
 * Revision 2.14  2009-09-23 14:58:36+05:30  Cprogrammer
 * fixed segementation fault in dbinfo when mcdinfo is absent
 *
 * Revision 2.13  2005-12-29 22:40:58+05:30  Cprogrammer
 * use getEnvConfigStr to set variables from environment variables
 *
 * Revision 2.12  2004-07-12 22:44:46+05:30  Cprogrammer
 * replaced system() with runcmmd()
 *
 * Revision 2.11  2003-10-28 00:22:41+05:30  Cprogrammer
 * skip local autogenerated dbinfo entries
 *
 * Revision 2.10  2003-10-24 00:40:58+05:30  Cprogrammer
 * create sql file for -e option
 *
 * Revision 2.9  2003-03-04 20:57:06+05:30  Cprogrammer
 * added row format display
 *
 * Revision 2.8  2003-01-28 23:22:51+05:30  Cprogrammer
 * corrected setting of default value of distributed
 *
 * Revision 2.7  2003-01-22 16:01:31+05:30  Cprogrammer
 * added option to select domain
 *
 * Revision 2.6  2003-01-01 10:55:30+05:30  Cprogrammer
 * missing break added in switch
 * delete option should delete MCD File and recreate it
 *
 * Revision 2.5  2003-01-01 03:29:13+05:30  Cprogrammer
 * Major Functionality overall. Following options added
 * insertion of dbinfo
 * updation of dbinfo
 * deletion of  dbinfo
 * display dbinfo entries
 *
 * Revision 2.4  2002-11-03 00:54:15+05:30  Cprogrammer
 * added host, server, client, protocol information
 *
 * Revision 2.3  2002-05-12 01:46:05+05:30  Cprogrammer
 * correced dbinfo not working without arguments
 *
 * Revision 2.2  2002-05-11 15:23:36+05:30  Cprogrammer
 * corrected non-working option mcdFile on command line
 *
 * Revision 2.1  2002-04-17 13:13:22+05:30  Cprogrammer
 * close all mysql connections outside for(;;) to avoid closing of reused mysql connections
 *
 * Revision 1.13  2002-04-10 15:19:11+05:30  Cprogrammer
 * added mysql_stat() function to return mysql statistics
 *
 * Revision 1.12  2002-04-10 14:05:04+05:30  Cprogrammer
 * display if domain is distributed or not
 * display TCP/IP port if using AF_INET socket or Unix Socket if using AF_UNIX socket
 *
 * Revision 1.11  2002-04-10 13:40:09+05:30  Cprogrammer
 * changes for InLookup
 *
 * Revision 1.10  2002-04-04 16:36:54+05:30  Cprogrammer
 * run with userid as indimail
 *
 * Revision 1.9  2002-04-03 17:31:26+05:30  Cprogrammer
 * typecast to supress compiler warnings
 *
 * Revision 1.8  2002-04-03 01:46:08+05:30  Cprogrammer
 * append .db only if file does not have '.' or if file does not end with .db
 *
 * Revision 1.7  2002-04-01 04:03:27+05:30  Cprogrammer
 * replaced lockcreate() and get_write_lock() with getDbLock()
 * added code to work with filesystem locking
 *
 * Revision 1.6  2002-04-01 02:10:50+05:30  Cprogrammer
 * replaced ReleaseLock() and RemoveLock() with delDbLock()
 *
 * Revision 1.5  2002-03-31 21:46:23+05:30  Cprogrammer
 * RemoveLock() after releasing lock
 *
 * Revision 1.4  2002-03-30 01:29:59+05:30  Cprogrammer
 * added server count no
 *
 * Revision 1.3  2002-03-30 00:53:27+05:30  Cprogrammer
 * use QMAILDIR/control/sql as default if no arguments specified on command line
 *
 * Revision 1.2  2002-03-28 02:30:58+05:30  Cprogrammer
 * added mysql status
 *
 * Revision 1.1  2002-03-28 02:22:18+05:30  Cprogrammer
 * Initial revision
 *
 */
#include "indimail.h"

#ifndef	lint
static char     sccsid[] = "$Id: dbinfo.c,v 2.15 2016-05-17 15:39:42+05:30 Cprogrammer Exp mbhangui $";
#endif

#ifdef CLUSTERED_SITE
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

#define DBINFO_SELECT 1
#define DBINFO_INSERT 2
#define DBINFO_UPDATE 3
#define DBINFO_DELETE 4
#define DBINFO_EDIT   5
static int      row_format;

static int      get_options(int, char **, int *, int *, char **, int *, char **, char **, char **, char **, char **, char **);
static int      editdbinfo(char *);
static void     usage();

int
main(int argc, char **argv)
{
	char           *m_server, *m_database, *m_user, *m_pass, *mdahost, *domain, *filename;
	char            mcdFile[MAX_BUFF];
	int             opt, dist, m_port, err, total;

	if (get_options(argc, argv, &opt, &dist, &m_server, &m_port, &m_database, &m_user, &m_pass, &mdahost, &domain, &filename))
		return (1);
	if (filename && *filename)
	{
		snprintf(mcdFile, sizeof(mcdFile), "MCDFILE=%s", filename);
		putenv(mcdFile);
	}
	switch (opt)
	{
	case DBINFO_SELECT:
		if (!(err = dbinfoSelect(filename, domain, mdahost, row_format)))
			LoadDbInfo_TXT(&total);
		break;
	case DBINFO_INSERT:
		if (!(err = dbinfoAdd(domain, dist, m_server, mdahost, m_port, m_database, m_user, m_pass)))
			LoadDbInfo_TXT(&total);
		break;
	case DBINFO_UPDATE:
		if (!(err = dbinfoUpdate(domain, dist, m_server, mdahost, m_port, m_database, m_user, m_pass)))
			LoadDbInfo_TXT(&total);
		break;
	case DBINFO_DELETE:
		if (!(err = dbinfoDel(domain, mdahost)))
		{
			if (!access(filename, F_OK) && unlink(filename))
			{
				fprintf(stderr, "dbinfo: unlink: %s: %s\n", filename, strerror(errno));
				return(1);
			}
			LoadDbInfo_TXT(&total);
		}
		break;
	case DBINFO_EDIT:
		err = editdbinfo(filename);
		break;
	default:
		err = -1;
	}
	vclose();
	return (err);
}

static int
editdbinfo(char *filename)
{
	char            mcdFile[MAX_BUFF], TmpBuf[MAX_BUFF], envbuf[MAX_BUFF];
	char           *ptr, *qmaildir, *controldir, *mcdfile;
	DBINFO        **rhostsptr, **tmpPtr;
	uid_t           uid;
	gid_t           gid;
	int             total, count;

	verbose = 1;
	getEnvConfigStr(&qmaildir, "QMAILDIR", QMAILDIR);
	getEnvConfigStr(&controldir, "CONTROLDIR", CONTROLDIR);
	if (!filename || !*filename)
		getEnvConfigStr(&mcdfile, "MCDFILE", MCDFILE);
	else
		mcdfile = filename;
	if (*mcdfile == '/' || *mcdfile == '.')
		snprintf(mcdFile, MAX_BUFF, "%s", mcdfile);
	else {
		if (*controldir == '/')
			snprintf(mcdFile, MAX_BUFF, "%s/%s", controldir, mcdfile);
		else
			snprintf(mcdFile, MAX_BUFF, "%s/%s/%s", qmaildir, controldir, mcdfile);
	}
	snprintf(envbuf, MAX_BUFF, "MCDFILE=%s", mcdFile);
	rhostsptr = LoadDbInfo_TXT(&total);
	for (count = 0,tmpPtr = rhostsptr;tmpPtr && *tmpPtr;tmpPtr++)
	{
		if ((*tmpPtr)->isLocal)
			continue;
		count++;
	}
	printf("Loaded %d entries in file %s\nPress ENTER to continue", count, mcdFile);
	getchar();
	if (rhostsptr && access(mcdFile, F_OK))
	{
		if (writedbinfo(rhostsptr, time(0)))
		{
			fprintf(stderr, "writedbinfo failed\n");
			return(1);
		}
	}
	getEnvConfigStr(&ptr, "EDITOR", "vi");
	printf("Editor is %s\n", ptr);
	snprintf(TmpBuf, MAX_BUFF, "%s %s", ptr, mcdFile);
	runcmmd(TmpBuf, 1);
	if (indimailuid == -1 || indimailgid == -1)
		GetIndiId(&indimailuid, &indimailgid);
	uid = indimailuid;
	gid = indimailgid;
	if (chown(mcdFile, uid, gid))
		fprintf(stderr, "chown: %s: %s\n", mcdFile, strerror(errno));
	return((LoadDbInfo_TXT(&total) ? 0 : 1));
}

static int
get_options(int argc, char **argv, int *option, int *distributed, char **mysql_server, int *mysql_port, char **mysql_database,
			char **mysql_user, char **mysql_pass, char **mdahost, char **domain, char **filename)
{
	int             c;

	row_format = 0;
	*distributed = 0;
	*option = *mysql_port = -1;
	*mysql_server = *mysql_database = *mysql_user = *mysql_pass = *mdahost = *domain = *filename = 0;
	while ((c = getopt(argc, argv, "viurseld:cS:p:D:U:P:m:")) != -1)
	{
		switch (c)
		{
		case 'v':
			verbose = 1;
			break;
		case 's':
			*option = DBINFO_SELECT;
			break;
		case 'i':
			*option = DBINFO_INSERT;
			break;
		case 'u':
			*option = DBINFO_UPDATE;
			break;
		case 'r':
			*option = DBINFO_DELETE;
			break;
		case 'd':
			*domain = optarg;
			break;
		case 'c':
			*distributed = 1;
			break;
		case 'S':
			*mysql_server = optarg;
			break;
		case 'p':
			*mysql_port = atoi(optarg);
			break;
		case 'D':
			*mysql_database = optarg;
			break;
		case 'U':
			*mysql_user = optarg;
			break;
		case 'P':
			*mysql_pass = optarg;
			break;
		case 'm':
			*mdahost = optarg;
			break;
		case 'e':
			*option = DBINFO_EDIT;
			break;
		case 'l':
			row_format = 1;
			break;
		default:
			usage();
			return (1);
		} /*- switch(c) */
	} /*- while ((c = getopt(argc, argv, "viurd:cs:P:D:u:p:m:")) != -1) */
	if (optind < argc)
		*filename = argv[optind++];
	if (*option == -1 || (*option != DBINFO_SELECT && *option != DBINFO_EDIT && !*filename))
	{
		usage();
		return (1);
	} else
	switch(*option)
	{
	case DBINFO_INSERT:
		if (*distributed == -1 || !*mysql_server || *mysql_port == -1 || !*mysql_database || !*mysql_user || !*mysql_pass)
		{
			usage();
			return (1);
		}
	case DBINFO_UPDATE:
	case DBINFO_DELETE:
		if (!*domain || !*mdahost)
		{
			usage();
			return (1);
		}
		break;
	case DBINFO_EDIT:
		break;
	}
	return (0);
}

static void
usage()
{
	fprintf(stderr, "usage: dbinfo [options] MCDF_file_PATH\n");
	fprintf(stderr, "       dbinfo -i -S MySQL_server  -p port -D database -U user -P password  [-c] -d domain -m mdahost MCDF_file\n");
	fprintf(stderr, "       dbinfo -u -S MySQL_server [-p port -D database -U user -P password] [-c] -d domain -m mdahost MCDF_file\n");
	fprintf(stderr, "       dbinfo -r -d domain -m mdahost MCDF_file\n");
	fprintf(stderr, "       dbinfo -s [-d domain] [-m mdahost] MCDF_file\n");
	fprintf(stderr, "       dbinfo -e\n");
	fprintf(stderr, "options: -v verbose\n");
	fprintf(stderr, "         -i Insert Entry\n");
	fprintf(stderr, "         -u Update Entry\n");
	fprintf(stderr, "         -r Remove Entry\n");
	fprintf(stderr, "         -s Show   Entries\n");
	fprintf(stderr, "         -d Domain Name\n");
	fprintf(stderr, "         -c If Clustered\n");
	fprintf(stderr, "         -S MySQL Server IP\n");
	fprintf(stderr, "         -p MySQL Port\n");
	fprintf(stderr, "         -D MySQL Database Name\n");
	fprintf(stderr, "         -U MySQL User Name\n");
	fprintf(stderr, "         -P MySQL Password\n");
	fprintf(stderr, "         -m Mail Store IP\n");
	fprintf(stderr, "         -e Edit Dbinfo using vi\n");
	fprintf(stderr, "         -l Row Format display\n");
	return;
}
#else
int
main()
{
	fprintf(stderr, "IndiMail not configured with --enable-user-cluster=y\n");
	return (0);
}
#endif

void
getversion_dbinfo_c()
{
	printf("%s\n", sccsid);
	printf("%s\n", sccsidh);
}
