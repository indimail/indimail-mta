diff -Naur tmp/ucspi-tcp-0.88/addcr.c ucspi-tcp-0.88/addcr.c
--- tmp/ucspi-tcp-0.88/addcr.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/addcr.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,22 +0,0 @@
-#include "buffer.h"
-#include "exit.h"
-
-main()
-{
-  register int n;
-  register char *x;
-  char ch;
-
-  for (;;) {
-    n = buffer_feed(buffer_0);
-    if (n < 0) _exit(111);
-    if (!n) _exit(0);
-    x = buffer_PEEK(buffer_0);
-    buffer_SEEK(buffer_0,n);
-    while (n > 0) {
-      ch = *x++; --n;
-      if (ch == '\n') buffer_PUTC(buffer_1,"\r"[0]);
-      buffer_PUTC(buffer_1,ch);
-    }
-  }
-}
diff -Naur tmp/ucspi-tcp-0.88/alloc.c ucspi-tcp-0.88/alloc.c
--- tmp/ucspi-tcp-0.88/alloc.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/alloc.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,32 +1,47 @@
+/*
+ * $Log: alloc.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "alloc.h"
 #include "error.h"
-extern char *malloc();
-extern void free();
+extern void    *malloc();
+extern void     free();
 
-#define ALIGNMENT 16 /* XXX: assuming that this alignment is enough */
-#define SPACE 2048 /* must be multiple of ALIGNMENT */
+#define ALIGNMENT 16			/*- XXX: assuming that this alignment is enough */
+#define SPACE 2048				/*- must be multiple of ALIGNMENT */
 
-typedef union { char irrelevant[ALIGNMENT]; double d; } aligned;
-static aligned realspace[SPACE / ALIGNMENT];
+typedef union
+{
+	char            irrelevant[ALIGNMENT];
+	double          d;
+}
+aligned;
+static aligned  realspace[SPACE / ALIGNMENT];
 #define space ((char *) realspace)
-static unsigned int avail = SPACE; /* multiple of ALIGNMENT; 0<=avail<=SPACE */
+static unsigned int avail = SPACE;	/*- multiple of ALIGNMENT; 0<=avail<=SPACE */
 
 /*@null@*//*@out@*/char *alloc(n)
-unsigned int n;
+	unsigned int    n;
 {
-  char *x;
-  n = ALIGNMENT + n - (n & (ALIGNMENT - 1)); /* XXX: could overflow */
-  if (n <= avail) { avail -= n; return space + avail; }
-  x = malloc(n);
-  if (!x) errno = error_nomem;
-  return x;
+	char           *x;
+	n = ALIGNMENT + n - (n & (ALIGNMENT - 1));	/*- XXX: could overflow */
+	if (n <= avail)
+	{
+		avail -= n;
+		return space + avail;
+	}
+	if(!(x = malloc(n)))
+		errno = error_nomem;
+	return x;
 }
 
-void alloc_free(x)
-char *x;
+void
+alloc_free(x)
+	char           *x;
 {
-  if (x >= space)
-    if (x < space + SPACE)
-      return; /* XXX: assuming that pointers are flat */
-  free(x);
+	if (x >= space && (x < space + SPACE))
+		return;				/*- XXX: assuming that pointers are flat */
+	free(x);
 }
diff -Naur tmp/ucspi-tcp-0.88/alloc.h ucspi-tcp-0.88/alloc.h
--- tmp/ucspi-tcp-0.88/alloc.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/alloc.h	2008-07-27 18:39:39.000000000 +0530
@@ -1,3 +1,9 @@
+/*
+ * $Log: alloc.h,v $
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef ALLOC_H
 #define ALLOC_H
 
diff -Naur tmp/ucspi-tcp-0.88/alloc_re.c ucspi-tcp-0.88/alloc_re.c
--- tmp/ucspi-tcp-0.88/alloc_re.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/alloc_re.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,17 +1,24 @@
+/*
+ * $Log: alloc_re.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "alloc.h"
 #include "byte.h"
 
-int alloc_re(x,m,n)
-char **x;
-unsigned int m;
-unsigned int n;
+int
+alloc_re(x, old_size, new_size)
+	char          **x;
+	unsigned int    old_size;
+	unsigned int    new_size;
 {
-  char *y;
- 
-  y = alloc(n);
-  if (!y) return 0;
-  byte_copy(y,m,*x);
-  alloc_free(*x);
-  *x = y;
-  return 1;
+	char           *y;
+
+	if (!(y = alloc(new_size)))
+		return 0;
+	byte_copy(y, old_size, *x);
+	alloc_free(*x);
+	*x = y;
+	return 1;
 }
diff -Naur tmp/ucspi-tcp-0.88/argv0.c ucspi-tcp-0.88/argv0.c
--- tmp/ucspi-tcp-0.88/argv0.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/argv0.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,10 +0,0 @@
-#include "pathexec.h"
-#include "strerr.h"
-
-main(int argc,char **argv,char **envp)
-{
-  if (argc < 3)
-    strerr_die1x(100,"argv0: usage: argv0 realname program [ arg ... ]");
-  pathexec_run(argv[1],argv + 2,envp);
-  strerr_die4sys(111,"argv0: fatal: ","unable to run ",argv[1],": ");
-}
diff -Naur tmp/ucspi-tcp-0.88/auto_home.h ucspi-tcp-0.88/auto_home.h
--- tmp/ucspi-tcp-0.88/auto_home.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/auto_home.h	2008-07-27 18:39:40.000000000 +0530
@@ -1,3 +1,9 @@
+/*
+ * $Log: auto_home.h,v $
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef AUTO_HOME_H
 #define AUTO_HOME_H
 
diff -Naur tmp/ucspi-tcp-0.88/auto-str.c ucspi-tcp-0.88/auto-str.c
--- tmp/ucspi-tcp-0.88/auto-str.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/auto-str.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,41 +1,60 @@
+/*
+ * $Log: auto-str.c,v $
+ * Revision 1.3  2008-07-17 23:02:13+05:30  Cprogrammer
+ * use unistd.h instead of readwrite.h
+ *
+ * Revision 1.2  2004-05-12 22:44:34+05:30  Cprogrammer
+ * changed puts() to my_puts for fedora release
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <unistd.h>
 #include "buffer.h"
-#include "readwrite.h"
 #include "exit.h"
 
-char bspace[256];
-buffer b = BUFFER_INIT(write,1,bspace,sizeof bspace);
+char            bspace[256];
+buffer          b = BUFFER_INIT(write, 1, bspace, sizeof bspace);
 
-void puts(char *s)
+void
+my_puts(char *s)
 {
-  if (buffer_puts(&b,s) == -1) _exit(111);
+	if (buffer_puts(&b, s) == -1)
+		_exit(111);
 }
 
-main(int argc,char **argv)
+int
+main(int argc, char **argv)
 {
-  char *name;
-  char *value;
-  unsigned char ch;
-  char octal[4];
-
-  name = argv[1];
-  if (!name) _exit(100);
-  value = argv[2];
-  if (!value) _exit(100);
-
-  puts("char ");
-  puts(name);
-  puts("[] = \"\\\n");
-
-  while (ch = *value++) {
-    puts("\\");
-    octal[3] = 0;
-    octal[2] = '0' + (ch & 7); ch >>= 3;
-    octal[1] = '0' + (ch & 7); ch >>= 3;
-    octal[0] = '0' + (ch & 7);
-    puts(octal);
-  }
-
-  puts("\\\n\";\n");
-  if (buffer_flush(&b) == -1) _exit(111);
-  _exit(0);
+	char           *name;
+	char           *value;
+	unsigned char   ch;
+	char            octal[4];
+
+	if(!(name = argv[1]))
+		_exit(100);
+	value = argv[2];
+	if (!value)
+		_exit(100);
+	my_puts("char ");
+	my_puts(name);
+	my_puts("[] = \"\\\n");
+	while ((ch = *value++))
+	{
+		my_puts("\\");
+		octal[3] = 0;
+		octal[2] = '0' + (ch & 7);
+		ch >>= 3;
+		octal[1] = '0' + (ch & 7);
+		ch >>= 3;
+		octal[0] = '0' + (ch & 7);
+		my_puts(octal);
+	}
+	my_puts("\\\n\";\n");
+	if (buffer_flush(&b) == -1)
+		_exit(111);
+	_exit(0);
+	/* Not reached */
+	return(0);
 }
diff -Naur tmp/ucspi-tcp-0.88/buffer_0.c ucspi-tcp-0.88/buffer_0.c
--- tmp/ucspi-tcp-0.88/buffer_0.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/buffer_0.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,12 +1,29 @@
-#include "readwrite.h"
+/*
+ * $Log: buffer_0.c,v $
+ * Revision 1.3  2008-07-25 16:48:26+05:30  Cprogrammer
+ * fix for darwin
+ *
+ * Revision 1.2  2008-07-17 23:02:26+05:30  Cprogrammer
+ * use unistd.h instead of readwrite.h
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <unistd.h>
 #include "buffer.h"
 
-int buffer_0_read(fd,buf,len) int fd; char *buf; int len;
+ssize_t
+buffer_0_read(fd, buf, len)
+	int             fd;
+	char           *buf;
+	int             len;
 {
-  if (buffer_flush(buffer_1) == -1) return -1;
-  return read(fd,buf,len);
+	if (buffer_flush(buffer_1) == -1)
+		return -1;
+	return read(fd, buf, len);
 }
 
-char buffer_0_space[BUFFER_INSIZE];
-static buffer it = BUFFER_INIT(buffer_0_read,0,buffer_0_space,sizeof buffer_0_space);
-buffer *buffer_0 = &it;
+char            buffer_0_space[BUFFER_INSIZE];
+static buffer   it = BUFFER_INIT(buffer_0_read, 0, buffer_0_space, sizeof buffer_0_space);
+buffer         *buffer_0 = &it;
diff -Naur tmp/ucspi-tcp-0.88/buffer_1.c ucspi-tcp-0.88/buffer_1.c
--- tmp/ucspi-tcp-0.88/buffer_1.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/buffer_1.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,6 +1,15 @@
-#include "readwrite.h"
+/*
+ * $Log: buffer_1.c,v $
+ * Revision 1.2  2008-07-17 23:02:34+05:30  Cprogrammer
+ * use unistd.h instead of readwrite.h
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <unistd.h>
 #include "buffer.h"
 
-char buffer_1_space[BUFFER_OUTSIZE];
-static buffer it = BUFFER_INIT(write,1,buffer_1_space,sizeof buffer_1_space);
-buffer *buffer_1 = &it;
+char            buffer_1_space[BUFFER_OUTSIZE];
+static buffer   it = BUFFER_INIT(write, 1, buffer_1_space, sizeof buffer_1_space);
+buffer         *buffer_1 = &it;
diff -Naur tmp/ucspi-tcp-0.88/buffer_2.c ucspi-tcp-0.88/buffer_2.c
--- tmp/ucspi-tcp-0.88/buffer_2.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/buffer_2.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,6 +1,15 @@
-#include "readwrite.h"
+/*
+ * $Log: buffer_2.c,v $
+ * Revision 1.2  2008-07-17 23:02:45+05:30  Cprogrammer
+ * use unistd.h instead of readwrite.h
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <unistd.h>
 #include "buffer.h"
 
-char buffer_2_space[256];
-static buffer it = BUFFER_INIT(write,2,buffer_2_space,sizeof buffer_2_space);
-buffer *buffer_2 = &it;
+char            buffer_2_space[256];
+static buffer   it = BUFFER_INIT(write, 2, buffer_2_space, sizeof buffer_2_space);
+buffer         *buffer_2 = &it;
diff -Naur tmp/ucspi-tcp-0.88/buffer.c ucspi-tcp-0.88/buffer.c
--- tmp/ucspi-tcp-0.88/buffer.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/buffer.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,10 +1,20 @@
+/*
+ * $Log: buffer.c,v $
+ * Revision 1.2  2008-07-25 16:48:33+05:30  Cprogrammer
+ * fix for darwin
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "buffer.h"
 
-void buffer_init(buffer *s,int (*op)(),int fd,char *buf,unsigned int len)
+void
+buffer_init(buffer * s, ssize_t (*op) (), int fd, char *buf, unsigned int len)
 {
-  s->x = buf;
-  s->fd = fd;
-  s->op = op;
-  s->p = 0;
-  s->n = len;
+	s->x = buf;
+	s->fd = fd;
+	s->op = op;
+	s->p = 0;
+	s->n = len;
 }
diff -Naur tmp/ucspi-tcp-0.88/buffer_copy.c ucspi-tcp-0.88/buffer_copy.c
--- tmp/ucspi-tcp-0.88/buffer_copy.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/buffer_copy.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,16 +1,27 @@
+/*
+ * $Log: buffer_copy.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "buffer.h"
 
-int buffer_copy(buffer *bout,buffer *bin)
+int
+buffer_copy(buffer * bout, buffer * bin)
 {
-  int n;
-  char *x;
+	int             n;
+	char           *x;
 
-  for (;;) {
-    n = buffer_feed(bin);
-    if (n < 0) return -2;
-    if (!n) return 0;
-    x = buffer_PEEK(bin);
-    if (buffer_put(bout,x,n) == -1) return -3;
-    buffer_SEEK(bin,n);
-  }
+	for (;;)
+	{
+		n = buffer_feed(bin);
+		if (n < 0)
+			return -2;
+		if (!n)
+			return 0;
+		x = buffer_PEEK(bin);
+		if (buffer_put(bout, x, n) == -1)
+			return -3;
+		buffer_SEEK(bin, n);
+	}
 }
diff -Naur tmp/ucspi-tcp-0.88/buffer_get.c ucspi-tcp-0.88/buffer_get.c
--- tmp/ucspi-tcp-0.88/buffer_get.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/buffer_get.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,67 +1,94 @@
+/*
+ * $Log: buffer_get.c,v $
+ * Revision 1.2  2008-07-25 16:48:38+05:30  Cprogrammer
+ * fix for darwin
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "buffer.h"
 #include "byte.h"
 #include "error.h"
 
-static int oneread(int (*op)(),int fd,char *buf,unsigned int len)
+static int
+oneread(ssize_t (*op) (), int fd, char *buf, unsigned int len)
 {
-  int r;
+	int             r;
 
-  for (;;) {
-    r = op(fd,buf,len);
-    if (r == -1) if (errno == error_intr) continue;
-    return r;
-  }
+	for (;;)
+	{
+		r = op(fd, buf, len);
+		if (r == -1 && errno == error_intr)
+			continue;
+		return r;
+	}
 }
 
-static int getthis(buffer *s,char *buf,unsigned int len)
+static int
+getthis(buffer * s, char *buf, unsigned int len)
 {
-  if (len > s->p) len = s->p;
-  s->p -= len;
-  byte_copy(buf,len,s->x + s->n);
-  s->n += len;
-  return len;
+	if (len > s->p)
+		len = s->p;
+	s->p -= len;
+	byte_copy(buf, len, s->x + s->n);
+	s->n += len;
+	return len;
 }
 
-int buffer_feed(buffer *s)
+int
+buffer_feed(buffer * s)
 {
-  int r;
+	int             r;
 
-  if (s->p) return s->p;
-  r = oneread(s->op,s->fd,s->x,s->n);
-  if (r <= 0) return r;
-  s->p = r;
-  s->n -= r;
-  if (s->n > 0) byte_copyr(s->x + s->n,r,s->x);
-  return r;
+	if (s->p)
+		return s->p;
+	if((r = oneread(s->op, s->fd, s->x, s->n)) <= 0)
+		return r;
+	s->p = r;
+	s->n -= r;
+	if (s->n > 0)
+		byte_copyr(s->x + s->n, r, s->x);
+	return r;
 }
 
-int buffer_bget(buffer *s,char *buf,unsigned int len)
+int
+buffer_bget(buffer * s, char *buf, unsigned int len)
 {
-  int r;
- 
-  if (s->p > 0) return getthis(s,buf,len);
-  if (s->n <= len) return oneread(s->op,s->fd,buf,s->n);
-  r = buffer_feed(s); if (r <= 0) return r;
-  return getthis(s,buf,len);
+	int             r;
+
+	if (s->p > 0)
+		return getthis(s, buf, len);
+	if (s->n <= len)
+		return oneread(s->op, s->fd, buf, s->n);
+	if((r = buffer_feed(s)) <= 0)
+		return r;
+	return getthis(s, buf, len);
 }
 
-int buffer_get(buffer *s,char *buf,unsigned int len)
+int
+buffer_get(buffer * s, char *buf, unsigned int len)
 {
-  int r;
- 
-  if (s->p > 0) return getthis(s,buf,len);
-  if (s->n <= len) return oneread(s->op,s->fd,buf,len);
-  r = buffer_feed(s); if (r <= 0) return r;
-  return getthis(s,buf,len);
+	int             r;
+
+	if (s->p > 0)
+		return getthis(s, buf, len);
+	if (s->n <= len)
+		return oneread(s->op, s->fd, buf, len);
+	if((r = buffer_feed(s)) <= 0)
+		return r;
+	return getthis(s, buf, len);
 }
 
-char *buffer_peek(buffer *s)
+char           *
+buffer_peek(buffer * s)
 {
-  return s->x + s->n;
+	return s->x + s->n;
 }
 
-void buffer_seek(buffer *s,unsigned int len)
+void
+buffer_seek(buffer * s, unsigned int len)
 {
-  s->n += len;
-  s->p -= len;
+	s->n += len;
+	s->p -= len;
 }
diff -Naur tmp/ucspi-tcp-0.88/buffer.h ucspi-tcp-0.88/buffer.h
--- tmp/ucspi-tcp-0.88/buffer.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/buffer.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,27 +1,41 @@
+/*
+ * $Log: buffer.h,v $
+ * Revision 1.3  2008-07-25 16:48:43+05:30  Cprogrammer
+ * fix for darwin
+ *
+ * Revision 1.2  2005-05-13 23:32:33+05:30  Cprogrammer
+ * code indented
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef BUFFER_H
 #define BUFFER_H
+#include <unistd.h>
 
-typedef struct buffer {
-  char *x;
-  unsigned int p;
-  unsigned int n;
-  int fd;
-  int (*op)();
+typedef struct buffer
+{
+	char           *x;
+	unsigned int    p;
+	unsigned int    n;
+	int             fd;
+	ssize_t         (*op) ();
 } buffer;
 
 #define BUFFER_INIT(op,fd,buf,len) { (buf), 0, (len), (fd), (op) }
 #define BUFFER_INSIZE 8192
 #define BUFFER_OUTSIZE 8192
 
-extern void buffer_init(buffer *,int (*)(),int,char *,unsigned int);
+extern void     buffer_init(buffer *, ssize_t (*)(), int, char *, unsigned int);
 
-extern int buffer_flush(buffer *);
-extern int buffer_put(buffer *,char *,unsigned int);
-extern int buffer_putalign(buffer *,char *,unsigned int);
-extern int buffer_putflush(buffer *,char *,unsigned int);
-extern int buffer_puts(buffer *,char *);
-extern int buffer_putsalign(buffer *,char *);
-extern int buffer_putsflush(buffer *,char *);
+extern int      buffer_flush(buffer *);
+extern int      buffer_put(buffer *, char *, unsigned int);
+extern int      buffer_putalign(buffer *, char *, unsigned int);
+extern int      buffer_putflush(buffer *, char *, unsigned int);
+extern int      buffer_puts(buffer *, char *);
+extern int      buffer_putsalign(buffer *, char *);
+extern int      buffer_putsflush(buffer *, char *);
 
 #define buffer_PUTC(s,c) \
   ( ((s)->n != (s)->p) \
@@ -29,12 +43,12 @@
     : buffer_put((s),&(c),1) \
   )
 
-extern int buffer_get(buffer *,char *,unsigned int);
-extern int buffer_bget(buffer *,char *,unsigned int);
-extern int buffer_feed(buffer *);
+extern int      buffer_get(buffer *, char *, unsigned int);
+extern int      buffer_bget(buffer *, char *, unsigned int);
+extern int      buffer_feed(buffer *);
 
-extern char *buffer_peek(buffer *);
-extern void buffer_seek(buffer *,unsigned int);
+extern char    *buffer_peek(buffer *);
+extern void     buffer_seek(buffer *, unsigned int);
 
 #define buffer_PEEK(s) ( (s)->x + (s)->n )
 #define buffer_SEEK(s,len) ( ( (s)->p -= (len) ) , ( (s)->n += (len) ) )
@@ -45,12 +59,12 @@
     : buffer_get((s),(c),1) \
   )
 
-extern int buffer_copy(buffer *,buffer *);
+extern int      buffer_copy(buffer *, buffer *);
 
-extern buffer *buffer_0;
-extern buffer *buffer_0small;
-extern buffer *buffer_1;
-extern buffer *buffer_1small;
-extern buffer *buffer_2;
+extern buffer  *buffer_0;
+extern buffer  *buffer_0small;
+extern buffer  *buffer_1;
+extern buffer  *buffer_1small;
+extern buffer  *buffer_2;
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/buffer_put.c ucspi-tcp-0.88/buffer_put.c
--- tmp/ucspi-tcp-0.88/buffer_put.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/buffer_put.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,88 +1,121 @@
+/*
+ * $Log: buffer_put.c,v $
+ * Revision 1.2  2008-07-25 16:48:47+05:30  Cprogrammer
+ * fix for darwin
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "buffer.h"
 #include "str.h"
 #include "byte.h"
 #include "error.h"
 
-static int allwrite(int (*op)(),int fd,char *buf,unsigned int len)
+static int
+allwrite(ssize_t (*op) (), int fd, char *buf, unsigned int len)
 {
-  int w;
+	int             w;
 
-  while (len) {
-    w = op(fd,buf,len);
-    if (w == -1) {
-      if (errno == error_intr) continue;
-      return -1; /* note that some data may have been written */
-    }
-    if (w == 0) ; /* luser's fault */
-    buf += w;
-    len -= w;
-  }
-  return 0;
-}
-
-int buffer_flush(buffer *s)
-{
-  int p;
- 
-  p = s->p;
-  if (!p) return 0;
-  s->p = 0;
-  return allwrite(s->op,s->fd,s->x,p);
-}
-
-int buffer_putalign(buffer *s,char *buf,unsigned int len)
-{
-  unsigned int n;
- 
-  while (len > (n = s->n - s->p)) {
-    byte_copy(s->x + s->p,n,buf); s->p += n; buf += n; len -= n;
-    if (buffer_flush(s) == -1) return -1;
-  }
-  /* now len <= s->n - s->p */
-  byte_copy(s->x + s->p,len,buf);
-  s->p += len;
-  return 0;
-}
-
-int buffer_put(buffer *s,char *buf,unsigned int len)
-{
-  unsigned int n;
- 
-  n = s->n;
-  if (len > n - s->p) {
-    if (buffer_flush(s) == -1) return -1;
-    /* now s->p == 0 */
-    if (n < BUFFER_OUTSIZE) n = BUFFER_OUTSIZE;
-    while (len > s->n) {
-      if (n > len) n = len;
-      if (allwrite(s->op,s->fd,buf,n) == -1) return -1;
-      buf += n;
-      len -= n;
-    }
-  }
-  /* now len <= s->n - s->p */
-  byte_copy(s->x + s->p,len,buf);
-  s->p += len;
-  return 0;
-}
-
-int buffer_putflush(buffer *s,char *buf,unsigned int len)
-{
-  if (buffer_flush(s) == -1) return -1;
-  return allwrite(s->op,s->fd,buf,len);
-}
-
-int buffer_putsalign(buffer *s,char *buf)
-{
-  return buffer_putalign(s,buf,str_len(buf));
-}
-
-int buffer_puts(buffer *s,char *buf)
+	while (len)
+	{
+		w = op(fd, buf, len);
+		if (w == -1)
+		{
+			if (errno == error_intr)
+				continue;
+			return -1;			/*- note that some data may have been written */
+		}
+		if (w == 0);			/*- luser's fault */
+		buf += w;
+		len -= w;
+	}
+	return 0;
+}
+
+int
+buffer_flush(buffer * s)
+{
+	int             p;
+
+	p = s->p;
+	if (!p)
+		return 0;
+	s->p = 0;
+	return allwrite(s->op, s->fd, s->x, p);
+}
+
+int
+buffer_putalign(buffer * s, char *buf, unsigned int len)
+{
+	unsigned int    n;
+
+	while (len > (n = s->n - s->p))
+	{
+		byte_copy(s->x + s->p, n, buf);
+		s->p += n;
+		buf += n;
+		len -= n;
+		if (buffer_flush(s) == -1)
+			return -1;
+	}
+	/*- now len <= s->n - s->p */
+	byte_copy(s->x + s->p, len, buf);
+	s->p += len;
+	return 0;
+}
+
+int
+buffer_put(buffer * s, char *buf, unsigned int len)
+{
+	unsigned int    n;
+
+	n = s->n;
+	if (len > n - s->p)
+	{
+		if (buffer_flush(s) == -1)
+			return -1;
+		/*- now s->p == 0 */
+		if (n < BUFFER_OUTSIZE)
+			n = BUFFER_OUTSIZE;
+		while (len > s->n)
+		{
+			if (n > len)
+				n = len;
+			if (allwrite(s->op, s->fd, buf, n) == -1)
+				return -1;
+			buf += n;
+			len -= n;
+		}
+	}
+	/*- now len <= s->n - s->p */
+	byte_copy(s->x + s->p, len, buf);
+	s->p += len;
+	return 0;
+}
+
+int
+buffer_putflush(buffer * s, char *buf, unsigned int len)
+{
+	if (buffer_flush(s) == -1)
+		return -1;
+	return allwrite(s->op, s->fd, buf, len);
+}
+
+int
+buffer_putsalign(buffer * s, char *buf)
+{
+	return buffer_putalign(s, buf, str_len(buf));
+}
+
+int
+buffer_puts(buffer * s, char *buf)
 {
-  return buffer_put(s,buf,str_len(buf));
+	return buffer_put(s, buf, str_len(buf));
 }
 
-int buffer_putsflush(buffer *s,char *buf)
+int
+buffer_putsflush(buffer * s, char *buf)
 {
-  return buffer_putflush(s,buf,str_len(buf));
+	return buffer_putflush(s, buf, str_len(buf));
 }
diff -Naur tmp/ucspi-tcp-0.88/byte_chr.c ucspi-tcp-0.88/byte_chr.c
--- tmp/ucspi-tcp-0.88/byte_chr.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/byte_chr.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,20 +1,48 @@
+/*
+ * $Log: byte_chr.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "byte.h"
 
-unsigned int byte_chr(s,n,c)
-char *s;
-register unsigned int n;
-int c;
+unsigned int
+byte_chr(s, n, c)
+	char           *s;
+	register unsigned int n;
+	int             c;
 {
-  register char ch;
-  register char *t;
+	register char   ch;
+	register char  *t;
 
-  ch = c;
-  t = s;
-  for (;;) {
-    if (!n) break; if (*t == ch) break; ++t; --n;
-    if (!n) break; if (*t == ch) break; ++t; --n;
-    if (!n) break; if (*t == ch) break; ++t; --n;
-    if (!n) break; if (*t == ch) break; ++t; --n;
-  }
-  return t - s;
+	ch = c;
+	t = s;
+	for (;;)
+	{
+		if (!n)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+		--n;
+		if (!n)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+		--n;
+		if (!n)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+		--n;
+		if (!n)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+		--n;
+	}
+	return t - s;
 }
diff -Naur tmp/ucspi-tcp-0.88/byte_copy.c ucspi-tcp-0.88/byte_copy.c
--- tmp/ucspi-tcp-0.88/byte_copy.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/byte_copy.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,14 +1,34 @@
+/*
+ * $Log: byte_copy.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "byte.h"
 
-void byte_copy(to,n,from)
-register char *to;
-register unsigned int n;
-register char *from;
+void
+byte_copy(to, n, from)
+	register char  *to;
+	register unsigned int n;
+	register char  *from;
 {
-  for (;;) {
-    if (!n) return; *to++ = *from++; --n;
-    if (!n) return; *to++ = *from++; --n;
-    if (!n) return; *to++ = *from++; --n;
-    if (!n) return; *to++ = *from++; --n;
-  }
+	for (;;)
+	{
+		if (!n)
+			return;
+		*to++ = *from++;
+		--n;
+		if (!n)
+			return;
+		*to++ = *from++;
+		--n;
+		if (!n)
+			return;
+		*to++ = *from++;
+		--n;
+		if (!n)
+			return;
+		*to++ = *from++;
+		--n;
+	}
 }
diff -Naur tmp/ucspi-tcp-0.88/byte_cr.c ucspi-tcp-0.88/byte_cr.c
--- tmp/ucspi-tcp-0.88/byte_cr.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/byte_cr.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,16 +1,36 @@
+/*
+ * $Log: byte_cr.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "byte.h"
 
-void byte_copyr(to,n,from)
-register char *to;
-register unsigned int n;
-register char *from;
+void
+byte_copyr(to, n, from)
+	register char  *to;
+	register unsigned int n;
+	register char  *from;
 {
-  to += n;
-  from += n;
-  for (;;) {
-    if (!n) return; *--to = *--from; --n;
-    if (!n) return; *--to = *--from; --n;
-    if (!n) return; *--to = *--from; --n;
-    if (!n) return; *--to = *--from; --n;
-  }
+	to += n;
+	from += n;
+	for (;;)
+	{
+		if (!n)
+			return;
+		*--to = *--from;
+		--n;
+		if (!n)
+			return;
+		*--to = *--from;
+		--n;
+		if (!n)
+			return;
+		*--to = *--from;
+		--n;
+		if (!n)
+			return;
+		*--to = *--from;
+		--n;
+	}
 }
diff -Naur tmp/ucspi-tcp-0.88/byte_diff.c ucspi-tcp-0.88/byte_diff.c
--- tmp/ucspi-tcp-0.88/byte_diff.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/byte_diff.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,16 +1,47 @@
+/*
+ * $Log: byte_diff.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "byte.h"
 
-int byte_diff(s,n,t)
-register char *s;
-register unsigned int n;
-register char *t;
+int
+byte_diff(s, n, t)
+	register char  *s;
+	register unsigned int n;
+	register char  *t;
 {
-  for (;;) {
-    if (!n) return 0; if (*s != *t) break; ++s; ++t; --n;
-    if (!n) return 0; if (*s != *t) break; ++s; ++t; --n;
-    if (!n) return 0; if (*s != *t) break; ++s; ++t; --n;
-    if (!n) return 0; if (*s != *t) break; ++s; ++t; --n;
-  }
-  return ((int)(unsigned int)(unsigned char) *s)
-       - ((int)(unsigned int)(unsigned char) *t);
+	for (;;)
+	{
+		if (!n)
+			return 0;
+		if (*s != *t)
+			break;
+		++s;
+		++t;
+		--n;
+		if (!n)
+			return 0;
+		if (*s != *t)
+			break;
+		++s;
+		++t;
+		--n;
+		if (!n)
+			return 0;
+		if (*s != *t)
+			break;
+		++s;
+		++t;
+		--n;
+		if (!n)
+			return 0;
+		if (*s != *t)
+			break;
+		++s;
+		++t;
+		--n;
+	}
+	return ((int) (unsigned int) (unsigned char) *s) - ((int) (unsigned int) (unsigned char) *t);
 }
diff -Naur tmp/ucspi-tcp-0.88/byte.h ucspi-tcp-0.88/byte.h
--- tmp/ucspi-tcp-0.88/byte.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/byte.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,12 +1,21 @@
+/*
+ * $Log: byte.h,v $
+ * Revision 1.2  2005-05-13 23:32:13+05:30  Cprogrammer
+ * code indented
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef BYTE_H
 #define BYTE_H
 
-extern unsigned int byte_chr();
-extern unsigned int byte_rchr();
-extern void byte_copy();
-extern void byte_copyr();
-extern int byte_diff();
-extern void byte_zero();
+unsigned int    byte_chr();
+unsigned int    byte_rchr();
+void            byte_copy();
+void            byte_copyr();
+int             byte_diff();
+void            byte_zero();
 
 #define byte_equal(s,n,t) (!byte_diff((s),(n),(t)))
 
diff -Naur tmp/ucspi-tcp-0.88/byte_rchr.c ucspi-tcp-0.88/byte_rchr.c
--- tmp/ucspi-tcp-0.88/byte_rchr.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/byte_rchr.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,23 +1,52 @@
+/*
+ * $Log: byte_rchr.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "byte.h"
 
-unsigned int byte_rchr(s,n,c)
-char *s;
-register unsigned int n;
-int c;
+unsigned int
+byte_rchr(s, n, c)
+	char           *s;
+	register unsigned int n;
+	int             c;
 {
-  register char ch;
-  register char *t;
-  register char *u;
+	register char   ch;
+	register char  *t;
+	register char  *u;
 
-  ch = c;
-  t = s;
-  u = 0;
-  for (;;) {
-    if (!n) break; if (*t == ch) u = t; ++t; --n;
-    if (!n) break; if (*t == ch) u = t; ++t; --n;
-    if (!n) break; if (*t == ch) u = t; ++t; --n;
-    if (!n) break; if (*t == ch) u = t; ++t; --n;
-  }
-  if (!u) u = t;
-  return u - s;
+	ch = c;
+	t = s;
+	u = 0;
+	for (;;)
+	{
+		if (!n)
+			break;
+		if (*t == ch)
+			u = t;
+		++t;
+		--n;
+		if (!n)
+			break;
+		if (*t == ch)
+			u = t;
+		++t;
+		--n;
+		if (!n)
+			break;
+		if (*t == ch)
+			u = t;
+		++t;
+		--n;
+		if (!n)
+			break;
+		if (*t == ch)
+			u = t;
+		++t;
+		--n;
+	}
+	if (!u)
+		u = t;
+	return u - s;
 }
diff -Naur tmp/ucspi-tcp-0.88/byte_zero.c ucspi-tcp-0.88/byte_zero.c
--- tmp/ucspi-tcp-0.88/byte_zero.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/byte_zero.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,13 +1,33 @@
+/*
+ * $Log: byte_zero.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "byte.h"
 
-void byte_zero(s,n)
-char *s;
-register unsigned int n;
+void
+byte_zero(s, n)
+	char           *s;
+	register unsigned int n;
 {
-  for (;;) {
-    if (!n) break; *s++ = 0; --n;
-    if (!n) break; *s++ = 0; --n;
-    if (!n) break; *s++ = 0; --n;
-    if (!n) break; *s++ = 0; --n;
-  }
+	for (;;)
+	{
+		if (!n)
+			break;
+		*s++ = 0;
+		--n;
+		if (!n)
+			break;
+		*s++ = 0;
+		--n;
+		if (!n)
+			break;
+		*s++ = 0;
+		--n;
+		if (!n)
+			break;
+		*s++ = 0;
+		--n;
+	}
 }
diff -Naur tmp/ucspi-tcp-0.88/case_diffb.c ucspi-tcp-0.88/case_diffb.c
--- tmp/ucspi-tcp-0.88/case_diffb.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/case_diffb.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,18 +1,32 @@
+/*
+ * $Log: case_diffb.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "case.h"
 
-int case_diffb(register char *s,register unsigned int len,register char *t)
+int
+case_diffb(register char *s, register unsigned int len, register char *t)
 {
-  register unsigned char x;
-  register unsigned char y;
+	register unsigned char x;
+	register unsigned char y;
 
-  while (len > 0) {
-    --len;
-    x = *s++ - 'A';
-    if (x <= 'Z' - 'A') x += 'a'; else x += 'A';
-    y = *t++ - 'A';
-    if (y <= 'Z' - 'A') y += 'a'; else y += 'A';
-    if (x != y)
-      return ((int)(unsigned int) x) - ((int)(unsigned int) y);
-  }
-  return 0;
+	while (len > 0)
+	{
+		--len;
+		x = *s++ - 'A';
+		if (x <= 'Z' - 'A')
+			x += 'a';
+		else
+			x += 'A';
+		y = *t++ - 'A';
+		if (y <= 'Z' - 'A')
+			y += 'a';
+		else
+			y += 'A';
+		if (x != y)
+			return ((int) (unsigned int) x) - ((int) (unsigned int) y);
+	}
+	return 0;
 }
diff -Naur tmp/ucspi-tcp-0.88/case_diffs.c ucspi-tcp-0.88/case_diffs.c
--- tmp/ucspi-tcp-0.88/case_diffs.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/case_diffs.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,17 +1,33 @@
+/*
+ * $Log: case_diffs.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "case.h"
 
-int case_diffs(register char *s,register char *t)
+int
+case_diffs(register char *s, register char *t)
 {
-  register unsigned char x;
-  register unsigned char y;
+	register unsigned char x;
+	register unsigned char y;
 
-  for (;;) {
-    x = *s++ - 'A';
-    if (x <= 'Z' - 'A') x += 'a'; else x += 'A';
-    y = *t++ - 'A';
-    if (y <= 'Z' - 'A') y += 'a'; else y += 'A';
-    if (x != y) break;
-    if (!x) break;
-  }
-  return ((int)(unsigned int) x) - ((int)(unsigned int) y);
+	for (;;)
+	{
+		x = *s++ - 'A';
+		if (x <= 'Z' - 'A')
+			x += 'a';
+		else
+			x += 'A';
+		y = *t++ - 'A';
+		if (y <= 'Z' - 'A')
+			y += 'a';
+		else
+			y += 'A';
+		if (x != y)
+			break;
+		if (!x)
+			break;
+	}
+	return ((int) (unsigned int) x) - ((int) (unsigned int) y);
 }
diff -Naur tmp/ucspi-tcp-0.88/case.h ucspi-tcp-0.88/case.h
--- tmp/ucspi-tcp-0.88/case.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/case.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,12 +1,21 @@
+/*
+ * $Log: case.h,v $
+ * Revision 1.2  2005-05-13 23:43:34+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef CASE_H
 #define CASE_H
 
-extern void case_lowers(char *);
-extern void case_lowerb(char *,unsigned int);
-extern int case_diffs(char *,char *);
-extern int case_diffb(char *,unsigned int,char *);
-extern int case_starts(char *,char *);
-extern int case_startb(char *,unsigned int,char *);
+void            case_lowers(char *);
+void            case_lowerb(char *, unsigned int);
+int             case_diffs(char *, char *);
+int             case_diffb(char *, unsigned int, char *);
+int             case_starts(char *, char *);
+int             case_startb(char *, unsigned int, char *);
 
 #define case_equals(s,t) (!case_diffs((s),(t)))
 
diff -Naur tmp/ucspi-tcp-0.88/cdb.c ucspi-tcp-0.88/cdb.c
--- tmp/ucspi-tcp-0.88/cdb.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/cdb.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,136 +1,176 @@
-/* Public domain. */
+/*
+ * $Log: cdb.c,v $
+ * Revision 1.2  2008-07-17 23:02:54+05:30  Cprogrammer
+ * use unistd.h instead of readwrite.h
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ * Public domain. 
+ */
 
+#include <unistd.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/mman.h>
-#include "readwrite.h"
 #include "error.h"
 #include "seek.h"
 #include "byte.h"
 #include "cdb.h"
 
-void cdb_free(struct cdb *c)
+void
+cdb_free(struct cdb *c)
 {
-  if (c->map) {
-    munmap(c->map,c->size);
-    c->map = 0;
-  }
-}
-
-void cdb_findstart(struct cdb *c)
-{
-  c->loop = 0;
-}
-
-void cdb_init(struct cdb *c,int fd)
-{
-  struct stat st;
-  char *x;
-
-  cdb_free(c);
-  cdb_findstart(c);
-  c->fd = fd;
-
-  if (fstat(fd,&st) == 0)
-    if (st.st_size <= 0xffffffff) {
-      x = mmap(0,st.st_size,PROT_READ,MAP_SHARED,fd,0);
-      if (x + 1) {
-	c->size = st.st_size;
-	c->map = x;
-      }
-    }
-}
-
-int cdb_read(struct cdb *c,char *buf,unsigned int len,uint32 pos)
-{
-  if (c->map) {
-    if ((pos > c->size) || (c->size - pos < len)) goto FORMAT;
-    byte_copy(buf,len,c->map + pos);
-  }
-  else {
-    if (seek_set(c->fd,pos) == -1) return -1;
-    while (len > 0) {
-      int r;
-      do
-        r = read(c->fd,buf,len);
-      while ((r == -1) && (errno == error_intr));
-      if (r == -1) return -1;
-      if (r == 0) goto FORMAT;
-      buf += r;
-      len -= r;
-    }
-  }
-  return 0;
-
-  FORMAT:
-  errno = error_proto;
-  return -1;
-}
-
-static int match(struct cdb *c,char *key,unsigned int len,uint32 pos)
-{
-  char buf[32];
-  int n;
-
-  while (len > 0) {
-    n = sizeof buf;
-    if (n > len) n = len;
-    if (cdb_read(c,buf,n,pos) == -1) return -1;
-    if (byte_diff(buf,n,key)) return 0;
-    pos += n;
-    key += n;
-    len -= n;
-  }
-  return 1;
-}
-
-int cdb_findnext(struct cdb *c,char *key,unsigned int len)
-{
-  char buf[8];
-  uint32 pos;
-  uint32 u;
-
-  if (!c->loop) {
-    u = cdb_hash(key,len);
-    if (cdb_read(c,buf,8,(u << 3) & 2047) == -1) return -1;
-    uint32_unpack(buf + 4,&c->hslots);
-    if (!c->hslots) return 0;
-    uint32_unpack(buf,&c->hpos);
-    c->khash = u;
-    u >>= 8;
-    u %= c->hslots;
-    u <<= 3;
-    c->kpos = c->hpos + u;
-  }
-
-  while (c->loop < c->hslots) {
-    if (cdb_read(c,buf,8,c->kpos) == -1) return -1;
-    uint32_unpack(buf + 4,&pos);
-    if (!pos) return 0;
-    c->loop += 1;
-    c->kpos += 8;
-    if (c->kpos == c->hpos + (c->hslots << 3)) c->kpos = c->hpos;
-    uint32_unpack(buf,&u);
-    if (u == c->khash) {
-      if (cdb_read(c,buf,8,pos) == -1) return -1;
-      uint32_unpack(buf,&u);
-      if (u == len)
-	switch(match(c,key,len,pos + 8)) {
-	  case -1:
-	    return -1;
-	  case 1:
-	    uint32_unpack(buf + 4,&c->dlen);
-	    c->dpos = pos + 8 + len;
-	    return 1;
+	if (c->map)
+	{
+		munmap(c->map, c->size);
+		c->map = 0;
+	}
+}
+
+void
+cdb_findstart(struct cdb *c)
+{
+	c->loop = 0;
+}
+
+void
+cdb_init(struct cdb *c, int fd)
+{
+	struct stat     st;
+	char           *x;
+
+	cdb_free(c);
+	cdb_findstart(c);
+	c->fd = fd;
+
+	if (fstat(fd, &st) == 0)
+		if (st.st_size <= 0xffffffff)
+		{
+			x = mmap(0, st.st_size, PROT_READ, MAP_SHARED, fd, 0);
+			if (x + 1)
+			{
+				c->size = st.st_size;
+				c->map = x;
+			}
+		}
+}
+
+int
+cdb_read(struct cdb *c, char *buf, unsigned int len, uint32 pos)
+{
+	if (c->map)
+	{
+		if ((pos > c->size) || (c->size - pos < len))
+			goto FORMAT;
+		byte_copy(buf, len, c->map + pos);
+	} else
+	{
+		if (seek_set(c->fd, pos) == -1)
+			return -1;
+		while (len > 0)
+		{
+			int             r;
+			do
+				r = read(c->fd, buf, len);
+			while ((r == -1) && (errno == error_intr));
+			if (r == -1)
+				return -1;
+			if (r == 0)
+				goto FORMAT;
+			buf += r;
+			len -= r;
+		}
+	}
+	return 0;
+
+FORMAT:
+	errno = error_proto;
+	return -1;
+}
+
+static int
+match(struct cdb *c, char *key, unsigned int len, uint32 pos)
+{
+	char            buf[32];
+	int             n;
+
+	while (len > 0)
+	{
+		n = sizeof buf;
+		if (n > len)
+			n = len;
+		if (cdb_read(c, buf, n, pos) == -1)
+			return -1;
+		if (byte_diff(buf, n, key))
+			return 0;
+		pos += n;
+		key += n;
+		len -= n;
+	}
+	return 1;
+}
+
+int
+cdb_findnext(struct cdb *c, char *key, unsigned int len)
+{
+	char            buf[8];
+	uint32          pos;
+	uint32          u;
+
+	if (!c->loop)
+	{
+		u = cdb_hash(key, len);
+		if (cdb_read(c, buf, 8, (u << 3) & 2047) == -1)
+			return -1;
+		uint32_unpack(buf + 4, &c->hslots);
+		if (!c->hslots)
+			return 0;
+		uint32_unpack(buf, &c->hpos);
+		c->khash = u;
+		u >>= 8;
+		u %= c->hslots;
+		u <<= 3;
+		c->kpos = c->hpos + u;
+	}
+
+	while (c->loop < c->hslots)
+	{
+		if (cdb_read(c, buf, 8, c->kpos) == -1)
+			return -1;
+		uint32_unpack(buf + 4, &pos);
+		if (!pos)
+			return 0;
+		c->loop += 1;
+		c->kpos += 8;
+		if (c->kpos == c->hpos + (c->hslots << 3))
+			c->kpos = c->hpos;
+		uint32_unpack(buf, &u);
+		if (u == c->khash)
+		{
+			if (cdb_read(c, buf, 8, pos) == -1)
+				return -1;
+			uint32_unpack(buf, &u);
+			if (u == len)
+				switch (match(c, key, len, pos + 8))
+				{
+				case -1:
+					return -1;
+				case 1:
+					uint32_unpack(buf + 4, &c->dlen);
+					c->dpos = pos + 8 + len;
+					return 1;
+				}
+		}
 	}
-    }
-  }
 
-  return 0;
+	return 0;
 }
 
-int cdb_find(struct cdb *c,char *key,unsigned int len)
+int
+cdb_find(struct cdb *c, char *key, unsigned int len)
 {
-  cdb_findstart(c);
-  return cdb_findnext(c,key,len);
+	cdb_findstart(c);
+	return cdb_findnext(c, key, len);
 }
diff -Naur tmp/ucspi-tcp-0.88/cdb.h ucspi-tcp-0.88/cdb.h
--- tmp/ucspi-tcp-0.88/cdb.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/cdb.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,4 +1,13 @@
-/* Public domain. */
+/*
+ * $Log: cdb.h,v $
+ * Revision 1.2  2005-05-13 23:43:59+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+/*- Public domain. */
 
 #ifndef CDB_H
 #define CDB_H
@@ -6,30 +15,31 @@
 #include "uint32.h"
 
 #define CDB_HASHSTART 5381
-extern uint32 cdb_hashadd(uint32,unsigned char);
-extern uint32 cdb_hash(char *,unsigned int);
+uint32          cdb_hashadd(uint32, unsigned char);
+uint32          cdb_hash(char *, unsigned int);
 
-struct cdb {
-  char *map; /* 0 if no map is available */
-  int fd;
-  uint32 size; /* initialized if map is nonzero */
-  uint32 loop; /* number of hash slots searched under this key */
-  uint32 khash; /* initialized if loop is nonzero */
-  uint32 kpos; /* initialized if loop is nonzero */
-  uint32 hpos; /* initialized if loop is nonzero */
-  uint32 hslots; /* initialized if loop is nonzero */
-  uint32 dpos; /* initialized if cdb_findnext() returns 1 */
-  uint32 dlen; /* initialized if cdb_findnext() returns 1 */
-} ;
-
-extern void cdb_free(struct cdb *);
-extern void cdb_init(struct cdb *,int fd);
-
-extern int cdb_read(struct cdb *,char *,unsigned int,uint32);
-
-extern void cdb_findstart(struct cdb *);
-extern int cdb_findnext(struct cdb *,char *,unsigned int);
-extern int cdb_find(struct cdb *,char *,unsigned int);
+struct cdb
+{
+	char           *map;	/*- 0 if no map is available */
+	int             fd;
+	uint32          size;	/*- initialized if map is nonzero */
+	uint32          loop;	/*- number of hash slots searched under this key */
+	uint32          khash;	/*- initialized if loop is nonzero */
+	uint32          kpos;	/*- initialized if loop is nonzero */
+	uint32          hpos;	/*- initialized if loop is nonzero */
+	uint32          hslots;	/*- initialized if loop is nonzero */
+	uint32          dpos;	/*- initialized if cdb_findnext() returns 1 */
+	uint32          dlen;	/*- initialized if cdb_findnext() returns 1 */
+};
+
+void            cdb_free(struct cdb *);
+void            cdb_init(struct cdb *, int fd);
+
+int             cdb_read(struct cdb *, char *, unsigned int, uint32);
+
+void            cdb_findstart(struct cdb *);
+int             cdb_findnext(struct cdb *, char *, unsigned int);
+int             cdb_find(struct cdb *, char *, unsigned int);
 
 #define cdb_datapos(c) ((c)->dpos)
 #define cdb_datalen(c) ((c)->dlen)
diff -Naur tmp/ucspi-tcp-0.88/cdb_hash.c ucspi-tcp-0.88/cdb_hash.c
--- tmp/ucspi-tcp-0.88/cdb_hash.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/cdb_hash.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,21 +1,31 @@
-/* Public domain. */
+/*
+ * $Log: cdb_hash.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ * Public domain. 
+ */
 
 #include "cdb.h"
 
-uint32 cdb_hashadd(uint32 h,unsigned char c)
+uint32
+cdb_hashadd(uint32 h, unsigned char c)
 {
-  h += (h << 5);
-  return h ^ c;
+	h += (h << 5);
+	return h ^ c;
 }
 
-uint32 cdb_hash(char *buf,unsigned int len)
+uint32
+cdb_hash(char *buf, unsigned int len)
 {
-  uint32 h;
+	uint32          h;
 
-  h = CDB_HASHSTART;
-  while (len) {
-    h = cdb_hashadd(h,*buf++);
-    --len;
-  }
-  return h;
+	h = CDB_HASHSTART;
+	while (len)
+	{
+		h = cdb_hashadd(h, *buf++);
+		--len;
+	}
+	return h;
 }
diff -Naur tmp/ucspi-tcp-0.88/cdb_make.c ucspi-tcp-0.88/cdb_make.c
--- tmp/ucspi-tcp-0.88/cdb_make.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/cdb_make.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,153 +1,206 @@
-/* Public domain. */
+/*
+ * $Log: cdb_make.c,v $
+ * Revision 1.2  2008-07-17 23:03:01+05:30  Cprogrammer
+ * use unistd.h instead of readwrite.h
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ * Public domain. 
+ */
 
-#include "readwrite.h"
+#include <unistd.h>
 #include "seek.h"
 #include "error.h"
 #include "alloc.h"
 #include "cdb.h"
 #include "cdb_make.h"
 
-int cdb_make_start(struct cdb_make *c,int fd)
+int
+cdb_make_start(struct cdb_make *c, int fd)
 {
-  c->head = 0;
-  c->split = 0;
-  c->hash = 0;
-  c->numentries = 0;
-  c->fd = fd;
-  c->pos = sizeof c->final;
-  buffer_init(&c->b,write,fd,c->bspace,sizeof c->bspace);
-  return seek_set(fd,c->pos);
-}
-
-static int posplus(struct cdb_make *c,uint32 len)
-{
-  uint32 newpos = c->pos + len;
-  if (newpos < len) { errno = error_nomem; return -1; }
-  c->pos = newpos;
-  return 0;
-}
-
-int cdb_make_addend(struct cdb_make *c,unsigned int keylen,unsigned int datalen,uint32 h)
-{
-  struct cdb_hplist *head;
-
-  head = c->head;
-  if (!head || (head->num >= CDB_HPLIST)) {
-    head = (struct cdb_hplist *) alloc(sizeof(struct cdb_hplist));
-    if (!head) return -1;
-    head->num = 0;
-    head->next = c->head;
-    c->head = head;
-  }
-  head->hp[head->num].h = h;
-  head->hp[head->num].p = c->pos;
-  ++head->num;
-  ++c->numentries;
-  if (posplus(c,8) == -1) return -1;
-  if (posplus(c,keylen) == -1) return -1;
-  if (posplus(c,datalen) == -1) return -1;
-  return 0;
-}
-
-int cdb_make_addbegin(struct cdb_make *c,unsigned int keylen,unsigned int datalen)
-{
-  char buf[8];
-
-  if (keylen > 0xffffffff) { errno = error_nomem; return -1; }
-  if (datalen > 0xffffffff) { errno = error_nomem; return -1; }
-
-  uint32_pack(buf,keylen);
-  uint32_pack(buf + 4,datalen);
-  if (buffer_putalign(&c->b,buf,8) == -1) return -1;
-  return 0;
-}
-
-int cdb_make_add(struct cdb_make *c,char *key,unsigned int keylen,char *data,unsigned int datalen)
-{
-  if (cdb_make_addbegin(c,keylen,datalen) == -1) return -1;
-  if (buffer_putalign(&c->b,key,keylen) == -1) return -1;
-  if (buffer_putalign(&c->b,data,datalen) == -1) return -1;
-  return cdb_make_addend(c,keylen,datalen,cdb_hash(key,keylen));
-}
-
-int cdb_make_finish(struct cdb_make *c)
-{
-  char buf[8];
-  int i;
-  uint32 len;
-  uint32 u;
-  uint32 memsize;
-  uint32 count;
-  uint32 where;
-  struct cdb_hplist *x;
-  struct cdb_hp *hp;
-
-  for (i = 0;i < 256;++i)
-    c->count[i] = 0;
-
-  for (x = c->head;x;x = x->next) {
-    i = x->num;
-    while (i--)
-      ++c->count[255 & x->hp[i].h];
-  }
-
-  memsize = 1;
-  for (i = 0;i < 256;++i) {
-    u = c->count[i] * 2;
-    if (u > memsize)
-      memsize = u;
-  }
-
-  memsize += c->numentries; /* no overflow possible up to now */
-  u = (uint32) 0 - (uint32) 1;
-  u /= sizeof(struct cdb_hp);
-  if (memsize > u) { errno = error_nomem; return -1; }
-
-  c->split = (struct cdb_hp *) alloc(memsize * sizeof(struct cdb_hp));
-  if (!c->split) return -1;
-
-  c->hash = c->split + c->numentries;
-
-  u = 0;
-  for (i = 0;i < 256;++i) {
-    u += c->count[i]; /* bounded by numentries, so no overflow */
-    c->start[i] = u;
-  }
-
-  for (x = c->head;x;x = x->next) {
-    i = x->num;
-    while (i--)
-      c->split[--c->start[255 & x->hp[i].h]] = x->hp[i];
-  }
-
-  for (i = 0;i < 256;++i) {
-    count = c->count[i];
-
-    len = count + count; /* no overflow possible */
-    uint32_pack(c->final + 8 * i,c->pos);
-    uint32_pack(c->final + 8 * i + 4,len);
-
-    for (u = 0;u < len;++u)
-      c->hash[u].h = c->hash[u].p = 0;
-
-    hp = c->split + c->start[i];
-    for (u = 0;u < count;++u) {
-      where = (hp->h >> 8) % len;
-      while (c->hash[where].p)
-	if (++where == len)
-	  where = 0;
-      c->hash[where] = *hp++;
-    }
-
-    for (u = 0;u < len;++u) {
-      uint32_pack(buf,c->hash[u].h);
-      uint32_pack(buf + 4,c->hash[u].p);
-      if (buffer_putalign(&c->b,buf,8) == -1) return -1;
-      if (posplus(c,8) == -1) return -1;
-    }
-  }
-
-  if (buffer_flush(&c->b) == -1) return -1;
-  if (seek_begin(c->fd) == -1) return -1;
-  return buffer_putflush(&c->b,c->final,sizeof c->final);
+	c->head = 0;
+	c->split = 0;
+	c->hash = 0;
+	c->numentries = 0;
+	c->fd = fd;
+	c->pos = sizeof c->final;
+	buffer_init(&c->b, write, fd, c->bspace, sizeof c->bspace);
+	return seek_set(fd, c->pos);
+}
+
+static int
+posplus(struct cdb_make *c, uint32 len)
+{
+	uint32          newpos = c->pos + len;
+	if (newpos < len)
+	{
+		errno = error_nomem;
+		return -1;
+	}
+	c->pos = newpos;
+	return 0;
+}
+
+int
+cdb_make_addend(struct cdb_make *c, unsigned int keylen, unsigned int datalen, uint32 h)
+{
+	struct cdb_hplist *head;
+
+	head = c->head;
+	if (!head || (head->num >= CDB_HPLIST))
+	{
+		head = (struct cdb_hplist *) alloc(sizeof(struct cdb_hplist));
+		if (!head)
+			return -1;
+		head->num = 0;
+		head->next = c->head;
+		c->head = head;
+	}
+	head->hp[head->num].h = h;
+	head->hp[head->num].p = c->pos;
+	++head->num;
+	++c->numentries;
+	if (posplus(c, 8) == -1)
+		return -1;
+	if (posplus(c, keylen) == -1)
+		return -1;
+	if (posplus(c, datalen) == -1)
+		return -1;
+	return 0;
+}
+
+int
+cdb_make_addbegin(struct cdb_make *c, unsigned int keylen, unsigned int datalen)
+{
+	char            buf[8];
+
+	if (keylen > 0xffffffff)
+	{
+		errno = error_nomem;
+		return -1;
+	}
+	if (datalen > 0xffffffff)
+	{
+		errno = error_nomem;
+		return -1;
+	}
+
+	uint32_pack(buf, keylen);
+	uint32_pack(buf + 4, datalen);
+	if (buffer_putalign(&c->b, buf, 8) == -1)
+		return -1;
+	return 0;
+}
+
+int
+cdb_make_add(struct cdb_make *c, char *key, unsigned int keylen, char *data, unsigned int datalen)
+{
+	if (cdb_make_addbegin(c, keylen, datalen) == -1)
+		return -1;
+	if (buffer_putalign(&c->b, key, keylen) == -1)
+		return -1;
+	if (buffer_putalign(&c->b, data, datalen) == -1)
+		return -1;
+	return cdb_make_addend(c, keylen, datalen, cdb_hash(key, keylen));
+}
+
+int
+cdb_make_finish(struct cdb_make *c)
+{
+	char            buf[8];
+	int             i;
+	uint32          len;
+	uint32          u;
+	uint32          memsize;
+	uint32          count;
+	uint32          where;
+	struct cdb_hplist *x;
+	struct cdb_hp  *hp;
+
+	for (i = 0; i < 256; ++i)
+		c->count[i] = 0;
+
+	for (x = c->head; x; x = x->next)
+	{
+		i = x->num;
+		while (i--)
+			++c->count[255 & x->hp[i].h];
+	}
+
+	memsize = 1;
+	for (i = 0; i < 256; ++i)
+	{
+		u = c->count[i] * 2;
+		if (u > memsize)
+			memsize = u;
+	}
+
+	memsize += c->numentries;	/*- no overflow possible up to now */
+	u = (uint32) 0 - (uint32) 1;
+	u /= sizeof(struct cdb_hp);
+	if (memsize > u)
+	{
+		errno = error_nomem;
+		return -1;
+	}
+
+	c->split = (struct cdb_hp *) alloc(memsize * sizeof(struct cdb_hp));
+	if (!c->split)
+		return -1;
+
+	c->hash = c->split + c->numentries;
+
+	u = 0;
+	for (i = 0; i < 256; ++i)
+	{
+		u += c->count[i];		/*- bounded by numentries, so no overflow */
+		c->start[i] = u;
+	}
+
+	for (x = c->head; x; x = x->next)
+	{
+		i = x->num;
+		while (i--)
+			c->split[--c->start[255 & x->hp[i].h]] = x->hp[i];
+	}
+
+	for (i = 0; i < 256; ++i)
+	{
+		count = c->count[i];
+
+		len = count + count;	/*- no overflow possible */
+		uint32_pack(c->final + 8 * i, c->pos);
+		uint32_pack(c->final + 8 * i + 4, len);
+
+		for (u = 0; u < len; ++u)
+			c->hash[u].h = c->hash[u].p = 0;
+
+		hp = c->split + c->start[i];
+		for (u = 0; u < count; ++u)
+		{
+			where = (hp->h >> 8) % len;
+			while (c->hash[where].p)
+				if (++where == len)
+					where = 0;
+			c->hash[where] = *hp++;
+		}
+
+		for (u = 0; u < len; ++u)
+		{
+			uint32_pack(buf, c->hash[u].h);
+			uint32_pack(buf + 4, c->hash[u].p);
+			if (buffer_putalign(&c->b, buf, 8) == -1)
+				return -1;
+			if (posplus(c, 8) == -1)
+				return -1;
+		}
+	}
+
+	if (buffer_flush(&c->b) == -1)
+		return -1;
+	if (seek_begin(c->fd) == -1)
+		return -1;
+	return buffer_putflush(&c->b, c->final, sizeof c->final);
 }
diff -Naur tmp/ucspi-tcp-0.88/cdb_make.h ucspi-tcp-0.88/cdb_make.h
--- tmp/ucspi-tcp-0.88/cdb_make.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/cdb_make.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,4 +1,15 @@
-/* Public domain. */
+/*
+ * $Log: cdb_make.h,v $
+ * Revision 1.2  2005-05-13 23:44:18+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+/*
+ * Public domain. 
+ */
 
 #ifndef CDB_MAKE_H
 #define CDB_MAKE_H
@@ -8,32 +19,38 @@
 
 #define CDB_HPLIST 1000
 
-struct cdb_hp { uint32 h; uint32 p; } ;
-
-struct cdb_hplist {
-  struct cdb_hp hp[CDB_HPLIST];
-  struct cdb_hplist *next;
-  int num;
-} ;
-
-struct cdb_make {
-  char bspace[8192];
-  char final[2048];
-  uint32 count[256];
-  uint32 start[256];
-  struct cdb_hplist *head;
-  struct cdb_hp *split; /* includes space for hash */
-  struct cdb_hp *hash;
-  uint32 numentries;
-  buffer b;
-  uint32 pos;
-  int fd;
-} ;
-
-extern int cdb_make_start(struct cdb_make *,int);
-extern int cdb_make_addbegin(struct cdb_make *,unsigned int,unsigned int);
-extern int cdb_make_addend(struct cdb_make *,unsigned int,unsigned int,uint32);
-extern int cdb_make_add(struct cdb_make *,char *,unsigned int,char *,unsigned int);
-extern int cdb_make_finish(struct cdb_make *);
+struct cdb_hp
+{
+	uint32          h;
+	uint32          p;
+};
+
+struct cdb_hplist
+{
+	struct cdb_hp   hp[CDB_HPLIST];
+	struct cdb_hplist *next;
+	int             num;
+};
+
+struct cdb_make
+{
+	char            bspace[8192];
+	char            final[2048];
+	uint32          count[256];
+	uint32          start[256];
+	struct cdb_hplist *head;
+	struct cdb_hp  *split;		/*- includes space for hash */
+	struct cdb_hp  *hash;
+	uint32          numentries;
+	buffer          b;
+	uint32          pos;
+	int             fd;
+};
+
+int             cdb_make_start(struct cdb_make *, int);
+int             cdb_make_addbegin(struct cdb_make *, unsigned int, unsigned int);
+int             cdb_make_addend(struct cdb_make *, unsigned int, unsigned int, uint32);
+int             cdb_make_add(struct cdb_make *, char *, unsigned int, char *, unsigned int);
+int             cdb_make_finish(struct cdb_make *);
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/chkshsgr.c ucspi-tcp-0.88/chkshsgr.c
--- tmp/ucspi-tcp-0.88/chkshsgr.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/chkshsgr.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,10 +1,25 @@
+/*
+ * $Log: chkshsgr.c,v $
+ * Revision 1.2  2007-06-10 10:12:16+05:30  Cprogrammer
+ * datatype changed to gid_t
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "exit.h"
+#include <sys/types.h>
+#include <unistd.h>
+#include <grp.h>
 
+int
 main()
 {
-  short x[4];
+	gid_t           x[4];
 
-  x[0] = x[1] = 0;
-  if (getgroups(1,x) == 0) if (setgroups(1,x) == -1) _exit(1);
-  _exit(0);
+	x[0] = x[1] = 0;
+	if (!getgroups(1, (gid_t *) x) && setgroups(1, (gid_t *) x) == -1)
+		_exit(1);
+	_exit(0);
+	/*- Not reached */
 }
diff -Naur tmp/ucspi-tcp-0.88/choose.sh ucspi-tcp-0.88/choose.sh
--- tmp/ucspi-tcp-0.88/choose.sh	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/choose.sh	2008-07-30 12:12:10.000000000 +0530
@@ -1,4 +1,12 @@
-
+#
+# $Log: choose.sh,v $
+# Revision 1.2  2008-07-30 12:11:54+05:30  Cprogrammer
+# added option 'R' which doesn't delete
+#
+# Revision 1.1  2003-12-31 19:57:58+05:30  Cprogrammer
+# Initial revision
+#
+#
 result="$4"
 
 case "$1" in
@@ -13,6 +21,12 @@
   *r*) ./$2 >/dev/null 2>&1 || result="$3" ;;
 esac
 
-rm -f $2.o $2
+case "$1" in
+  *R*) ./$2 >/dev/null 2>&1 || result="$3" ;;
+esac
+
+case "$1" in
+	*c* | *l* | *r*) rm -f $2.o $2 ;;
+esac
 
 exec cat "$result"
diff -Naur tmp/ucspi-tcp-0.88/commands.c ucspi-tcp-0.88/commands.c
--- tmp/ucspi-tcp-0.88/commands.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/commands.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,39 +1,61 @@
+/*
+ * $Log: commands.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "buffer.h"
 #include "stralloc.h"
 #include "str.h"
 #include "case.h"
 #include "commands.h"
 
-static stralloc cmd = {0};
+static stralloc cmd = { 0 };
 
-int commands(buffer *ss,struct commands *c)
+int
+commands(buffer * ss, struct commands *c)
 {
-  int i;
-  char *arg;
-  char ch;
-
-  for (;;) {
-    if (!stralloc_copys(&cmd,"")) return -1;
-
-    for (;;) {
-      i = buffer_get(ss,&ch,1);
-      if (i != 1) return i;
-      if (ch == '\n') break;
-      if (!ch) ch = '\n';
-      if (!stralloc_append(&cmd,&ch)) return -1;
-    }
-
-    if (cmd.len > 0) if (cmd.s[cmd.len - 1] == '\r') --cmd.len;
-
-    if (!stralloc_0(&cmd)) return -1;
-
-    i = str_chr(cmd.s,' ');
-    arg = cmd.s + i;
-    while (*arg == ' ') ++arg;
-    cmd.s[i] = 0;
-
-    for (i = 0;c[i].verb;++i) if (case_equals(c[i].verb,cmd.s)) break;
-    c[i].action(arg);
-    if (c[i].flush) c[i].flush();
-  }
+	int             i;
+	char           *arg;
+	char            ch;
+
+	for (;;)
+	{
+		if (!stralloc_copys(&cmd, ""))
+			return -1;
+
+		for (;;)
+		{
+			i = buffer_get(ss, &ch, 1);
+			if (i != 1)
+				return i;
+			if (ch == '\n')
+				break;
+			if (!ch)
+				ch = '\n';
+			if (!stralloc_append(&cmd, &ch))
+				return -1;
+		}
+
+		if (cmd.len > 0 && cmd.s[cmd.len - 1] == '\r')
+			--cmd.len;
+
+		if (!stralloc_0(&cmd))
+			return -1;
+
+		i = str_chr(cmd.s, ' ');
+		arg = cmd.s + i;
+		while (*arg == ' ')
+			++arg;
+		cmd.s[i] = 0;
+
+		for (i = 0; c[i].verb; ++i)
+		{
+			if (case_equals(c[i].verb, cmd.s))
+				break;
+		}
+		c[i].action(arg);
+		if (c[i].flush)
+			c[i].flush();
+	}
 }
diff -Naur tmp/ucspi-tcp-0.88/commands.h ucspi-tcp-0.88/commands.h
--- tmp/ucspi-tcp-0.88/commands.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/commands.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,12 +1,22 @@
+/*
+ * $Log: commands.h,v $
+ * Revision 1.2  2005-05-13 23:44:28+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef COMMANDS_H
 #define COMMANDS_H
 
-struct commands {
-  char *verb;
-  void (*action)(char *);
-  void (*flush)(void);
-} ;
+struct commands
+{
+	char           *verb;
+	void            (*action) (char *);
+	void            (*flush) (void);
+};
 
-extern int commands(buffer *,struct commands *);
+int             commands(buffer *, struct commands *);
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/conf-cc ucspi-tcp-0.88/conf-cc
--- tmp/ucspi-tcp-0.88/conf-cc	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/conf-cc	2008-07-26 12:00:57.000000000 +0530
@@ -1,3 +1,3 @@
-gcc -O2
+cc -Wall -O2
 
 This will be used to compile .c files.
diff -Naur tmp/ucspi-tcp-0.88/conf-home ucspi-tcp-0.88/conf-home
--- tmp/ucspi-tcp-0.88/conf-home	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/conf-home	2009-09-22 01:52:11.910070513 +0530
@@ -1,4 +1,4 @@
-/usr/local
+/var/indimail
 
 This is the ucspi-tcp home directory. Programs will be installed in
 .../bin.
diff -Naur tmp/ucspi-tcp-0.88/conf-home.in ucspi-tcp-0.88/conf-home.in
--- tmp/ucspi-tcp-0.88/conf-home.in	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/conf-home.in	2009-02-10 10:25:08.000000000 +0530
@@ -0,0 +1,4 @@
+HOME
+
+This is the ucspi-tcp home directory. Programs will be installed in
+.../bin.
diff -Naur tmp/ucspi-tcp-0.88/conf-ip ucspi-tcp-0.88/conf-ip
--- tmp/ucspi-tcp-0.88/conf-ip	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/conf-ip	2005-06-10 12:08:15.000000000 +0530
@@ -0,0 +1 @@
+-DIPV6
diff -Naur tmp/ucspi-tcp-0.88/conf-ld ucspi-tcp-0.88/conf-ld
--- tmp/ucspi-tcp-0.88/conf-ld	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/conf-ld	2009-02-10 23:07:12.000000000 +0530
@@ -1,3 +1,3 @@
-gcc -s
+cc -O2 -s
 
 This will be used to link .o files into an executable.
diff -Naur tmp/ucspi-tcp-0.88/conf-mysqlrules ucspi-tcp-0.88/conf-mysqlrules
--- tmp/ucspi-tcp-0.88/conf-mysqlrules	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/conf-mysqlrules	2008-08-13 10:24:20.000000000 +0530
@@ -0,0 +1 @@
+-DMYSQL_CONFIG
diff -Naur tmp/ucspi-tcp-0.88/conf-tls ucspi-tcp-0.88/conf-tls
--- tmp/ucspi-tcp-0.88/conf-tls	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/conf-tls	2008-07-28 11:16:53.000000000 +0530
@@ -0,0 +1 @@
+-DTLS
diff -Naur tmp/ucspi-tcp-0.88/control.c ucspi-tcp-0.88/control.c
--- tmp/ucspi-tcp-0.88/control.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/control.c	2008-07-27 18:41:45.000000000 +0530
@@ -0,0 +1,125 @@
+/*
+ * $Log: control.c,v $
+ * Revision 1.1  2003-12-27 17:15:20+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "buffer.h"
+#include "stralloc.h"
+#include "scan.h"
+#include "error.h"
+#include "open.h"
+#include "getln.h"
+#include "env.h"
+#include "control.h"
+#include <unistd.h>
+
+static char     inbuf[64];
+static stralloc line = { 0 };
+
+int
+control_readint(i, fn)
+	int            *i;
+	char           *fn;
+{
+	unsigned long   u;
+
+	switch (control_readline(&line, fn))
+	{
+	case 0:
+		return 0;
+	case -1:
+		return -1;
+	}
+	if (!stralloc_0(&line))
+		return -1;
+	if (!scan_ulong(line.s, &u))
+		return 0;
+	*i = u;
+	return 1;
+}
+
+int
+control_readline(sa, fn)
+	stralloc       *sa;
+	char           *fn;
+{
+	buffer          ss;
+	int             fd, match;
+
+	if((fd = open_read(fn)) == -1)
+	{
+		if (errno == error_noent)
+			return 0;
+		return -1;
+	}
+	buffer_init(&ss, read, fd, inbuf, sizeof inbuf);
+	if (getln(&ss, sa, &match, '\n') == -1)
+	{
+		close(fd);
+		return -1;
+	}
+	striptrailingwhitespace(sa);
+	close(fd);
+	return 1;
+}
+
+int
+control_readfile(sa, fn)
+	stralloc       *sa;
+	char           *fn;
+{
+	int             fd, match;
+	buffer          ssin;
+
+	if (!stralloc_copys(sa, ""))
+		return -1;
+	if((fd = open_read(fn)) == -1)
+	{
+		if (errno == error_noent)
+			return 0;
+		return -1;
+	}
+	buffer_init(&ssin, read, fd, inbuf, sizeof inbuf);
+	for (;;)
+	{
+		if (getln(&ssin, &line, &match, '\n') == -1)
+			break;
+		if (!match && !line.len)
+		{
+			close(fd);
+			return 1;
+		}
+		striptrailingwhitespace(&line);
+		if (!stralloc_0(&line))
+			break;
+		if (line.s[0] && line.s[0] != '#' && !stralloc_cat(sa, &line))
+			break;
+		if (!match)
+		{
+			close(fd);
+			return 1;
+		}
+	}
+	close(fd);
+	return -1;
+}
+
+void
+striptrailingwhitespace(sa)
+	stralloc       *sa;
+{
+	while (sa->len > 0)
+	{
+		switch (sa->s[sa->len - 1])
+		{
+		case '\n':
+		case ' ':
+		case '\t':
+			--sa->len;
+			break;
+		default:
+			return;
+		}
+	}
+}
diff -Naur tmp/ucspi-tcp-0.88/control.h ucspi-tcp-0.88/control.h
--- tmp/ucspi-tcp-0.88/control.h	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/control.h	2008-07-27 18:41:52.000000000 +0530
@@ -0,0 +1,18 @@
+/*
+ * $Log: control.h,v $
+ * Revision 1.2  2005-05-13 23:44:37+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifndef CONTROL_H
+#define CONTROL_H
+#include "stralloc.h"
+
+int             control_readint(int *, char *);
+int             control_readline(stralloc *, char *);
+int             control_readfile(stralloc *, char *);
+void            striptrailingwhitespace(stralloc *);
+#endif
diff -Naur tmp/ucspi-tcp-0.88/date@.1 ucspi-tcp-0.88/date@.1
--- tmp/ucspi-tcp-0.88/date@.1	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/date@.1	2000-11-16 17:06:19.000000000 +0530
@@ -0,0 +1,44 @@
+.TH date@ 1
+.SH NAME
+date@ \- prints the date on a remote host.
+.SH SYNOPSIS
+.B date@
+[
+.I host
+]
+.SH DESCRIPTION
+.B date@
+connects to TCP port 13 (Daytime) on
+.I host
+and prints any data it receives. It removes CR (\\015) and converts unprintable
+characters to a visible format. 
+
+If
+.I host
+is not supplied,
+.B date@
+connects to the local host. 
+
+Some computers respond to port 13 with a human-readable date. For example,
+they may be running 
+.IP
+tcpserver -RHl0 0 13 date
+.P
+using tcpserver. 
+.SH SEE ALSO
+tcpserver(1),
+tcprules(1),
+tcprulescheck(1),
+argv0(1),
+fixcrio(1),
+recordio(1),
+rblsmtpd(1),
+tcpclient(1),
+who@(1),
+finger@(1),
+http@(1),
+tcpcat(1),
+mconnect(1),
+tcp-environ(5)
+
+http://cr.yp.to/ucspi-tcp.html
diff -Naur tmp/ucspi-tcp-0.88/date@.sh ucspi-tcp-0.88/date@.sh
--- tmp/ucspi-tcp-0.88/date@.sh	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/date@.sh	2008-07-27 18:42:20.000000000 +0530
@@ -1 +1,6 @@
+# $Log: date@.sh,v $
+# Revision 1.1  2003-12-31 19:57:58+05:30  Cprogrammer
+# Initial revision
+#
+#
 HOME/bin/tcpclient -RHl0 -- "${1-0}" 13 sh -c 'exec HOME/bin/delcr <&6' | cat -v
diff -Naur tmp/ucspi-tcp-0.88/delcr.c ucspi-tcp-0.88/delcr.c
--- tmp/ucspi-tcp-0.88/delcr.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/delcr.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,37 +0,0 @@
-#include "buffer.h"
-#include "exit.h"
-
-main()
-{
-  register int n;
-  register char *x;
-  char ch;
-  register int flagcr = 0;
-
-  for (;;) {
-    n = buffer_feed(buffer_0);
-    if (n < 0) _exit(111);
-    if (!n) {
-      if (flagcr) buffer_PUTC(buffer_1,"\r"[0]);
-      buffer_flush(buffer_1);
-      _exit(0);
-    }
-    x = buffer_PEEK(buffer_0);
-    buffer_SEEK(buffer_0,n);
-
-    while (n > 0) {
-      ch = *x++; --n;
-      if (!flagcr) {
-        if (ch == '\r') { flagcr = 1; continue; }
-	buffer_PUTC(buffer_1,ch);
-	continue;
-      }
-      if (ch != '\n') {
-        buffer_PUTC(buffer_1,"\r"[0]);
-        if (ch == '\r') continue;
-      }
-      flagcr = 0;
-      buffer_PUTC(buffer_1,ch);
-    }
-  }
-}
diff -Naur tmp/ucspi-tcp-0.88/dns_dfd.c ucspi-tcp-0.88/dns_dfd.c
--- tmp/ucspi-tcp-0.88/dns_dfd.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns_dfd.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,69 +1,96 @@
+/*
+ * $Log: dns_dfd.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "error.h"
 #include "alloc.h"
 #include "byte.h"
 #include "dns.h"
 
-int dns_domain_fromdot(char **out,char *buf,unsigned int n)
+int
+dns_domain_fromdot(char **out, char *buf, unsigned int n)
 {
-  char label[63];
-  unsigned int labellen = 0; /* <= sizeof label */
-  char name[255];
-  unsigned int namelen = 0; /* <= sizeof name */
-  char ch;
-  char *x;
-
-  errno = error_proto;
-
-  for (;;) {
-    if (!n) break;
-    ch = *buf++; --n;
-    if (ch == '.') {
-      if (labellen) {
-	if (namelen + labellen + 1 > sizeof name) return 0;
-	name[namelen++] = labellen;
-	byte_copy(name + namelen,labellen,label);
-	namelen += labellen;
-	labellen = 0;
-      }
-      continue;
-    }
-    if (ch == '\\') {
-      if (!n) break;
-      ch = *buf++; --n;
-      if ((ch >= '0') && (ch <= '7')) {
-	ch -= '0';
-	if (n && (*buf >= '0') && (*buf <= '7')) {
-	  ch <<= 3;
-	  ch += *buf - '0';
-	  ++buf; --n;
-	  if (n && (*buf >= '0') && (*buf <= '7')) {
-	    ch <<= 3;
-	    ch += *buf - '0';
-	    ++buf; --n;
-	  }
+	char            label[63];
+	unsigned int    labellen = 0;	/*- <= sizeof label */
+	char            name[255];
+	unsigned int    namelen = 0;	/*- <= sizeof name */
+	char            ch;
+	char           *x;
+
+	errno = error_proto;
+
+	for (;;)
+	{
+		if (!n)
+			break;
+		ch = *buf++;
+		--n;
+		if (ch == '.')
+		{
+			if (labellen)
+			{
+				if (namelen + labellen + 1 > sizeof name)
+					return 0;
+				name[namelen++] = labellen;
+				byte_copy(name + namelen, labellen, label);
+				namelen += labellen;
+				labellen = 0;
+			}
+			continue;
+		}
+		if (ch == '\\')
+		{
+			if (!n)
+				break;
+			ch = *buf++;
+			--n;
+			if ((ch >= '0') && (ch <= '7'))
+			{
+				ch -= '0';
+				if (n && (*buf >= '0') && (*buf <= '7'))
+				{
+					ch <<= 3;
+					ch += *buf - '0';
+					++buf;
+					--n;
+					if (n && (*buf >= '0') && (*buf <= '7'))
+					{
+						ch <<= 3;
+						ch += *buf - '0';
+						++buf;
+						--n;
+					}
+				}
+			}
+		}
+		if (labellen >= sizeof label)
+			return 0;
+		label[labellen++] = ch;
 	}
-      }
-    }
-    if (labellen >= sizeof label) return 0;
-    label[labellen++] = ch;
-  }
-
-  if (labellen) {
-    if (namelen + labellen + 1 > sizeof name) return 0;
-    name[namelen++] = labellen;
-    byte_copy(name + namelen,labellen,label);
-    namelen += labellen;
-    labellen = 0;
-  }
-
-  if (namelen + 1 > sizeof name) return 0;
-  name[namelen++] = 0;
-
-  x = alloc(namelen);
-  if (!x) return 0;
-  byte_copy(x,namelen,name);
-
-  if (*out) alloc_free(*out);
-  *out = x;
-  return 1;
+
+	if (labellen)
+	{
+		if (namelen + labellen + 1 > sizeof name)
+			return 0;
+		name[namelen++] = labellen;
+		byte_copy(name + namelen, labellen, label);
+		namelen += labellen;
+		labellen = 0;
+	}
+
+	if (namelen + 1 > sizeof name)
+		return 0;
+	name[namelen++] = 0;
+
+	x = alloc(namelen);
+	if (!x)
+		return 0;
+	byte_copy(x, namelen, name);
+
+	if (*out)
+		alloc_free(*out);
+	*out = x;
+	return 1;
 }
diff -Naur tmp/ucspi-tcp-0.88/dns_domain.c ucspi-tcp-0.88/dns_domain.c
--- tmp/ucspi-tcp-0.88/dns_domain.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns_domain.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,61 +1,98 @@
+/*
+ * $Log: dns_domain.c,v $
+ * Revision 1.2  2005-06-10 09:04:45+05:30  Cprogrammer
+ * fixed bug with dns_domain_suffix()
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "error.h"
 #include "alloc.h"
 #include "case.h"
 #include "byte.h"
 #include "dns.h"
 
-unsigned int dns_domain_length(char *dn)
+unsigned int
+dns_domain_length(char *dn)
 {
-  char *x;
-  unsigned char c;
+	char           *x;
+	unsigned char   c;
 
-  x = dn;
-  while (c = *x++)
-    x += (unsigned int) c;
-  return x - dn;
+	x = dn;
+	while ((c = *x++))
+		x += (unsigned int) c;
+	return x - dn;
 }
 
-void dns_domain_free(char **out)
+void
+dns_domain_free(char **out)
 {
-  if (*out) {
-    alloc_free(*out);
-    *out = 0;
-  }
+	if (*out)
+	{
+		alloc_free(*out);
+		*out = 0;
+	}
 }
 
-int dns_domain_copy(char **out,char *in)
+int
+dns_domain_copy(char **out, char *in)
 {
-  unsigned int len;
-  char *x;
+	unsigned int    len;
+	char           *x;
 
-  len = dns_domain_length(in);
-  x = alloc(len);
-  if (!x) return 0;
-  byte_copy(x,len,in);
-  if (*out) alloc_free(*out);
-  *out = x;
-  return 1;
+	len = dns_domain_length(in);
+	x = alloc(len);
+	if (!x)
+		return 0;
+	byte_copy(x, len, in);
+	if (*out)
+		alloc_free(*out);
+	*out = x;
+	return 1;
 }
 
-int dns_domain_equal(char *dn1,char *dn2)
+int
+dns_domain_equal(char *dn1, char *dn2)
 {
-  unsigned int len;
+	unsigned int    len;
 
-  len = dns_domain_length(dn1);
-  if (len != dns_domain_length(dn2)) return 0;
+	len = dns_domain_length(dn1);
+	if (len != dns_domain_length(dn2))
+		return 0;
+	if (case_diffb(dn1, len, dn2))
+		return 0;				/*- safe since 63 < 'A' */
+	return 1;
+}
+
+int
+dns_domain_suffix(char *big, char *little)
+{
+	unsigned char   c;
 
-  if (case_diffb(dn1,len,dn2)) return 0; /* safe since 63 < 'A' */
-  return 1;
+	for (;;)
+	{
+		if (dns_domain_equal(big,little))
+			return 1;
+		if (!(c = *big++))
+			return 0;
+		big += c;
+	}
 }
 
-char *dns_domain_suffix(char *big,char *little)
+unsigned int
+dns_domain_suffixpos(char *big, char *little)
 {
-  unsigned char c;
+	char           *orig = big;
+	unsigned char   c;
 
-  for (;;) {
-    if (dns_domain_equal(big,little)) return big;
-    c = *big++;
-    if (!c) return 0;
-    big += c;
-  }
+	for (;;)
+	{
+		if (dns_domain_equal(big,little))
+			return big - orig;
+		c = *big++;
+		if (!c)
+			return 0;
+		big += c;
+	}
 }
diff -Naur tmp/ucspi-tcp-0.88/dns_dtda.c ucspi-tcp-0.88/dns_dtda.c
--- tmp/ucspi-tcp-0.88/dns_dtda.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns_dtda.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,35 +1,51 @@
+/*
+ * $Log: dns_dtda.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "stralloc.h"
 #include "dns.h"
 
-int dns_domain_todot_cat(stralloc *out,char *d)
+int
+dns_domain_todot_cat(stralloc * out, char *d)
 {
-  char ch;
-  char ch2;
-  unsigned char ch3;
-  char buf[4];
+	char            ch;
+	char            ch2;
+	unsigned char   ch3;
+	char            buf[4];
 
-  if (!*d)
-    return stralloc_append(out,".");
+	if (!*d)
+		return stralloc_append(out, ".");
 
-  for (;;) {
-    ch = *d++;
-    while (ch--) {
-      ch2 = *d++;
-      if ((ch2 >= 'A') && (ch2 <= 'Z'))
-	ch2 += 32;
-      if (((ch2 >= 'a') && (ch2 <= 'z')) || ((ch2 >= '0') && (ch2 <= '9')) || (ch2 == '-') || (ch2 == '_')) {
-        if (!stralloc_append(out,&ch2)) return 0;
-      }
-      else {
-	ch3 = ch2;
-	buf[3] = '0' + (ch3 & 7); ch3 >>= 3;
-	buf[2] = '0' + (ch3 & 7); ch3 >>= 3;
-	buf[1] = '0' + (ch3 & 7);
-	buf[0] = '\\';
-	if (!stralloc_catb(out,buf,4)) return 0;
-      }
-    }
-    if (!*d) return 1;
-    if (!stralloc_append(out,".")) return 0;
-  }
+	for (;;)
+	{
+		ch = *d++;
+		while (ch--)
+		{
+			ch2 = *d++;
+			if ((ch2 >= 'A') && (ch2 <= 'Z'))
+				ch2 += 32;
+			if (((ch2 >= 'a') && (ch2 <= 'z')) || ((ch2 >= '0') && (ch2 <= '9')) || (ch2 == '-') || (ch2 == '_'))
+			{
+				if (!stralloc_append(out, &ch2))
+					return 0;
+			} else
+			{
+				ch3 = ch2;
+				buf[3] = '0' + (ch3 & 7);
+				ch3 >>= 3;
+				buf[2] = '0' + (ch3 & 7);
+				ch3 >>= 3;
+				buf[1] = '0' + (ch3 & 7);
+				buf[0] = '\\';
+				if (!stralloc_catb(out, buf, 4))
+					return 0;
+			}
+		}
+		if (!*d)
+			return 1;
+		if (!stralloc_append(out, "."))
+			return 0;
+	}
 }
diff -Naur tmp/ucspi-tcp-0.88/dns.h ucspi-tcp-0.88/dns.h
--- tmp/ucspi-tcp-0.88/dns.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,6 +1,22 @@
+/*
+ * $Log: dns.h,v $
+ * Revision 1.5  2007-06-10 10:13:52+05:30  Cprogrammer
+ * fixed compilation warnings
+ *
+ * Revision 1.4  2005-06-10 11:06:30+05:30  Cprogrammer
+ * removed blank lines
+ *
+ * Revision 1.3  2005-06-10 09:05:09+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef DNS_H
 #define DNS_H
 
+#include "haveip6.h"
 #include "stralloc.h"
 #include "iopause.h"
 #include "taia.h"
@@ -22,63 +38,75 @@
 #define DNS_T_AAAA "\0\34"
 #define DNS_T_AXFR "\0\374"
 #define DNS_T_ANY "\0\377"
-
-struct dns_transmit {
-  char *query; /* 0, or dynamically allocated */
-  unsigned int querylen;
-  char *packet; /* 0, or dynamically allocated */
-  unsigned int packetlen;
-  int s1; /* 0, or 1 + an open file descriptor */
-  int tcpstate;
-  unsigned int udploop;
-  unsigned int curserver;
-  struct taia deadline;
-  unsigned int pos;
-  char *servers;
-  char localip[4];
-  char qtype[2];
-} ;
-
-extern void dns_random_init(char *);
-extern unsigned int dns_random(unsigned int);
-
-extern void dns_sortip(char *,unsigned int);
-
-extern void dns_domain_free(char **);
-extern int dns_domain_copy(char **,char *);
-extern unsigned int dns_domain_length(char *);
-extern int dns_domain_equal(char *,char *);
-extern char *dns_domain_suffix(char *,char *);
-extern int dns_domain_fromdot(char **,char *,unsigned int);
-extern int dns_domain_todot_cat(stralloc *,char *);
-
-extern unsigned int dns_packet_copy(char *,unsigned int,unsigned int,char *,unsigned int);
-extern unsigned int dns_packet_getname(char *,unsigned int,unsigned int,char **);
-extern unsigned int dns_packet_skipname(char *,unsigned int,unsigned int);
-extern int dns_packet_nameequal(char *,unsigned int,unsigned int,char *,unsigned int,unsigned int);
-
-extern int dns_transmit_start(struct dns_transmit *,char *,int,char *,char *,char *);
-extern void dns_transmit_free(struct dns_transmit *);
-extern void dns_transmit_io(struct dns_transmit *,iopause_fd *,struct taia *);
-extern int dns_transmit_get(struct dns_transmit *,iopause_fd *,struct taia *);
-
-extern int dns_resolvconfip(char *);
-extern int dns_resolve(char *,char *);
-extern struct dns_transmit dns_resolve_tx;
-
-extern int dns_ip4_packet(stralloc *,char *,unsigned int);
-extern int dns_ip4(stralloc *,stralloc *);
-extern int dns_name_packet(stralloc *,char *,unsigned int);
-extern void dns_name4_domain(char *,char *);
 #define DNS_NAME4_DOMAIN 31
-extern int dns_name4(stralloc *,char *);
-extern int dns_txt_packet(stralloc *,char *,unsigned int);
-extern int dns_txt(stralloc *,stralloc *);
-extern int dns_mx_packet(stralloc *,char *,unsigned int);
-extern int dns_mx(stralloc *,stralloc *);
-
-extern int dns_resolvconfrewrite(stralloc *);
-extern int dns_ip4_qualify_rules(stralloc *,stralloc *,stralloc *,stralloc *);
-extern int dns_ip4_qualify(stralloc *,stralloc *,stralloc *);
+#ifdef LIBC_HAS_IP6
+#define DNS_NAME6_DOMAIN (4*16+11)
+#endif
 
+struct dns_transmit
+{
+	char           *query;		/*- 0, or dynamically allocated */
+	unsigned int    querylen;
+	char           *packet;		/*- 0, or dynamically allocated */
+	unsigned int    packetlen;
+	int             s1;			/*- 0, or 1 + an open file descriptor */
+	int             tcpstate;
+	unsigned int    udploop;
+	unsigned int    curserver;
+	struct taia     deadline;
+	unsigned int    pos;
+	char           *servers;
+#ifdef LIBC_HAS_IP6
+	char            localip[16];
+	unsigned int    scope_id;
+#else
+	char            localip[4];
+#endif
+	char            qtype[2];
+};
+struct dns_transmit dns_resolve_tx;
+
+void            dns_random_init(char *);
+unsigned int    dns_random(unsigned int);
+void            dns_sortip(char *, unsigned int);
+void            dns_domain_free(char **);
+int             dns_domain_copy(char **, char *);
+unsigned int    dns_domain_length(char *);
+int             dns_domain_equal(char *, char *);
+int             dns_domain_suffix(char *, char *);
+int             dns_domain_fromdot(char **, char *, unsigned int);
+int             dns_domain_todot_cat(stralloc *, char *);
+unsigned int    dns_packet_copy(char *, unsigned int, unsigned int, char *, unsigned int);
+unsigned int    dns_packet_getname(char *, unsigned int, unsigned int, char **);
+unsigned int    dns_packet_skipname(char *, unsigned int, unsigned int);
+int             dns_transmit_start(struct dns_transmit *, char *, int, char *, char *, unsigned char *);
+void            dns_transmit_free(struct dns_transmit *);
+void            dns_transmit_io(struct dns_transmit *, iopause_fd *, struct taia *);
+int             dns_transmit_get(struct dns_transmit *, iopause_fd *, struct taia *);
+int             dns_resolvconfip(char *);
+int             dns_resolve(char *, char *);
+int             dns_ip4_packet(stralloc *, char *, unsigned int);
+int             dns_ip4(stralloc *, stralloc *);
+int             dns_name_packet(stralloc *, char *, unsigned int);
+void            dns_name4_domain(char *, char *);
+int             dns_name4(stralloc *, char *);
+int             dns_txt_packet(stralloc *, char *, unsigned int);
+int             dns_txt(stralloc *, stralloc *);
+int             dns_mx_packet(stralloc *, char *, unsigned int);
+int             dns_mx(stralloc *, stralloc *);
+int             dns_resolvconfrewrite(stralloc *);
+int             dns_ip4_qualify_rules(stralloc *, stralloc *, stralloc *, stralloc *);
+int             dns_ip4_qualify(stralloc *, stralloc *, stralloc *);
+int             dns_packet_nameequal(char *, unsigned int, unsigned int, char *, unsigned int, unsigned int);
+
+#ifdef LIBC_HAS_IP6
+int             dns_name6(stralloc *, char *);
+int             dns_name6_domain(char *, char *);
+void            dns_sortip6(char *, unsigned int);
+unsigned int    dns_domain_suffixpos(char *, char *);
+int             dns_ip6_packet(stralloc *, char *, unsigned int);
+int             dns_ip6(stralloc *, stralloc *);
+int             dns_ip6_qualify_rules(stralloc *, stralloc *, stralloc *, stralloc *);
+int             dns_ip6_qualify(stralloc *, stralloc *, stralloc *);
+#endif
 #endif
diff -Naur tmp/ucspi-tcp-0.88/dns_ip.c ucspi-tcp-0.88/dns_ip.c
--- tmp/ucspi-tcp-0.88/dns_ip.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns_ip.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,75 +1,228 @@
+/*
+ * $Log: dns_ip.c,v $
+ * Revision 1.3  2007-06-10 10:14:25+05:30  Cprogrammer
+ * beautify
+ *
+ * Revision 1.2  2005-06-10 12:08:49+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "stralloc.h"
 #include "uint16.h"
 #include "byte.h"
 #include "dns.h"
+#ifdef IPV6
+#include "ip4.h"
+#include "ip6.h"
 
-int dns_ip4_packet(stralloc *out,char *buf,unsigned int len)
+static int
+dns_ip6_packet_add(stralloc * out, char *buf, unsigned int len)
 {
-  unsigned int pos;
-  char header[12];
-  uint16 numanswers;
-  uint16 datalen;
-
-  if (!stralloc_copys(out,"")) return -1;
-
-  pos = dns_packet_copy(buf,len,0,header,12); if (!pos) return -1;
-  uint16_unpack_big(header + 6,&numanswers);
-  pos = dns_packet_skipname(buf,len,pos); if (!pos) return -1;
-  pos += 4;
-
-  while (numanswers--) {
-    pos = dns_packet_skipname(buf,len,pos); if (!pos) return -1;
-    pos = dns_packet_copy(buf,len,pos,header,10); if (!pos) return -1;
-    uint16_unpack_big(header + 8,&datalen);
-    if (byte_equal(header,2,DNS_T_A))
-      if (byte_equal(header + 2,2,DNS_C_IN))
-        if (datalen == 4) {
-	  if (!dns_packet_copy(buf,len,pos,header,4)) return -1;
-	  if (!stralloc_catb(out,header,4)) return -1;
+	unsigned int    pos;
+	char            header[16];
+	uint16          numanswers;
+	uint16          datalen;
+
+	if (!(pos = dns_packet_copy(buf, len, 0, header, 12)))
+		return -1;
+	uint16_unpack_big(header + 6, &numanswers);
+	if (!(pos = dns_packet_skipname(buf, len, pos)))
+		return -1;
+	pos += 4;
+	while (numanswers--)
+	{
+		if (!(pos = dns_packet_skipname(buf, len, pos)))
+			return -1;
+		if (!(pos = dns_packet_copy(buf, len, pos, header, 10)))
+			return -1;
+		uint16_unpack_big(header + 8, &datalen);
+		if (byte_equal(header, 2, DNS_T_AAAA))
+		{
+			if (byte_equal(header + 2, 2, DNS_C_IN) && datalen == 16)
+			{
+				if (!dns_packet_copy(buf, len, pos, header, 16))
+					return -1;
+				if (!stralloc_catb(out, header, 16))
+					return -1;
+			}
+		} else
+		if (byte_equal(header, 2, DNS_T_A) && byte_equal(header + 2, 2, DNS_C_IN) && datalen == 4)
+		{
+			byte_copy(header, 12, V4mappedprefix);
+			if (!dns_packet_copy(buf, len, pos, header + 12, 4))
+				return -1;
+			if (!stralloc_catb(out, header, 16))
+				return -1;
+		}
+		pos += datalen;
 	}
-    pos += datalen;
-  }
+	dns_sortip6(out->s, out->len);
+	return 0;
+}
 
-  dns_sortip(out->s,out->len);
-  return 0;
+int
+dns_ip6_packet(stralloc *out, char *buf, unsigned int len)
+{
+	if (!stralloc_copys(out, ""))
+		return -1;
+	return dns_ip6_packet_add(out, buf, len);
 }
 
-static char *q = 0;
+static char    *q = 0;
 
-int dns_ip4(stralloc *out,stralloc *fqdn)
+int
+dns_ip6(stralloc *out, stralloc *fqdn)
+{
+	unsigned int    i;
+	char            code;
+	char            ch;
+	char            ip[16];
+
+	if (!stralloc_copys(out, ""))
+		return -1;
+	if (!stralloc_readyplus(fqdn, 1))
+		return -1;
+	fqdn->s[fqdn->len] = 0;
+	if ((i = ip6_scan(fqdn->s, ip)))
+	{
+		if (fqdn->s[i])
+			return -1;
+		stralloc_copyb(out, ip, 16);
+		return 0;
+	}
+	code = 0;
+	for (i = 0; i <= fqdn->len; ++i)
+	{
+		if (i < fqdn->len)
+			ch = fqdn->s[i];
+		else
+			ch = '.';
+		if ((ch == '[') || (ch == ']'))
+			continue;
+		if (ch == '.')
+		{
+			if (!stralloc_append(out, &code))
+				return -1;
+			code = 0;
+			continue;
+		}
+		if ((ch >= '0') && (ch <= '9'))
+		{
+			code *= 10;
+			code += ch - '0';
+			continue;
+		}
+		if (!dns_domain_fromdot(&q, fqdn->s, fqdn->len))
+			return -1;
+		if (!stralloc_copys(out, ""))
+			return -1;
+		if (dns_resolve(q, DNS_T_AAAA) != -1)
+		{
+			if (dns_ip6_packet_add(out, dns_resolve_tx.packet, dns_resolve_tx.packetlen) != -1)
+			{
+				dns_transmit_free(&dns_resolve_tx);
+				dns_domain_free(&q);
+			}
+		}
+		if (!dns_domain_fromdot(&q, fqdn->s, fqdn->len))
+			return -1;
+		if (dns_resolve(q, DNS_T_A) != -1)
+		{
+			if (dns_ip6_packet_add(out, dns_resolve_tx.packet, dns_resolve_tx.packetlen) != -1)
+			{
+				dns_transmit_free(&dns_resolve_tx);
+				dns_domain_free(&q);
+			}
+		}
+		return out->a > 0 ? 0 : -1;
+	}
+	out->len &= ~3;
+	return 0;
+}
+#else
+int
+dns_ip4_packet(stralloc * out, char *buf, unsigned int len)
 {
-  unsigned int i;
-  char code;
-  char ch;
-
-  if (!stralloc_copys(out,"")) return -1;
-  code = 0;
-  for (i = 0;i <= fqdn->len;++i) {
-    if (i < fqdn->len)
-      ch = fqdn->s[i];
-    else
-      ch = '.';
-
-    if ((ch == '[') || (ch == ']')) continue;
-    if (ch == '.') {
-      if (!stralloc_append(out,&code)) return -1;
-      code = 0;
-      continue;
-    }
-    if ((ch >= '0') && (ch <= '9')) {
-      code *= 10;
-      code += ch - '0';
-      continue;
-    }
-
-    if (!dns_domain_fromdot(&q,fqdn->s,fqdn->len)) return -1;
-    if (dns_resolve(q,DNS_T_A) == -1) return -1;
-    if (dns_ip4_packet(out,dns_resolve_tx.packet,dns_resolve_tx.packetlen) == -1) return -1;
-    dns_transmit_free(&dns_resolve_tx);
-    dns_domain_free(&q);
-    return 0;
-  }
+	unsigned int    pos;
+	char            header[12];
+	uint16          numanswers;
+	uint16          datalen;
+
+	if (!stralloc_copys(out, ""))
+		return -1;
+	if (!(pos = dns_packet_copy(buf, len, 0, header, 12)))
+		return -1;
+	uint16_unpack_big(header + 6, &numanswers);
+	if (!(pos = dns_packet_skipname(buf, len, pos)))
+		return -1;
+	pos += 4;
+	while (numanswers--)
+	{
+		if (!(pos = dns_packet_skipname(buf, len, pos)))
+			return -1;
+		if (!(pos = dns_packet_copy(buf, len, pos, header, 10)))
+			return -1;
+		uint16_unpack_big(header + 8, &datalen);
+		if (byte_equal(header, 2, DNS_T_A) && byte_equal(header + 2, 2, DNS_C_IN) && datalen == 4)
+		{
+			if (!dns_packet_copy(buf, len, pos, header, 4))
+				return -1;
+			if (!stralloc_catb(out, header, 4))
+				return -1;
+		}
+		pos += datalen;
+	}
+	dns_sortip(out->s, out->len);
+	return 0;
+}
+
+static char    *q = 0;
 
-  out->len &= ~3;
-  return 0;
+int
+dns_ip4(stralloc *out, stralloc *fqdn)
+{
+	unsigned int    i;
+	char            code;
+	char            ch;
+
+	if (!stralloc_copys(out, ""))
+		return -1;
+	code = 0;
+	for (i = 0; i <= fqdn->len; ++i)
+	{
+		if (i < fqdn->len)
+			ch = fqdn->s[i];
+		else
+			ch = '.';
+		if ((ch == '[') || (ch == ']'))
+			continue;
+		if (ch == '.')
+		{
+			if (!stralloc_append(out, &code))
+				return -1;
+			code = 0;
+			continue;
+		}
+		if ((ch >= '0') && (ch <= '9'))
+		{
+			code *= 10;
+			code += ch - '0';
+			continue;
+		}
+		if (!dns_domain_fromdot(&q, fqdn->s, fqdn->len))
+			return -1;
+		if (dns_resolve(q, DNS_T_A) == -1)
+			return -1;
+		if (dns_ip4_packet(out, dns_resolve_tx.packet, dns_resolve_tx.packetlen) == -1)
+			return -1;
+		dns_transmit_free(&dns_resolve_tx);
+		dns_domain_free(&q);
+		return 0;
+	}
+	out->len &= ~3;
+	return 0;
 }
+#endif
diff -Naur tmp/ucspi-tcp-0.88/dns_ipq.c ucspi-tcp-0.88/dns_ipq.c
--- tmp/ucspi-tcp-0.88/dns_ipq.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns_ipq.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,71 +1,122 @@
+/*
+ * $Log: dns_ipq.c,v $
+ * Revision 1.2  2005-06-10 12:09:01+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "stralloc.h"
 #include "case.h"
 #include "byte.h"
 #include "str.h"
 #include "dns.h"
 
-static int doit(stralloc *work,char *rule)
+static int
+doit(stralloc * work, char *rule)
 {
-  char ch;
-  unsigned int colon;
-  unsigned int prefixlen;
-
-  ch = *rule++;
-  if ((ch != '?') && (ch != '=') && (ch != '*') && (ch != '-')) return 1;
-  colon = str_chr(rule,':');
-  if (!rule[colon]) return 1;
-
-  if (work->len < colon) return 1;
-  prefixlen = work->len - colon;
-  if ((ch == '=') && prefixlen) return 1;
-  if (case_diffb(rule,colon,work->s + prefixlen)) return 1;
-  if (ch == '?') {
-    if (byte_chr(work->s,prefixlen,'.') < prefixlen) return 1;
-    if (byte_chr(work->s,prefixlen,'[') < prefixlen) return 1;
-    if (byte_chr(work->s,prefixlen,']') < prefixlen) return 1;
-  }
-
-  work->len = prefixlen;
-  if (ch == '-') work->len = 0;
-  return stralloc_cats(work,rule + colon + 1);
+	char            ch;
+	unsigned int    colon;
+	unsigned int    prefixlen;
+
+	ch = *rule++;
+	if ((ch != '?') && (ch != '=') && (ch != '*') && (ch != '-'))
+		return 1;
+	colon = str_chr(rule, ':');
+	if (!rule[colon])
+		return 1;
+
+	if (work->len < colon)
+		return 1;
+	prefixlen = work->len - colon;
+	if ((ch == '=') && prefixlen)
+		return 1;
+	if (case_diffb(rule, colon, work->s + prefixlen))
+		return 1;
+	if (ch == '?')
+	{
+		if (byte_chr(work->s, prefixlen, '.') < prefixlen)
+			return 1;
+		if (byte_chr(work->s, prefixlen, ':') < prefixlen)
+			return 1;
+		if (byte_chr(work->s, prefixlen, '[') < prefixlen)
+			return 1;
+		if (byte_chr(work->s, prefixlen, ']') < prefixlen)
+			return 1;
+	}
+
+	work->len = prefixlen;
+	if (ch == '-')
+		work->len = 0;
+	return stralloc_cats(work, rule + colon + 1);
 }
 
-int dns_ip4_qualify_rules(stralloc *out,stralloc *fqdn,stralloc *in,stralloc *rules)
+int
+#ifdef IPV6
+dns_ip6_qualify_rules(stralloc * out, stralloc * fqdn, stralloc *in, stralloc *rules)
+#else
+dns_ip4_qualify_rules(stralloc * out, stralloc * fqdn, stralloc * in, stralloc * rules)
+#endif
 {
-  unsigned int i;
-  unsigned int j;
-  unsigned int plus;
-  unsigned int fqdnlen;
-
-  if (!stralloc_copy(fqdn,in)) return -1;
-
-  for (j = i = 0;j < rules->len;++j)
-    if (!rules->s[j]) {
-      if (!doit(fqdn,rules->s + i)) return -1;
-      i = j + 1;
-    }
-
-  fqdnlen = fqdn->len;
-  plus = byte_chr(fqdn->s,fqdnlen,'+');
-  if (plus >= fqdnlen)
-    return dns_ip4(out,fqdn);
-
-  i = plus + 1;
-  for (;;) {
-    j = byte_chr(fqdn->s + i,fqdnlen - i,'+');
-    byte_copy(fqdn->s + plus,j,fqdn->s + i);
-    fqdn->len = plus + j;
-    if (dns_ip4(out,fqdn) == -1) return -1;
-    if (out->len) return 0;
-    i += j;
-    if (i >= fqdnlen) return 0;
-    ++i;
-  }
+	unsigned int    i;
+	unsigned int    j;
+	unsigned int    plus;
+	unsigned int    fqdnlen;
+
+	if (!stralloc_copy(fqdn, in))
+		return -1;
+	for (j = i = 0; j < rules->len; ++j)
+	{
+		if (!rules->s[j])
+		{
+			if (!doit(fqdn, rules->s + i))
+				return -1;
+			i = j + 1;
+		}
+	}
+	fqdnlen = fqdn->len;
+	plus = byte_chr(fqdn->s, fqdnlen, '+');
+	if (plus >= fqdnlen)
+#ifdef IPV6
+		return dns_ip6(out, fqdn);
+#else
+		return dns_ip4(out, fqdn);
+#endif
+	i = plus + 1;
+	for (;;)
+	{
+		j = byte_chr(fqdn->s + i, fqdnlen - i, '+');
+		byte_copy(fqdn->s + plus, j, fqdn->s + i);
+		fqdn->len = plus + j;
+#ifdef IPV6
+		if (dns_ip6(out, fqdn) == -1)
+#else
+		if (dns_ip4(out, fqdn) == -1)
+#endif
+			return -1;
+		if (out->len)
+			return 0;
+		i += j;
+		if (i >= fqdnlen)
+			return 0;
+		++i;
+	}
 }
 
-int dns_ip4_qualify(stralloc *out,stralloc *fqdn,stralloc *in)
+int
+#ifdef IPV6
+dns_ip6_qualify(stralloc * out, stralloc * fqdn, stralloc *in)
+#else
+dns_ip4_qualify(stralloc * out, stralloc * fqdn, stralloc * in)
+#endif
 {
-  static stralloc rules;
-  if (dns_resolvconfrewrite(&rules) == -1) return -1;
-  return dns_ip4_qualify_rules(out,fqdn,in,&rules);
+	static stralloc rules;
+	if (dns_resolvconfrewrite(&rules) == -1)
+		return -1;
+#ifdef IPV6
+	return dns_ip6_qualify_rules(out, fqdn, in, &rules);
+#else
+	return dns_ip4_qualify_rules(out, fqdn, in, &rules);
+#endif
 }
diff -Naur tmp/ucspi-tcp-0.88/dns_name.c ucspi-tcp-0.88/dns_name.c
--- tmp/ucspi-tcp-0.88/dns_name.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns_name.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,48 +1,95 @@
+/*
+ * $Log: dns_name.c,v $
+ * Revision 1.2  2005-06-10 12:09:40+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "stralloc.h"
 #include "uint16.h"
 #include "byte.h"
 #include "dns.h"
+#ifdef IPV6
+#include "ip6.h"
+#endif
 
-static char *q = 0;
+static char    *q = 0;
 
-int dns_name_packet(stralloc *out,char *buf,unsigned int len)
+int
+dns_name_packet(stralloc *out, char *buf, unsigned int len)
 {
-  unsigned int pos;
-  char header[12];
-  uint16 numanswers;
-  uint16 datalen;
-
-  if (!stralloc_copys(out,"")) return -1;
-
-  pos = dns_packet_copy(buf,len,0,header,12); if (!pos) return -1;
-  uint16_unpack_big(header + 6,&numanswers);
-  pos = dns_packet_skipname(buf,len,pos); if (!pos) return -1;
-  pos += 4;
-
-  while (numanswers--) {
-    pos = dns_packet_skipname(buf,len,pos); if (!pos) return -1;
-    pos = dns_packet_copy(buf,len,pos,header,10); if (!pos) return -1;
-    uint16_unpack_big(header + 8,&datalen);
-    if (byte_equal(header,2,DNS_T_PTR))
-      if (byte_equal(header + 2,2,DNS_C_IN)) {
-	if (!dns_packet_getname(buf,len,pos,&q)) return -1;
-	if (!dns_domain_todot_cat(out,q)) return -1;
+	unsigned int    pos;
+	char            header[12];
+	uint16          numanswers;
+	uint16          datalen;
+
+	if (!stralloc_copys(out, ""))
+		return -1;
+	pos = dns_packet_copy(buf, len, 0, header, 12);
+	if (!pos)
+		return -1;
+	uint16_unpack_big(header + 6, &numanswers);
+	pos = dns_packet_skipname(buf, len, pos);
+	if (!pos)
+		return -1;
+	pos += 4;
+	while (numanswers--)
+	{
+		pos = dns_packet_skipname(buf, len, pos);
+		if (!pos)
+			return -1;
+		pos = dns_packet_copy(buf, len, pos, header, 10);
+		if (!pos)
+			return -1;
+		uint16_unpack_big(header + 8, &datalen);
+		if (byte_equal(header, 2, DNS_T_PTR))
+		{
+			if (byte_equal(header + 2, 2, DNS_C_IN))
+			{
+				if (!dns_packet_getname(buf, len, pos, &q))
+					return -1;
+				if (!dns_domain_todot_cat(out, q))
+					return -1;
+				return 0;
+			}
+		}
+		pos += datalen;
+	}
 	return 0;
-      }
-    pos += datalen;
-  }
+}
+
+int
+dns_name4(stralloc *out, char ip[4])
+{
+	char            name[DNS_NAME4_DOMAIN];
 
-  return 0;
+	dns_name4_domain(name, ip);
+	if (dns_resolve(name, DNS_T_PTR) == -1)
+		return -1;
+	if (dns_name_packet(out, dns_resolve_tx.packet, dns_resolve_tx.packetlen) == -1)
+		return -1;
+	dns_transmit_free(&dns_resolve_tx);
+	dns_domain_free(&q);
+	return 0;
 }
 
-int dns_name4(stralloc *out,char ip[4])
+#ifdef IPV6
+int
+dns_name6(stralloc *out, char ip[16])
 {
-  char name[DNS_NAME4_DOMAIN];
+	char            name[DNS_NAME6_DOMAIN];
 
-  dns_name4_domain(name,ip);
-  if (dns_resolve(name,DNS_T_PTR) == -1) return -1;
-  if (dns_name_packet(out,dns_resolve_tx.packet,dns_resolve_tx.packetlen) == -1) return -1;
-  dns_transmit_free(&dns_resolve_tx);
-  dns_domain_free(&q);
-  return 0;
+	if (ip6_isv4mapped(ip))
+		return dns_name4(out, ip + 12);
+	dns_name6_domain(name,ip);
+	if (dns_resolve(name, DNS_T_PTR) == -1)
+		return -1;
+	if (dns_name_packet(out, dns_resolve_tx.packet, dns_resolve_tx.packetlen) == -1)
+		return -1;
+	dns_transmit_free(&dns_resolve_tx);
+	dns_domain_free(&q);
+	return 0;
 }
+#endif
diff -Naur tmp/ucspi-tcp-0.88/dns_nd.c ucspi-tcp-0.88/dns_nd.c
--- tmp/ucspi-tcp-0.88/dns_nd.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns_nd.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,24 +1,63 @@
+/*
+ * $Log: dns_nd.c,v $
+ * Revision 1.2  2005-06-10 12:09:56+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "byte.h"
 #include "fmt.h"
 #include "dns.h"
+#ifdef IPV6
+/*
+ * RFC1886:
+ * *   4321:0:1:2:3:4:567:89ab
+ * * ->
+ * *   b.a.9.8.7.6.5.0.4.0.0.0.3.0.0.0.2.0.0.0.1.0.0.0.0.0.0.0.1.2.3.4.IP6.INT.
+ */
 
-void dns_name4_domain(char name[DNS_NAME4_DOMAIN],char ip[4])
+static inline char
+tohex(char c)
 {
-  unsigned int namelen;
-  unsigned int i;
+	return c >= 10 ? c - 10 + 'a' : c + '0';
+}
+
+int
+dns_name6_domain(char name[DNS_NAME6_DOMAIN], char ip[16])
+{
+	unsigned int    j;
+
+	for (j = 0; j < 16; j++)
+	{
+		name[j * 4] = 1;
+		name[j * 4 + 1] = tohex(ip[15 - j] & 15);
+		name[j * 4 + 2] = 1;
+		name[j * 4 + 3] = tohex((unsigned char) ip[15 - j] >> 4);
+	}
+	byte_copy(name + 4 * 16, 10, "\3ip6\4arpa\0");
+	return 4 * 16 + 10;
+}
+#endif
+void
+dns_name4_domain(char name[DNS_NAME4_DOMAIN], char ip[4])
+{
+	unsigned int    namelen;
+	unsigned int    i;
 
-  namelen = 0;
-  i = fmt_ulong(name + namelen + 1,(unsigned long) (unsigned char) ip[3]);
-  name[namelen++] = i;
-  namelen += i;
-  i = fmt_ulong(name + namelen + 1,(unsigned long) (unsigned char) ip[2]);
-  name[namelen++] = i;
-  namelen += i;
-  i = fmt_ulong(name + namelen + 1,(unsigned long) (unsigned char) ip[1]);
-  name[namelen++] = i;
-  namelen += i;
-  i = fmt_ulong(name + namelen + 1,(unsigned long) (unsigned char) ip[0]);
-  name[namelen++] = i;
-  namelen += i;
-  byte_copy(name + namelen,14,"\7in-addr\4arpa\0");
+	namelen = 0;
+	i = fmt_ulong(name + namelen + 1, (unsigned long) (unsigned char) ip[3]);
+	name[namelen++] = i;
+	namelen += i;
+	i = fmt_ulong(name + namelen + 1, (unsigned long) (unsigned char) ip[2]);
+	name[namelen++] = i;
+	namelen += i;
+	i = fmt_ulong(name + namelen + 1, (unsigned long) (unsigned char) ip[1]);
+	name[namelen++] = i;
+	namelen += i;
+	i = fmt_ulong(name + namelen + 1, (unsigned long) (unsigned char) ip[0]);
+	name[namelen++] = i;
+	namelen += i;
+	byte_copy(name + namelen, 14, "\7in-addr\4arpa\0");
 }
diff -Naur tmp/ucspi-tcp-0.88/dns_packet.c ucspi-tcp-0.88/dns_packet.c
--- tmp/ucspi-tcp-0.88/dns_packet.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns_packet.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,77 +1,118 @@
 /*
-DNS should have used LZ77 instead of its own sophomoric compression algorithm.
-*/
+ * $Log: dns_packet.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ * DNS should have used LZ77 instead of its own sophomoric compression algorithm.
+ */
 
 #include "error.h"
 #include "dns.h"
 
-unsigned int dns_packet_copy(char *buf,unsigned int len,unsigned int pos,char *out,unsigned int outlen)
+unsigned int
+dns_packet_copy(char *buf, unsigned int len, unsigned int pos, char *out, unsigned int outlen)
 {
-  while (outlen) {
-    if (pos >= len) { errno = error_proto; return 0; }
-    *out = buf[pos++];
-    ++out; --outlen;
-  }
-  return pos;
+	while (outlen)
+	{
+		if (pos >= len)
+		{
+			errno = error_proto;
+			return 0;
+		}
+		*out = buf[pos++];
+		++out;
+		--outlen;
+	}
+	return pos;
 }
 
-unsigned int dns_packet_skipname(char *buf,unsigned int len,unsigned int pos)
+unsigned int
+dns_packet_skipname(char *buf, unsigned int len, unsigned int pos)
 {
-  unsigned char ch;
+	unsigned char   ch;
 
-  for (;;) {
-    if (pos >= len) break;
-    ch = buf[pos++];
-    if (ch >= 192) return pos + 1;
-    if (ch >= 64) break;
-    if (!ch) return pos;
-    pos += ch;
-  }
+	for (;;)
+	{
+		if (pos >= len)
+			break;
+		ch = buf[pos++];
+		if (ch >= 192)
+			return pos + 1;
+		if (ch >= 64)
+			break;
+		if (!ch)
+			return pos;
+		pos += ch;
+	}
 
-  errno = error_proto;
-  return 0;
+	errno = error_proto;
+	return 0;
 }
 
-unsigned int dns_packet_getname(char *buf,unsigned int len,unsigned int pos,char **d)
+unsigned int
+dns_packet_getname(char *buf, unsigned int len, unsigned int pos, char **d)
 {
-  unsigned int loop = 0;
-  unsigned int state = 0;
-  unsigned int firstcompress = 0;
-  unsigned int where;
-  unsigned char ch;
-  char name[255];
-  unsigned int namelen = 0;
-
-  for (;;) {
-    if (pos >= len) goto PROTO; ch = buf[pos++];
-    if (++loop >= 1000) goto PROTO;
-
-    if (state) {
-      if (namelen + 1 > sizeof name) goto PROTO; name[namelen++] = ch;
-      --state;
-    }
-    else {
-      while (ch >= 192) {
-	where = ch; where -= 192; where <<= 8;
-	if (pos >= len) goto PROTO; ch = buf[pos++];
-	if (!firstcompress) firstcompress = pos;
-	pos = where + ch;
-	if (pos >= len) goto PROTO; ch = buf[pos++];
-	if (++loop >= 1000) goto PROTO;
-      }
-      if (ch >= 64) goto PROTO;
-      if (namelen + 1 > sizeof name) goto PROTO; name[namelen++] = ch;
-      if (!ch) break;
-      state = ch;
-    }
-  }
-
-  if (!dns_domain_copy(d,name)) return 0;
-
-  if (firstcompress) return firstcompress;
-  return pos;
+	unsigned int    loop = 0;
+	unsigned int    state = 0;
+	unsigned int    firstcompress = 0;
+	unsigned int    where;
+	unsigned char   ch;
+	char            name[255];
+	unsigned int    namelen = 0;
+
+	for (;;)
+	{
+		if (pos >= len)
+			goto PROTO;
+		ch = buf[pos++];
+		if (++loop >= 1000)
+			goto PROTO;
+
+		if (state)
+		{
+			if (namelen + 1 > sizeof name)
+				goto PROTO;
+			name[namelen++] = ch;
+			--state;
+		} else
+		{
+			while (ch >= 192)
+			{
+				where = ch;
+				where -= 192;
+				where <<= 8;
+				if (pos >= len)
+					goto PROTO;
+				ch = buf[pos++];
+				if (!firstcompress)
+					firstcompress = pos;
+				pos = where + ch;
+				if (pos >= len)
+					goto PROTO;
+				ch = buf[pos++];
+				if (++loop >= 1000)
+					goto PROTO;
+			}
+			if (ch >= 64)
+				goto PROTO;
+			if (namelen + 1 > sizeof name)
+				goto PROTO;
+			name[namelen++] = ch;
+			if (!ch)
+				break;
+			state = ch;
+		}
+	}
+
+	if (!dns_domain_copy(d, name))
+		return 0;
+
+	if (firstcompress)
+		return firstcompress;
+	return pos;
 
   PROTO:
-  errno = error_proto;
-  return 0;
+	errno = error_proto;
+	return 0;
 }
diff -Naur tmp/ucspi-tcp-0.88/dns_random.c ucspi-tcp-0.88/dns_random.c
--- tmp/ucspi-tcp-0.88/dns_random.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns_random.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,62 +1,93 @@
+/*
+ * $Log: dns_random.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "dns.h"
 #include "taia.h"
 #include "uint32.h"
+#include <unistd.h>
 
-static uint32 seed[32];
-static uint32 in[12];
-static uint32 out[8];
-static int outleft = 0;
+static uint32   seed[32];
+static uint32   in[12];
+static uint32   out[8];
+static int      outleft = 0;
 
 #define ROTATE(x,b) (((x) << (b)) | ((x) >> (32 - (b))))
 #define MUSH(i,b) x = t[i] += (((x ^ seed[i]) + sum) ^ ROTATE(x,b));
 
-static void surf(void)
+static void
+surf(void)
 {
-  uint32 t[12]; uint32 x; uint32 sum = 0;
-  int r; int i; int loop;
-
-  for (i = 0;i < 12;++i) t[i] = in[i] ^ seed[12 + i];
-  for (i = 0;i < 8;++i) out[i] = seed[24 + i];
-  x = t[11];
-  for (loop = 0;loop < 2;++loop) {
-    for (r = 0;r < 16;++r) {
-      sum += 0x9e3779b9;
-      MUSH(0,5) MUSH(1,7) MUSH(2,9) MUSH(3,13)
-      MUSH(4,5) MUSH(5,7) MUSH(6,9) MUSH(7,13)
-      MUSH(8,5) MUSH(9,7) MUSH(10,9) MUSH(11,13)
-    }
-    for (i = 0;i < 8;++i) out[i] ^= t[i + 4];
-  }
+	uint32          t[12];
+	uint32          x;
+	uint32          sum = 0;
+	int             r;
+	int             i;
+	int             loop;
+
+	for (i = 0; i < 12; ++i)
+		t[i] = in[i] ^ seed[12 + i];
+	for (i = 0; i < 8; ++i)
+		out[i] = seed[24 + i];
+	x = t[11];
+	for (loop = 0; loop < 2; ++loop)
+	{
+		for (r = 0; r < 16; ++r)
+		{
+			sum += 0x9e3779b9;
+			MUSH(0, 5)
+			MUSH(1, 7)
+			MUSH(2, 9)
+			MUSH(3, 13)
+			MUSH(4, 5)
+			MUSH(5, 7)
+			MUSH(6, 9)
+			MUSH(7, 13)
+			MUSH(8, 5)
+			MUSH(9, 7)
+			MUSH(10,9)
+			MUSH(11, 13)
+		}
+		for (i = 0; i < 8; ++i)
+			out[i] ^= t[i + 4];
+	}
 }
 
-void dns_random_init(char data[128])
+void
+dns_random_init(char data[128])
 {
-  int i;
-  struct taia t;
-  char tpack[16];
-
-  for (i = 0;i < 32;++i)
-    uint32_unpack(data + 4 * i,seed + i);
-
-  taia_now(&t);
-  taia_pack(tpack,&t);
-  for (i = 0;i < 4;++i)
-    uint32_unpack(tpack + 4 * i,in + 4 + i);
-
-  in[8] = getpid();
-  in[9] = getppid();
-  /* more space in 10 and 11, but this is probably enough */
+	int             i;
+	struct taia     t;
+	char            tpack[16];
+
+	for (i = 0; i < 32; ++i)
+		uint32_unpack(data + 4 * i, seed + i);
+
+	taia_now(&t);
+	taia_pack(tpack, &t);
+	for (i = 0; i < 4; ++i)
+		uint32_unpack(tpack + 4 * i, in + 4 + i);
+
+	in[8] = getpid();
+	in[9] = getppid();
+	/*- more space in 10 and 11, but this is probably enough */
 }
 
-unsigned int dns_random(unsigned int n)
+unsigned int
+dns_random(unsigned int n)
 {
-  if (!n) return 0;
+	if (!n)
+		return 0;
 
-  if (!outleft) {
-    if (!++in[0]) if (!++in[1]) if (!++in[2]) ++in[3];
-    surf();
-    outleft = 8;
-  }
+	if (!outleft)
+	{
+		if (!++in[0] && !++in[1] && !++in[2])
+			++in[3];
+		surf();
+		outleft = 8;
+	}
 
-  return out[--outleft] % n;
+	return out[--outleft] % n;
 }
diff -Naur tmp/ucspi-tcp-0.88/dns_rcip.c ucspi-tcp-0.88/dns_rcip.c
--- tmp/ucspi-tcp-0.88/dns_rcip.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns_rcip.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,82 +1,148 @@
+/*
+ * $Log: dns_rcip.c,v $
+ * Revision 1.2  2005-06-10 09:05:46+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "taia.h"
 #include "openreadclose.h"
 #include "byte.h"
 #include "ip4.h"
+#ifdef IPV6
+#include "ip6.h"
+#endif
 #include "env.h"
 #include "dns.h"
 
-static stralloc data = {0};
+static stralloc data = { 0 };
 
-static int init(char ip[64])
+static int
+#ifdef IPV6
+init(char ip[256])
+#else
+init(char ip[64])
+#endif
 {
-  int i;
-  int j;
-  int iplen = 0;
-  char *x;
-
-  x = env_get("DNSCACHEIP");
-  if (x)
-    while (iplen <= 60)
-      if (*x == '.')
-	++x;
-      else {
-        i = ip4_scan(x,ip + iplen);
-	if (!i) break;
-	x += i;
-	iplen += 4;
-      }
-
-  if (!iplen) {
-    i = openreadclose("/etc/resolv.conf",&data,64);
-    if (i == -1) return -1;
-    if (i) {
-      if (!stralloc_append(&data,"\n")) return -1;
-      i = 0;
-      for (j = 0;j < data.len;++j)
-        if (data.s[j] == '\n') {
-          if (byte_equal("nameserver ",11,data.s + i) || byte_equal("nameserver\t",11,data.s + i)) {
-            i += 10;
-            while ((data.s[i] == ' ') || (data.s[i] == '\t'))
-              ++i;
-            if (iplen <= 60)
-              if (ip4_scan(data.s + i,ip + iplen))
-                iplen += 4;
-          }
-          i = j + 1;
-        }
-    }
-  }
-
-  if (!iplen) {
-    byte_copy(ip,4,"\177\0\0\1");
-    iplen = 4;
-  }
-  byte_zero(ip + iplen,64 - iplen);
-  return 0;
+	int             i;
+	int             j;
+	int             iplen = 0;
+	char           *x;
+
+	if ((x = env_get("DNSCACHEIP")))
+	{
+		while (iplen <= 60)
+		{
+			if (*x == '.')
+				++x;
+			else
+			{
+#ifdef IPV6
+				i = ip6_scan(x,ip + iplen);
+#else
+				i = ip4_scan(x, ip + iplen);
+#endif
+				if (!i)
+					break;
+				x += i;
+#ifdef IPV6
+				iplen += 16;
+#else
+				iplen += 4;
+#endif
+			}
+		}
+	}
+	if (!iplen)
+	{
+		if ((i = openreadclose("/etc/resolv.conf", &data, 64)) == -1)
+			return -1;
+		if (i)
+		{
+			if (!stralloc_append(&data, "\n"))
+				return -1;
+			i = 0;
+			for (j = 0; j < data.len; ++j)
+			{
+				if (data.s[j] == '\n')
+				{
+					if (byte_equal("nameserver ", 11, data.s + i) || byte_equal("nameserver\t", 11, data.s + i))
+					{
+						i += 10;
+						while ((data.s[i] == ' ') || (data.s[i] == '\t'))
+							++i;
+#ifdef IPV6
+						if (iplen <= 60 && ip6_scan(data.s + i,ip + iplen))
+							iplen += 16;
+#else
+						if (iplen <= 60 && ip4_scan(data.s + i, ip + iplen))
+							iplen += 4;
+#endif
+					}
+					i = j + 1;
+				}
+			}
+		}
+	}
+	if (!iplen)
+	{
+#ifdef IPV6
+		byte_copy(ip, 16, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1");
+		iplen = 16;
+#else
+		byte_copy(ip, 4, "\177\0\0\1");
+		iplen = 4;
+#endif
+	}
+#ifdef IPV6
+	byte_zero(ip + iplen, 256 - iplen);
+#else
+	byte_zero(ip + iplen, 64 - iplen);
+#endif
+	return 0;
 }
 
-static int ok = 0;
+static int      ok = 0;
 static unsigned int uses;
 static struct taia deadline;
-static char ip[64]; /* defined if ok */
-
-int dns_resolvconfip(char s[64])
+#ifdef IPV6
+static char     ip[256]; /* defined if ok */
+#else
+static char     ip[64]; /*- defined if ok */
+#endif
+
+int
+#ifdef IPV6
+dns_resolvconfip(char s[256])
+#else
+dns_resolvconfip(char s[64])
+#endif
 {
-  struct taia now;
+	struct taia     now;
 
-  taia_now(&now);
-  if (taia_less(&deadline,&now)) ok = 0;
-  if (!uses) ok = 0;
-
-  if (!ok) {
-    if (init(ip) == -1) return -1;
-    taia_uint(&deadline,600);
-    taia_add(&deadline,&now,&deadline);
-    uses = 10000;
-    ok = 1;
-  }
-
-  --uses;
-  byte_copy(s,64,ip);
-  return 0;
+	taia_now(&now);
+	if (taia_less(&deadline, &now))
+		ok = 0;
+	if (!uses)
+		ok = 0;
+
+	if (!ok)
+	{
+		if (init(ip) == -1)
+			return -1;
+		taia_uint(&deadline, 600);
+		taia_add(&deadline, &now, &deadline);
+		uses = 10000;
+		ok = 1;
+	}
+
+	--uses;
+#ifdef IPV6
+	byte_copy(s, 256, ip);
+#else
+	byte_copy(s, 64, ip);
+#endif
+	return 0;
 }
diff -Naur tmp/ucspi-tcp-0.88/dns_rcrw.c ucspi-tcp-0.88/dns_rcrw.c
--- tmp/ucspi-tcp-0.88/dns_rcrw.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns_rcrw.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,130 +1,180 @@
+/*
+ * $Log: dns_rcrw.c,v $
+ * Revision 1.2  2005-06-10 09:12:13+05:30  Cprogrammer
+ * code beautified
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "taia.h"
 #include "env.h"
 #include "byte.h"
 #include "str.h"
 #include "openreadclose.h"
 #include "dns.h"
+#include <unistd.h>
 
-static stralloc data = {0};
+static stralloc data = { 0 };
 
-static int init(stralloc *rules)
+static int
+init(stralloc * rules)
 {
-  char host[256];
-  char *x;
-  int i;
-  int j;
-  int k;
-
-  if (!stralloc_copys(rules,"")) return -1;
-
-  x = env_get("DNSREWRITEFILE");
-  if (!x) x = "/etc/dnsrewrite";
-
-  i = openreadclose(x,&data,64);
-  if (i == -1) return -1;
-
-  if (i) {
-    if (!stralloc_append(&data,"\n")) return -1;
-    i = 0;
-    for (j = 0;j < data.len;++j)
-      if (data.s[j] == '\n') {
-        if (!stralloc_catb(rules,data.s + i,j - i)) return -1;
-        while (rules->len) {
-          if (rules->s[rules->len - 1] != ' ')
-          if (rules->s[rules->len - 1] != '\t')
-          if (rules->s[rules->len - 1] != '\r')
-            break;
-          --rules->len;
-        }
-        if (!stralloc_0(rules)) return -1;
-        i = j + 1;
-      }
-    return 0;
-  }
-
-  x = env_get("LOCALDOMAIN");
-  if (x) {
-    if (!stralloc_copys(&data,x)) return -1;
-    if (!stralloc_append(&data," ")) return -1;
-    if (!stralloc_copys(rules,"?:")) return -1;
-    i = 0;
-    for (j = 0;j < data.len;++j)
-      if (data.s[j] == ' ') {
-        if (!stralloc_cats(rules,"+.")) return -1;
-        if (!stralloc_catb(rules,data.s + i,j - i)) return -1;
-        i = j + 1;
-      }
-    if (!stralloc_0(rules)) return -1;
-    if (!stralloc_cats(rules,"*.:")) return -1;
-    if (!stralloc_0(rules)) return -1;
-    return 0;
-  }
-
-  i = openreadclose("/etc/resolv.conf",&data,64);
-  if (i == -1) return -1;
-
-  if (i) {
-    if (!stralloc_append(&data,"\n")) return -1;
-    i = 0;
-    for (j = 0;j < data.len;++j)
-      if (data.s[j] == '\n') {
-        if (byte_equal("search ",7,data.s + i) || byte_equal("search\t",7,data.s + i) || byte_equal("domain ",7,data.s + i) || byte_equal("domain\t",7,data.s + i)) {
-          if (!stralloc_copys(rules,"?:")) return -1;
-          i += 7;
-          while (i < j) {
-            k = byte_chr(data.s + i,j - i,' ');
-            k = byte_chr(data.s + i,k,'\t');
-            if (!k) { ++i; continue; }
-            if (!stralloc_cats(rules,"+.")) return -1;
-            if (!stralloc_catb(rules,data.s + i,k)) return -1;
-            i += k;
-          }
-          if (!stralloc_0(rules)) return -1;
-          if (!stralloc_cats(rules,"*.:")) return -1;
-          if (!stralloc_0(rules)) return -1;
-          return 0;
-        }
-        i = j + 1;
-      }
-  }
-
-  host[0] = 0;
-  if (gethostname(host,sizeof host) == -1) return -1;
-  host[(sizeof host) - 1] = 0;
-  i = str_chr(host,'.');
-  if (host[i]) {
-    if (!stralloc_copys(rules,"?:")) return -1;
-    if (!stralloc_cats(rules,host + i)) return -1;
-    if (!stralloc_0(rules)) return -1;
-  }
-  if (!stralloc_cats(rules,"*.:")) return -1;
-  if (!stralloc_0(rules)) return -1;
-
-  return 0;
+	char            host[256];
+	char           *x;
+	int             i;
+	int             j;
+	int             k;
+
+	if (!stralloc_copys(rules, ""))
+		return -1;
+	if (!(x = env_get("DNSREWRITEFILE")))
+		x = "/etc/dnsrewrite";
+	if ((i = openreadclose(x, &data, 64)) == -1)
+		return -1;
+	if (i)
+	{
+		if (!stralloc_append(&data, "\n"))
+			return -1;
+		i = 0;
+		for (j = 0; j < data.len; ++j)
+		{
+			if (data.s[j] == '\n')
+			{
+				if (!stralloc_catb(rules, data.s + i, j - i))
+					return -1;
+				while (rules->len)
+				{
+					if (rules->s[rules->len - 1] != ' ' && rules->s[rules->len - 1] != '\t' && rules->s[rules->len - 1] != '\r')
+						break;
+					--rules->len;
+				}
+				if (!stralloc_0(rules))
+					return -1;
+				i = j + 1;
+			}
+		}
+		return 0;
+	}
+	if ((x = env_get("LOCALDOMAIN")))
+	{
+		if (!stralloc_copys(&data, x))
+			return -1;
+		if (!stralloc_append(&data, " "))
+			return -1;
+		if (!stralloc_copys(rules, "?:"))
+			return -1;
+		i = 0;
+		for (j = 0; j < data.len; ++j)
+		{
+			if (data.s[j] == ' ')
+			{
+				if (!stralloc_cats(rules, "+."))
+					return -1;
+				if (!stralloc_catb(rules, data.s + i, j - i))
+					return -1;
+				i = j + 1;
+			}
+		}
+		if (!stralloc_0(rules))
+			return -1;
+		if (!stralloc_cats(rules, "*.:"))
+			return -1;
+		if (!stralloc_0(rules))
+			return -1;
+		return 0;
+	}
+	if ((i = openreadclose("/etc/resolv.conf", &data, 64)) == -1)
+		return -1;
+	if (i)
+	{
+		if (!stralloc_append(&data, "\n"))
+			return -1;
+		i = 0;
+		for (j = 0; j < data.len; ++j)
+		{
+			if (data.s[j] == '\n')
+			{
+				if (byte_equal("search ", 7, data.s + i) || byte_equal("search\t", 7, data.s + i) ||
+					byte_equal("domain ", 7, data.s + i) || byte_equal("domain\t", 7, data.s + i))
+				{
+					if (!stralloc_copys(rules, "?:"))
+						return -1;
+					i += 7;
+					while (i < j)
+					{
+						k = byte_chr(data.s + i, j - i, ' ');
+						k = byte_chr(data.s + i, k, '\t');
+						if (!k)
+						{
+							++i;
+							continue;
+						}
+						if (!stralloc_cats(rules, "+."))
+							return -1;
+						if (!stralloc_catb(rules, data.s + i, k))
+							return -1;
+						i += k;
+					}
+					if (!stralloc_0(rules))
+						return -1;
+					if (!stralloc_cats(rules, "*.:"))
+						return -1;
+					if (!stralloc_0(rules))
+						return -1;
+					return 0;
+				}
+				i = j + 1;
+			}
+		}
+	}
+	host[0] = 0;
+	if (gethostname(host, sizeof host) == -1)
+		return -1;
+	host[(sizeof host) - 1] = 0;
+	i = str_chr(host, '.');
+	if (host[i])
+	{
+		if (!stralloc_copys(rules, "?:"))
+			return -1;
+		if (!stralloc_cats(rules, host + i))
+			return -1;
+		if (!stralloc_0(rules))
+			return -1;
+	}
+	if (!stralloc_cats(rules, "*.:"))
+		return -1;
+	if (!stralloc_0(rules))
+		return -1;
+	return 0;
 }
 
-static int ok = 0;
+static int      ok = 0;
 static unsigned int uses;
 static struct taia deadline;
-static stralloc rules = {0}; /* defined if ok */
+static stralloc rules = { 0 };	/*- defined if ok */
 
-int dns_resolvconfrewrite(stralloc *out)
+int
+dns_resolvconfrewrite(stralloc * out)
 {
-  struct taia now;
+	struct taia     now;
 
-  taia_now(&now);
-  if (taia_less(&deadline,&now)) ok = 0;
-  if (!uses) ok = 0;
-
-  if (!ok) {
-    if (init(&rules) == -1) return -1;
-    taia_uint(&deadline,600);
-    taia_add(&deadline,&now,&deadline);
-    uses = 10000;
-    ok = 1;
-  }
-
-  --uses;
-  if (!stralloc_copy(out,&rules)) return -1;
-  return 0;
+	taia_now(&now);
+	if (taia_less(&deadline, &now))
+		ok = 0;
+	if (!uses)
+		ok = 0;
+	if (!ok)
+	{
+		if (init(&rules) == -1)
+			return -1;
+		taia_uint(&deadline, 600);
+		taia_add(&deadline, &now, &deadline);
+		uses = 10000;
+		ok = 1;
+	}
+	--uses;
+	if (!stralloc_copy(out, &rules))
+		return -1;
+	return 0;
 }
diff -Naur tmp/ucspi-tcp-0.88/dns_resolve.c ucspi-tcp-0.88/dns_resolve.c
--- tmp/ucspi-tcp-0.88/dns_resolve.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns_resolve.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,29 +1,54 @@
+/*
+ * $Log: dns_resolve.c,v $
+ * Revision 1.2  2005-06-10 09:12:27+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "iopause.h"
 #include "taia.h"
 #include "byte.h"
+#ifdef IPV6
+#include "ip6.h"
+#endif
 #include "dns.h"
 
-struct dns_transmit dns_resolve_tx = {0};
+struct dns_transmit dns_resolve_tx = { 0 };
 
-int dns_resolve(char *q,char qtype[2])
+int
+dns_resolve(char *q, char qtype[2])
 {
-  struct taia stamp;
-  struct taia deadline;
-  char servers[64];
-  iopause_fd x[1];
-  int r;
+	struct taia     stamp;
+	struct taia     deadline;
+#ifdef IPV6
+	char            servers[256];
+#else
+	char            servers[64];
+#endif
+	iopause_fd      x[1];
+	int             r;
 
-  if (dns_resolvconfip(servers) == -1) return -1;
-  if (dns_transmit_start(&dns_resolve_tx,servers,1,q,qtype,"\0\0\0\0") == -1) return -1;
-
-  for (;;) {
-    taia_now(&stamp);
-    taia_uint(&deadline,120);
-    taia_add(&deadline,&deadline,&stamp);
-    dns_transmit_io(&dns_resolve_tx,x,&deadline);
-    iopause(x,1,&deadline,&stamp);
-    r = dns_transmit_get(&dns_resolve_tx,x,&stamp);
-    if (r == -1) return -1;
-    if (r == 1) return 0;
-  }
+	if (dns_resolvconfip(servers) == -1)
+		return -1;
+#ifdef IPV6
+	if (dns_transmit_start(&dns_resolve_tx, servers, 1, q, qtype, V6any) == -1)
+#else
+	if (dns_transmit_start(&dns_resolve_tx, servers, 1, q, qtype, "\0\0\0\0") == -1)
+#endif
+		return -1;
+	for (;;)
+	{
+		taia_now(&stamp);
+		taia_uint(&deadline, 120);
+		taia_add(&deadline, &deadline, &stamp);
+		dns_transmit_io(&dns_resolve_tx, x, &deadline);
+		iopause(x, 1, &deadline, &stamp);
+		if((r = dns_transmit_get(&dns_resolve_tx, x, &stamp)) == -1)
+			return -1;
+		else
+		if (r == 1)
+			return 0;
+	}
 }
diff -Naur tmp/ucspi-tcp-0.88/dns_sortip.c ucspi-tcp-0.88/dns_sortip.c
--- tmp/ucspi-tcp-0.88/dns_sortip.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns_sortip.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,20 +1,56 @@
+/*
+ * $Log: dns_sortip.c,v $
+ * Revision 1.2  2005-06-10 12:10:04+05:30  Cprogrammer
+ * adeed ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "byte.h"
 #include "dns.h"
+#ifdef IPV6
 
-/* XXX: sort servers by configurable notion of closeness? */
-/* XXX: pay attention to competence of each server? */
+/*
+ * XXX: sort servers by configurable notion of closeness? 
+ * XXX: pay attention to competence of each server? 
+ */
 
-void dns_sortip(char *s,unsigned int n)
+void
+dns_sortip6(char *s, unsigned int n)
 {
-  unsigned int i;
-  char tmp[4];
+	unsigned int    i;
+	char            tmp[16];
 
-  n >>= 2;
-  while (n > 1) {
-    i = dns_random(n);
-    --n;
-    byte_copy(tmp,4,s + (i << 2));
-    byte_copy(s + (i << 2),4,s + (n << 2));
-    byte_copy(s + (n << 2),4,tmp);
-  }
+	n >>= 4;
+	while (n > 1)
+	{
+		i = dns_random(n);
+		--n;
+		byte_copy(tmp, 16, s + (i << 4));
+		byte_copy(s + (i << 4), 16, s + (n << 4));
+		byte_copy(s + (n << 4), 16, tmp);
+	}
 }
+#else
+
+/*- XXX: sort servers by configurable notion of closeness?  */
+/*- XXX: pay attention to competence of each server?  */
+
+void
+dns_sortip(char *s, unsigned int n)
+{
+	unsigned int    i;
+	char            tmp[4];
+
+	n >>= 2;
+	while (n > 1)
+	{
+		i = dns_random(n);
+		--n;
+		byte_copy(tmp, 4, s + (i << 2));
+		byte_copy(s + (i << 2), 4, s + (n << 2));
+		byte_copy(s + (n << 2), 4, tmp);
+	}
+}
+#endif
diff -Naur tmp/ucspi-tcp-0.88/dns_transmit.c ucspi-tcp-0.88/dns_transmit.c
--- tmp/ucspi-tcp-0.88/dns_transmit.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns_transmit.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,364 +1,506 @@
+/*
+ * $Log: dns_transmit.c,v $
+ * Revision 1.4  2008-07-17 23:03:10+05:30  Cprogrammer
+ * use unistd.h instead of readwrite.h
+ *
+ * Revision 1.3  2007-06-10 10:14:34+05:30  Cprogrammer
+ * fixed compilation warnings
+ *
+ * Revision 1.2  2005-06-10 09:12:36+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <unistd.h>
 #include "socket.h"
 #include "alloc.h"
 #include "error.h"
 #include "byte.h"
-#include "readwrite.h"
 #include "uint16.h"
+#ifdef IPV6
+#include "ip6.h"
+#endif
 #include "dns.h"
+#include <unistd.h>
 
-static int serverwantstcp(char *buf,unsigned int len)
-{
-  char out[12];
-
-  if (!dns_packet_copy(buf,len,0,out,12)) return 1;
-  if (out[2] & 2) return 1;
-  return 0;
-}
-
-static int serverfailed(char *buf,unsigned int len)
-{
-  char out[12];
-  unsigned int rcode;
-
-  if (!dns_packet_copy(buf,len,0,out,12)) return 1;
-  rcode = out[3];
-  rcode &= 15;
-  if (rcode && (rcode != 3)) { errno = error_again; return 1; }
-  return 0;
-}
-
-static int irrelevant(struct dns_transmit *d,char *buf,unsigned int len)
-{
-  char out[12];
-  char *dn;
-  unsigned int pos;
-
-  pos = dns_packet_copy(buf,len,0,out,12); if (!pos) return 1;
-  if (byte_diff(out,2,d->query + 2)) return 1;
-  if (out[4] != 0) return 1;
-  if (out[5] != 1) return 1;
-
-  dn = 0;
-  pos = dns_packet_getname(buf,len,pos,&dn); if (!pos) return 1;
-  if (!dns_domain_equal(dn,d->query + 14)) { alloc_free(dn); return 1; }
-  alloc_free(dn);
-
-  pos = dns_packet_copy(buf,len,pos,out,4); if (!pos) return 1;
-  if (byte_diff(out,2,d->qtype)) return 1;
-  if (byte_diff(out + 2,2,DNS_C_IN)) return 1;
-
-  return 0;
-}
-
-static void packetfree(struct dns_transmit *d)
-{
-  if (!d->packet) return;
-  alloc_free(d->packet);
-  d->packet = 0;
-}
-
-static void queryfree(struct dns_transmit *d)
-{
-  if (!d->query) return;
-  alloc_free(d->query);
-  d->query = 0;
-}
-
-static void socketfree(struct dns_transmit *d)
-{
-  if (!d->s1) return;
-  close(d->s1 - 1);
-  d->s1 = 0;
-}
-
-void dns_transmit_free(struct dns_transmit *d)
-{
-  queryfree(d);
-  socketfree(d);
-  packetfree(d);
-}
-
-static int randombind(struct dns_transmit *d)
-{
-  int j;
-
-  for (j = 0;j < 10;++j)
-    if (socket_bind4(d->s1 - 1,d->localip,1025 + dns_random(64510)) == 0)
-      return 0;
-  if (socket_bind4(d->s1 - 1,d->localip,0) == 0)
-    return 0;
-  return -1;
-}
-
-static const int timeouts[4] = { 1, 3, 11, 45 };
-
-static int thisudp(struct dns_transmit *d)
-{
-  char *ip;
-
-  socketfree(d);
-
-  while (d->udploop < 4) {
-    for (;d->curserver < 16;++d->curserver) {
-      ip = d->servers + 4 * d->curserver;
-      if (byte_diff(ip,4,"\0\0\0\0")) {
-	d->query[2] = dns_random(256);
-	d->query[3] = dns_random(256);
-  
-        d->s1 = 1 + socket_udp();
-        if (!d->s1) { dns_transmit_free(d); return -1; }
-	if (randombind(d) == -1) { dns_transmit_free(d); return -1; }
-
-        if (socket_connect4(d->s1 - 1,ip,53) == 0)
-          if (send(d->s1 - 1,d->query + 2,d->querylen - 2,0) == d->querylen - 2) {
-            struct taia now;
-            taia_now(&now);
-            taia_uint(&d->deadline,timeouts[d->udploop]);
-            taia_add(&d->deadline,&d->deadline,&now);
-            d->tcpstate = 0;
-            return 0;
-          }
-  
-        socketfree(d);
-      }
-    }
-
-    ++d->udploop;
-    d->curserver = 0;
-  }
-
-  dns_transmit_free(d); return -1;
-}
-
-static int firstudp(struct dns_transmit *d)
-{
-  d->curserver = 0;
-  return thisudp(d);
-}
-
-static int nextudp(struct dns_transmit *d)
+static int
+serverwantstcp(char *buf, unsigned int len)
 {
-  ++d->curserver;
-  return thisudp(d);
-}
-
-static int thistcp(struct dns_transmit *d)
-{
-  struct taia now;
-  char *ip;
-
-  socketfree(d);
-  packetfree(d);
-
-  for (;d->curserver < 16;++d->curserver) {
-    ip = d->servers + 4 * d->curserver;
-    if (byte_diff(ip,4,"\0\0\0\0")) {
-      d->query[2] = dns_random(256);
-      d->query[3] = dns_random(256);
-
-      d->s1 = 1 + socket_tcp();
-      if (!d->s1) { dns_transmit_free(d); return -1; }
-      if (randombind(d) == -1) { dns_transmit_free(d); return -1; }
-  
-      taia_now(&now);
-      taia_uint(&d->deadline,10);
-      taia_add(&d->deadline,&d->deadline,&now);
-      if (socket_connect4(d->s1 - 1,ip,53) == 0) {
-        d->tcpstate = 2;
-        return 0;
-      }
-      if ((errno == error_inprogress) || (errno == error_wouldblock)) {
-        d->tcpstate = 1;
-        return 0;
-      }
-  
-      socketfree(d);
-    }
-  }
-
-  dns_transmit_free(d); return -1;
-}
-
-static int firsttcp(struct dns_transmit *d)
-{
-  d->curserver = 0;
-  return thistcp(d);
-}
-
-static int nexttcp(struct dns_transmit *d)
-{
-  ++d->curserver;
-  return thistcp(d);
-}
-
-int dns_transmit_start(struct dns_transmit *d,char servers[64],int flagrecursive,char *q,char qtype[2],char localip[4])
-{
-  unsigned int len;
-
-  dns_transmit_free(d);
-  errno = error_io;
-
-  len = dns_domain_length(q);
-  d->querylen = len + 18;
-  d->query = alloc(d->querylen);
-  if (!d->query) return -1;
-
-  uint16_pack_big(d->query,len + 16);
-  byte_copy(d->query + 2,12,flagrecursive ? "\0\0\1\0\0\1\0\0\0\0\0\0" : "\0\0\0\0\0\1\0\0\0\0\0\0gcc-bug-workaround");
-  byte_copy(d->query + 14,len,q);
-  byte_copy(d->query + 14 + len,2,qtype);
-  byte_copy(d->query + 16 + len,2,DNS_C_IN);
-
-  byte_copy(d->qtype,2,qtype);
-  d->servers = servers;
-  byte_copy(d->localip,4,localip);
-
-  d->udploop = flagrecursive ? 1 : 0;
-
-  if (len + 16 > 512) return firsttcp(d);
-  return firstudp(d);
-}
-
-void dns_transmit_io(struct dns_transmit *d,iopause_fd *x,struct taia *deadline)
-{
-  x->fd = d->s1 - 1;
-
-  switch(d->tcpstate) {
-    case 0: case 3: case 4: case 5:
-      x->events = IOPAUSE_READ;
-      break;
-    case 1: case 2:
-      x->events = IOPAUSE_WRITE;
-      break;
-  }
-
-  if (taia_less(&d->deadline,deadline))
-    *deadline = d->deadline;
-}
-
-int dns_transmit_get(struct dns_transmit *d,iopause_fd *x,struct taia *when)
-{
-  char udpbuf[513];
-  unsigned char ch;
-  int r;
-  int fd;
-
-  errno = error_io;
-  fd = d->s1 - 1;
-
-  if (!x->revents) {
-    if (taia_less(when,&d->deadline)) return 0;
-    errno = error_timeout;
-    if (d->tcpstate == 0) return nextudp(d);
-    return nexttcp(d);
-  }
-
-  if (d->tcpstate == 0) {
-/*
-have attempted to send UDP query to each server udploop times
-have sent query to curserver on UDP socket s
-*/
-    r = recv(fd,udpbuf,sizeof udpbuf,0);
-    if (r <= 0) {
-      if (d->udploop == 2) return 0;
-      return nextudp(d);
-    }
-    if (r + 1 > sizeof udpbuf) return 0;
-
-    if (irrelevant(d,udpbuf,r)) return 0;
-    if (serverwantstcp(udpbuf,r)) return firsttcp(d);
-    if (serverfailed(udpbuf,r)) {
-      if (d->udploop == 2) return 0;
-      return nextudp(d);
-    }
-    socketfree(d);
-
-    d->packetlen = r;
-    d->packet = alloc(d->packetlen);
-    if (!d->packet) { dns_transmit_free(d); return -1; }
-    byte_copy(d->packet,d->packetlen,udpbuf);
-    queryfree(d);
-    return 1;
-  }
-
-  if (d->tcpstate == 1) {
-/*
-have sent connection attempt to curserver on TCP socket s
-pos not defined
-*/
-    if (!socket_connected(fd)) return nexttcp(d);
-    d->pos = 0;
-    d->tcpstate = 2;
-    return 0;
-  }
-
-  if (d->tcpstate == 2) {
-/*
-have connection to curserver on TCP socket s
-have sent pos bytes of query
-*/
-    r = write(fd,d->query + d->pos,d->querylen - d->pos);
-    if (r <= 0) return nexttcp(d);
-    d->pos += r;
-    if (d->pos == d->querylen) {
-      struct taia now;
-      taia_now(&now);
-      taia_uint(&d->deadline,10);
-      taia_add(&d->deadline,&d->deadline,&now);
-      d->tcpstate = 3;
-    }
-    return 0;
-  }
-
-  if (d->tcpstate == 3) {
-/*
-have sent entire query to curserver on TCP socket s
-pos not defined
-*/
-    r = read(fd,&ch,1);
-    if (r <= 0) return nexttcp(d);
-    d->packetlen = ch;
-    d->tcpstate = 4;
-    return 0;
-  }
-
-  if (d->tcpstate == 4) {
-/*
-have sent entire query to curserver on TCP socket s
-pos not defined
-have received one byte of packet length into packetlen
-*/
-    r = read(fd,&ch,1);
-    if (r <= 0) return nexttcp(d);
-    d->packetlen <<= 8;
-    d->packetlen += ch;
-    d->tcpstate = 5;
-    d->pos = 0;
-    d->packet = alloc(d->packetlen);
-    if (!d->packet) { dns_transmit_free(d); return -1; }
-    return 0;
-  }
-
-  if (d->tcpstate == 5) {
-/*
-have sent entire query to curserver on TCP socket s
-have received entire packet length into packetlen
-packet is allocated
-have received pos bytes of packet
-*/
-    r = read(fd,d->packet + d->pos,d->packetlen - d->pos);
-    if (r <= 0) return nexttcp(d);
-    d->pos += r;
-    if (d->pos < d->packetlen) return 0;
-
-    socketfree(d);
-    if (irrelevant(d,d->packet,d->packetlen)) return nexttcp(d);
-    if (serverwantstcp(d->packet,d->packetlen)) return nexttcp(d);
-    if (serverfailed(d->packet,d->packetlen)) return nexttcp(d);
-
-    queryfree(d);
-    return 1;
-  }
+	char            out[12];
 
-  return 0;
+	if (!dns_packet_copy(buf, len, 0, out, 12))
+		return 1;
+	if (out[2] & 2)
+		return 1;
+	return 0;
+}
+
+static int
+serverfailed(char *buf, unsigned int len)
+{
+	char            out[12];
+	unsigned int    rcode;
+
+	if (!dns_packet_copy(buf, len, 0, out, 12))
+		return 1;
+	rcode = out[3];
+	rcode &= 15;
+	if (rcode && (rcode != 3))
+	{
+		errno = error_again;
+		return 1;
+	}
+	return 0;
+}
+
+static int
+irrelevant(struct dns_transmit *d, char *buf, unsigned int len)
+{
+	char            out[12];
+	char           *dn;
+	unsigned int    pos;
+
+	pos = dns_packet_copy(buf, len, 0, out, 12);
+	if (!pos)
+		return 1;
+	if (byte_diff(out, 2, d->query + 2))
+		return 1;
+	if (out[4] != 0)
+		return 1;
+	if (out[5] != 1)
+		return 1;
+	dn = 0;
+	pos = dns_packet_getname(buf, len, pos, &dn);
+	if (!pos)
+		return 1;
+	if (!dns_domain_equal(dn, d->query + 14))
+	{
+		alloc_free(dn);
+		return 1;
+	}
+	alloc_free(dn);
+	pos = dns_packet_copy(buf, len, pos, out, 4);
+	if (!pos)
+		return 1;
+	if (byte_diff(out, 2, d->qtype))
+		return 1;
+	if (byte_diff(out + 2, 2, DNS_C_IN))
+		return 1;
+	return 0;
+}
+
+static void
+packetfree(struct dns_transmit *d)
+{
+	if (!d->packet)
+		return;
+	alloc_free(d->packet);
+	d->packet = 0;
+}
+
+static void
+queryfree(struct dns_transmit *d)
+{
+	if (!d->query)
+		return;
+	alloc_free(d->query);
+	d->query = 0;
+}
+
+static void
+socketfree(struct dns_transmit *d)
+{
+	if (!d->s1)
+		return;
+	close(d->s1 - 1);
+	d->s1 = 0;
+}
+
+void
+dns_transmit_free(struct dns_transmit *d)
+{
+	queryfree(d);
+	socketfree(d);
+	packetfree(d);
+}
+
+static int
+randombind(struct dns_transmit *d)
+{
+	int             j;
+
+	for (j = 0; j < 10; ++j)
+	{
+#ifdef IPV6
+		if (socket_bind6(d->s1 - 1, d->localip, 1025 + dns_random(64510), d->scope_id) == 0)
+#else
+		if (socket_bind4(d->s1 - 1, d->localip, 1025 + dns_random(64510)) == 0)
+#endif
+			return 0;
+	}
+#ifdef IPV6
+	if (socket_bind6(d->s1 - 1, d->localip, 0, d->scope_id) == 0)
+#else
+	if (socket_bind4(d->s1 - 1, d->localip, 0) == 0)
+#endif
+		return 0;
+	return -1;
+}
+
+static int timeouts[4] = { 1, 3, 11, 45 };
+
+static int
+thisudp(struct dns_transmit *d)
+{
+	char           *ip;
+
+	socketfree(d);
+	while (d->udploop < 4)
+	{
+		for (; d->curserver < 16; ++d->curserver)
+		{
+#ifdef IPV6
+			ip = d->servers + 16 * d->curserver;
+			if (byte_diff(ip, 16, V6any))
+#else
+			ip = d->servers + 4 * d->curserver;
+			if (byte_diff(ip, 4, "\0\0\0\0"))
+#endif
+			{
+				d->query[2] = dns_random(256);
+				d->query[3] = dns_random(256);
+#ifdef IPV6
+				d->s1 = 1 + socket_udp6();
+#else
+				d->s1 = 1 + socket_udp();
+#endif
+				if (!d->s1)
+				{
+					dns_transmit_free(d);
+					return -1;
+				}
+				if (randombind(d) == -1)
+				{
+					dns_transmit_free(d);
+					return -1;
+				}
+#ifdef IPV6
+				if (socket_connect6(d->s1 - 1, ip, 53, d->scope_id) == 0)
+#else
+				if (socket_connect4(d->s1 - 1, ip, 53) == 0)
+#endif
+				{
+					if (send(d->s1 - 1, d->query + 2, d->querylen - 2, 0) == d->querylen - 2)
+					{
+						struct taia     now;
+						taia_now(&now);
+						taia_uint(&d->deadline, timeouts[d->udploop]);
+						taia_add(&d->deadline, &d->deadline, &now);
+						d->tcpstate = 0;
+						return 0;
+					}
+				}
+				socketfree(d);
+			}
+		}
+		++d->udploop;
+		d->curserver = 0;
+	}
+	dns_transmit_free(d);
+	return -1;
+}
+
+static int
+firstudp(struct dns_transmit *d)
+{
+	d->curserver = 0;
+	return thisudp(d);
+}
+
+static int
+nextudp(struct dns_transmit *d)
+{
+	++d->curserver;
+	return thisudp(d);
+}
+
+static int
+thistcp(struct dns_transmit *d)
+{
+	struct taia     now;
+	char          *ip;
+
+	socketfree(d);
+	packetfree(d);
+	for (; d->curserver < 16; ++d->curserver)
+	{
+#ifdef IPV6
+		ip = d->servers + 16 * d->curserver;
+		if (byte_diff(ip, 16, V6any))
+#else
+		ip = d->servers + 4 * d->curserver;
+		if (byte_diff(ip, 4, "\0\0\0\0"))
+#endif
+		{
+			d->query[2] = dns_random(256);
+			d->query[3] = dns_random(256);
+#ifdef IPV6
+			d->s1 = 1 + socket_tcp6();
+#else
+			d->s1 = 1 + socket_tcp();
+#endif
+			if (!d->s1)
+			{
+				dns_transmit_free(d);
+				return -1;
+			}
+			if (randombind(d) == -1)
+			{
+				dns_transmit_free(d);
+				return -1;
+			}
+			taia_now(&now);
+			taia_uint(&d->deadline, 10);
+			taia_add(&d->deadline, &d->deadline, &now);
+#ifdef IPV6
+			if (socket_connect6(d->s1 - 1, ip, 53, d->scope_id) == 0)
+#else
+			if (socket_connect4(d->s1 - 1, ip, 53) == 0)
+#endif
+			{
+				d->tcpstate = 2;
+				return 0;
+			}
+			if ((errno == error_inprogress) || (errno == error_wouldblock))
+			{
+				d->tcpstate = 1;
+				return 0;
+			}
+			socketfree(d);
+		}
+	}
+	dns_transmit_free(d);
+	return -1;
+}
+
+static int
+firsttcp(struct dns_transmit *d)
+{
+	d->curserver = 0;
+	return thistcp(d);
+}
+
+static int
+nexttcp(struct dns_transmit *d)
+{
+	++d->curserver;
+	return thistcp(d);
+}
+
+int
+#ifdef IPV6
+dns_transmit_start(struct dns_transmit *d, char servers[256], int flagrecursive,
+	char *q, char qtype[2], unsigned char localip[16])
+#else
+dns_transmit_start(struct dns_transmit *d, char servers[64], int flagrecursive,
+	char *q, char qtype[2], unsigned char localip[4])
+#endif
+{
+	unsigned int    len;
+
+	dns_transmit_free(d);
+	errno = error_io;
+	len = dns_domain_length(q);
+	d->querylen = len + 18;
+	d->query = alloc(d->querylen);
+	if (!d->query)
+		return -1;
+	uint16_pack_big(d->query, len + 16);
+	byte_copy(d->query + 2, 12, flagrecursive ? "\0\0\1\0\0\1\0\0\0\0\0\0" : "\0\0\0\0\0\1\0\0\0\0\0\0gcc-bug-workaround");
+	byte_copy(d->query + 14, len, q);
+	byte_copy(d->query + 14 + len, 2, qtype);
+	byte_copy(d->query + 16 + len, 2, DNS_C_IN);
+	byte_copy(d->qtype, 2, qtype);
+	d->servers = servers;
+#ifdef IPV6
+	byte_copy(d->localip, 16, localip);
+#else
+	byte_copy(d->localip, 4, localip);
+#endif
+	d->udploop = flagrecursive ? 1 : 0;
+	if (len + 16 > 512)
+		return firsttcp(d);
+	return firstudp(d);
+}
+
+void
+dns_transmit_io(struct dns_transmit *d, iopause_fd * x, struct taia *deadline)
+{
+	x->fd = d->s1 - 1;
+	switch (d->tcpstate)
+	{
+	case 0:
+	case 3:
+	case 4:
+	case 5:
+		x->events = IOPAUSE_READ;
+		break;
+	case 1:
+	case 2:
+		x->events = IOPAUSE_WRITE;
+		break;
+	}
+	if (taia_less(&d->deadline, deadline))
+		*deadline = d->deadline;
+}
+
+int
+dns_transmit_get(struct dns_transmit *d, iopause_fd *x, struct taia *when)
+{
+	char            udpbuf[513];
+	unsigned char   ch;
+	int             r;
+	int             fd;
+
+	errno = error_io;
+	fd = d->s1 - 1;
+	if (!x->revents)
+	{
+		if (taia_less(when, &d->deadline))
+			return 0;
+		errno = error_timeout;
+		if (d->tcpstate == 0)
+			return nextudp(d);
+		return nexttcp(d);
+	}
+	if (d->tcpstate == 0)
+	{
+		/*
+		 * have attempted to send UDP query to each server udploop times
+		 * have sent query to curserver on UDP socket s
+		 */
+		if ((r = recv(fd, udpbuf, sizeof udpbuf, 0)) <= 0)
+		{
+#ifdef IPV6
+			if (errno == ECONNREFUSED && d->udploop == 2)
+#else
+			if (d->udploop == 2)
+#endif
+				return 0;
+			return nextudp(d);
+		}
+		if (r + 1 > sizeof udpbuf)
+			return 0;
+		if (irrelevant(d, udpbuf, r))
+			return 0;
+		if (serverwantstcp(udpbuf, r))
+			return firsttcp(d);
+		if (serverfailed(udpbuf, r))
+		{
+			if (d->udploop == 2)
+				return 0;
+			return nextudp(d);
+		}
+		socketfree(d);
+		d->packetlen = r;
+		d->packet = alloc(d->packetlen);
+		if (!d->packet)
+		{
+			dns_transmit_free(d);
+			return -1;
+		}
+		byte_copy(d->packet, d->packetlen, udpbuf);
+		queryfree(d);
+		return 1;
+	}
+	if (d->tcpstate == 1)
+	{
+		/*
+		 * have sent connection attempt to curserver on TCP socket s
+		 * pos not defined
+		 */
+		if (!socket_connected(fd))
+			return nexttcp(d);
+		d->pos = 0;
+		d->tcpstate = 2;
+		return 0;
+	}
+	if (d->tcpstate == 2)
+	{
+		/*
+		 * have connection to curserver on TCP socket s
+		 * have sent pos bytes of query
+		 */
+		if ((r = write(fd, d->query + d->pos, d->querylen - d->pos)) <= 0)
+			return nexttcp(d);
+		d->pos += r;
+		if (d->pos == d->querylen)
+		{
+			struct taia     now;
+			taia_now(&now);
+			taia_uint(&d->deadline, 10);
+			taia_add(&d->deadline, &d->deadline, &now);
+			d->tcpstate = 3;
+		}
+		return 0;
+	}
+	if (d->tcpstate == 3)
+	{
+		/*
+		 * have sent entire query to curserver on TCP socket s
+		 * pos not defined
+		 */
+		if ((r = read(fd, &ch, 1)) <= 0)
+			return nexttcp(d);
+		d->packetlen = ch;
+		d->tcpstate = 4;
+		return 0;
+	}
+	if (d->tcpstate == 4)
+	{
+		/*
+		 * have sent entire query to curserver on TCP socket s
+		 * pos not defined
+		 * have received one byte of packet length into packetlen
+		 */
+		if ((r = read(fd, &ch, 1)) <= 0)
+			return nexttcp(d);
+		d->packetlen <<= 8;
+		d->packetlen += ch;
+		d->tcpstate = 5;
+		d->pos = 0;
+		d->packet = alloc(d->packetlen);
+		if (!d->packet)
+		{
+			dns_transmit_free(d);
+			return -1;
+		}
+		return 0;
+	}
+	if (d->tcpstate == 5)
+	{
+		/*
+		 * have sent entire query to curserver on TCP socket s
+		 * have received entire packet length into packetlen
+		 * packet is allocated
+		 * have received pos bytes of packet
+		 */
+		if ((r = read(fd, d->packet + d->pos, d->packetlen - d->pos)) <= 0)
+			return nexttcp(d);
+		d->pos += r;
+		if (d->pos < d->packetlen)
+			return 0;
+		socketfree(d);
+		if (irrelevant(d, d->packet, d->packetlen))
+			return nexttcp(d);
+		if (serverwantstcp(d->packet, d->packetlen))
+			return nexttcp(d);
+		if (serverfailed(d->packet, d->packetlen))
+			return nexttcp(d);
+		queryfree(d);
+		return 1;
+	}
+	return 0;
 }
diff -Naur tmp/ucspi-tcp-0.88/dns_txt.c ucspi-tcp-0.88/dns_txt.c
--- tmp/ucspi-tcp-0.88/dns_txt.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/dns_txt.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,59 +1,89 @@
+/*
+ * $Log: dns_txt.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "stralloc.h"
 #include "uint16.h"
 #include "byte.h"
 #include "dns.h"
 
-int dns_txt_packet(stralloc *out,char *buf,unsigned int len)
+int
+dns_txt_packet(stralloc * out, char *buf, unsigned int len)
 {
-  unsigned int pos;
-  char header[12];
-  uint16 numanswers;
-  uint16 datalen;
-  char ch;
-  unsigned int txtlen;
-  int i;
-
-  if (!stralloc_copys(out,"")) return -1;
-
-  pos = dns_packet_copy(buf,len,0,header,12); if (!pos) return -1;
-  uint16_unpack_big(header + 6,&numanswers);
-  pos = dns_packet_skipname(buf,len,pos); if (!pos) return -1;
-  pos += 4;
-
-  while (numanswers--) {
-    pos = dns_packet_skipname(buf,len,pos); if (!pos) return -1;
-    pos = dns_packet_copy(buf,len,pos,header,10); if (!pos) return -1;
-    uint16_unpack_big(header + 8,&datalen);
-    if (byte_equal(header,2,DNS_T_TXT))
-      if (byte_equal(header + 2,2,DNS_C_IN)) {
-	if (pos + datalen > len) return -1;
-	txtlen = 0;
-	for (i = 0;i < datalen;++i) {
-	  ch = buf[pos + i];
-	  if (!txtlen)
-	    txtlen = (unsigned char) ch;
-	  else {
-	    --txtlen;
-	    if (ch < 32) ch = '?';
-	    if (ch > 126) ch = '?';
-	    if (!stralloc_append(out,&ch)) return -1;
-	  }
+	unsigned int    pos;
+	char            header[12];
+	uint16          numanswers;
+	uint16          datalen;
+	char            ch;
+	unsigned int    txtlen;
+	int             i;
+
+	if (!stralloc_copys(out, ""))
+		return -1;
+
+	pos = dns_packet_copy(buf, len, 0, header, 12);
+	if (!pos)
+		return -1;
+	uint16_unpack_big(header + 6, &numanswers);
+	pos = dns_packet_skipname(buf, len, pos);
+	if (!pos)
+		return -1;
+	pos += 4;
+
+	while (numanswers--)
+	{
+		pos = dns_packet_skipname(buf, len, pos);
+		if (!pos)
+			return -1;
+		pos = dns_packet_copy(buf, len, pos, header, 10);
+		if (!pos)
+			return -1;
+		uint16_unpack_big(header + 8, &datalen);
+		if (byte_equal(header, 2, DNS_T_TXT))
+		{
+			if (byte_equal(header + 2, 2, DNS_C_IN))
+			{
+				if (pos + datalen > len)
+					return -1;
+				txtlen = 0;
+				for (i = 0; i < datalen; ++i)
+				{
+					ch = buf[pos + i];
+					if (!txtlen)
+						txtlen = (unsigned char) ch;
+					else
+					{
+						--txtlen;
+						if (ch < 32)
+							ch = '?';
+						if (ch > 126)
+							ch = '?';
+						if (!stralloc_append(out, &ch))
+							return -1;
+					}
+				}
+			}
+		}
+		pos += datalen;
 	}
-      }
-    pos += datalen;
-  }
 
-  return 0;
+	return 0;
 }
 
-static char *q = 0;
+static char    *q = 0;
 
-int dns_txt(stralloc *out,stralloc *fqdn)
+int
+dns_txt(stralloc * out, stralloc * fqdn)
 {
-  if (!dns_domain_fromdot(&q,fqdn->s,fqdn->len)) return -1;
-  if (dns_resolve(q,DNS_T_TXT) == -1) return -1;
-  if (dns_txt_packet(out,dns_resolve_tx.packet,dns_resolve_tx.packetlen) == -1) return -1;
-  dns_transmit_free(&dns_resolve_tx);
-  dns_domain_free(&q);
-  return 0;
+	if (!dns_domain_fromdot(&q, fqdn->s, fqdn->len))
+		return -1;
+	if (dns_resolve(q, DNS_T_TXT) == -1)
+		return -1;
+	if (dns_txt_packet(out, dns_resolve_tx.packet, dns_resolve_tx.packetlen) == -1)
+		return -1;
+	dns_transmit_free(&dns_resolve_tx);
+	dns_domain_free(&q);
+	return 0;
 }
diff -Naur tmp/ucspi-tcp-0.88/env.c ucspi-tcp-0.88/env.c
--- tmp/ucspi-tcp-0.88/env.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/env.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,15 +1,26 @@
+/*
+ * $Log: env.c,v $
+ * Revision 1.1  2003-10-21 11:21:08+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "str.h"
 #include "env.h"
 
-extern /*@null@*/char *env_get(char *s)
+extern /*- @null@ */
+char       *
+env_get(char *s)
 {
-  int i;
-  unsigned int len;
+	int             i;
+	unsigned int    len;
 
-  if (!s) return 0;
-  len = str_len(s);
-  for (i = 0;environ[i];++i)
-    if (str_start(environ[i],s) && (environ[i][len] == '='))
-      return environ[i] + len + 1;
-  return 0;
+	if (!s)
+		return 0;
+	len = str_len(s);
+	for (i = 0; environ[i]; ++i)
+	{
+		if (str_start(environ[i], s) && (environ[i][len] == '='))
+			return environ[i] + len + 1;
+	}
+	return 0;
 }
diff -Naur tmp/ucspi-tcp-0.88/env.h ucspi-tcp-0.88/env.h
--- tmp/ucspi-tcp-0.88/env.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/env.h	2008-07-27 18:39:40.000000000 +0530
@@ -1,3 +1,9 @@
+/*
+ * $Log: env.h,v $
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef ENV_H
 #define ENV_H
 
diff -Naur tmp/ucspi-tcp-0.88/error.c ucspi-tcp-0.88/error.c
--- tmp/ucspi-tcp-0.88/error.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/error.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,4 +1,9 @@
-#include <errno.h>
+/*
+ * $Log: error.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "error.h"
 
 /* warning: as coverage improves here, should update error_{str,temp} */
diff -Naur tmp/ucspi-tcp-0.88/error.h ucspi-tcp-0.88/error.h
--- tmp/ucspi-tcp-0.88/error.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/error.h	2008-07-27 18:39:40.000000000 +0530
@@ -1,7 +1,12 @@
+/*
+ * $Log: error.h,v $
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef ERROR_H
 #define ERROR_H
-
-extern int errno;
+#include <errno.h>
 
 extern int error_intr;
 extern int error_nomem;
diff -Naur tmp/ucspi-tcp-0.88/error_str.c ucspi-tcp-0.88/error_str.c
--- tmp/ucspi-tcp-0.88/error_str.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/error_str.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,4 +1,9 @@
-#include <errno.h>
+/*
+ * $Log: error_str.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "error.h"
 
 #define X(e,s) if (i == e) return s;
diff -Naur tmp/ucspi-tcp-0.88/exit.h ucspi-tcp-0.88/exit.h
--- tmp/ucspi-tcp-0.88/exit.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/exit.h	2008-07-27 18:39:40.000000000 +0530
@@ -1,3 +1,9 @@
+/*
+ * $Log: exit.h,v $
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef EXIT_H
 #define EXIT_H
 
diff -Naur tmp/ucspi-tcp-0.88/fd_copy.c ucspi-tcp-0.88/fd_copy.c
--- tmp/ucspi-tcp-0.88/fd_copy.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/fd_copy.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,11 +1,22 @@
+/*
+ * $Log: fd_copy.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <fcntl.h>
 #include "fd.h"
+#include <unistd.h>
 
-int fd_copy(int to,int from)
+int
+fd_copy(int to, int from)
 {
-  if (to == from) return 0;
-  if (fcntl(from,F_GETFL,0) == -1) return -1;
-  close(to);
-  if (fcntl(from,F_DUPFD,to) == -1) return -1;
-  return 0;
+	if (to == from)
+		return 0;
+	if (fcntl(from, F_GETFL, 0) == -1)
+		return -1;
+	close(to);
+	if (fcntl(from, F_DUPFD, to) == -1)
+		return -1;
+	return 0;
 }
diff -Naur tmp/ucspi-tcp-0.88/fd.h ucspi-tcp-0.88/fd.h
--- tmp/ucspi-tcp-0.88/fd.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/fd.h	2008-07-27 18:39:40.000000000 +0530
@@ -1,3 +1,9 @@
+/*
+ * $Log: fd.h,v $
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef FD_H
 #define FD_H
 
diff -Naur tmp/ucspi-tcp-0.88/fd_move.c ucspi-tcp-0.88/fd_move.c
--- tmp/ucspi-tcp-0.88/fd_move.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/fd_move.c	2008-07-27 18:39:31.000000000 +0530
@@ -1,9 +1,19 @@
+/*
+ * $Log: fd_move.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "fd.h"
+#include <unistd.h>
 
-int fd_move(int to,int from)
+int
+fd_move(int to, int from)
 {
-  if (to == from) return 0;
-  if (fd_copy(to,from) == -1) return -1;
-  close(from);
-  return 0;
+	if (to == from)
+		return 0;
+	if (fd_copy(to, from) == -1)
+		return -1;
+	close(from);
+	return 0;
 }
diff -Naur tmp/ucspi-tcp-0.88/FILES ucspi-tcp-0.88/FILES
--- tmp/ucspi-tcp-0.88/FILES	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/FILES	2008-07-30 11:36:15.000000000 +0530
@@ -9,6 +9,7 @@
 conf-cc
 conf-ld
 conf-home
+conf-mysqlrules
 tcpserver.c
 tcprules.c
 tcprulescheck.c
@@ -216,3 +217,7 @@
 warn-auto.sh
 warn-shsgr
 x86cpuid.c
+db.h
+db.c
+dbinfo.c
+trymysql.c
diff -Naur tmp/ucspi-tcp-0.88/find-systype.sh ucspi-tcp-0.88/find-systype.sh
--- tmp/ucspi-tcp-0.88/find-systype.sh	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/find-systype.sh	2008-07-27 18:42:30.000000000 +0530
@@ -1,3 +1,9 @@
+#
+# $Log: find-systype.sh,v $
+# Revision 1.1  2003-12-31 19:57:58+05:30  Cprogrammer
+# Initial revision
+#
+#
 # oper-:arch-:syst-:chip-:kern-
 # oper = operating system type; e.g., sunos-4.1.4
 # arch = machine language; e.g., sparc
diff -Naur tmp/ucspi-tcp-0.88/finger@.1 ucspi-tcp-0.88/finger@.1
--- tmp/ucspi-tcp-0.88/finger@.1	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/finger@.1	2000-11-16 17:06:19.000000000 +0530
@@ -0,0 +1,53 @@
+.TH finger@ 1
+.SH NAME
+finger@ \- gets user information from a remote host.
+.SH SYNOPSIS
+.B finger@
+[
+.I host
+[
+.I user
+] ]
+.SH DESCRIPTION
+.B finger@
+connects to TCP port 79 (Finger) on
+.IR host ,
+sends
+.I user
+(with an extra CR) to
+.IR host ,
+and prints any data it receives. It removes CR and converts unprintable
+characters to a visible format. 
+
+Some computers respond to port 79 with information about
+.IR user .
+
+If
+.I user
+is not supplied,
+.B finger@
+sends a blank line to host. Some computers respond with information about all
+the users who are logged in.
+
+If
+.I host
+is not supplied,
+.B finger@
+connects to the local host.
+.SH SEE ALSO
+tcpserver(1),
+tcprules(1),
+tcprulescheck(1),
+argv0(1),
+fixcrio(1),
+recordio(1),
+rblsmtpd(1),
+tcpclient(1),
+who@(1),
+date@(1),
+http@(1),
+tcpcat(1),
+mconnect(1),
+tcp-environ(5)
+
+http://cr.yp.to/ucspi-tcp.html
diff -Naur tmp/ucspi-tcp-0.88/finger@.sh ucspi-tcp-0.88/finger@.sh
--- tmp/ucspi-tcp-0.88/finger@.sh	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/finger@.sh	2008-07-27 18:42:42.000000000 +0530
@@ -1,3 +1,9 @@
+#
+# $Log: finger@.sh,v $
+# Revision 1.1  2003-12-31 19:57:58+05:30  Cprogrammer
+# Initial revision
+#
+#
 echo "${2-}" | HOME/bin/tcpclient -RHl0 -- "${1-0}" 79 sh -c '
   HOME/bin/addcr >&7
   exec HOME/bin/delcr <&6
diff -Naur tmp/ucspi-tcp-0.88/fixcrio.c ucspi-tcp-0.88/fixcrio.c
--- tmp/ucspi-tcp-0.88/fixcrio.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/fixcrio.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,161 +0,0 @@
-#include "sig.h"
-#include "buffer.h"
-#include "strerr.h"
-#include "byte.h"
-#include "readwrite.h"
-#include "exit.h"
-#include "iopause.h"
-#include "pathexec.h"
-
-#define FATAL "fixcrio: fatal: "
-
-char prebuf[256];
-
-int leftstatus = 0;
-char leftbuf[512];
-int leftlen;
-int leftpos;
-int leftflagcr = 0;
-
-int rightstatus = 0;
-char rightbuf[512];
-int rightlen;
-int rightpos;
-int rightflagcr = 0;
-
-void doit(int fdleft,int fdright)
-{
-  struct taia stamp;
-  struct taia deadline;
-  iopause_fd x[4];
-  int xlen;
-  iopause_fd *io0;
-  iopause_fd *ioleft;
-  iopause_fd *io1;
-  iopause_fd *ioright;
-  int r;
-  int i;
-  char ch;
-
-  for (;;) {
-    xlen = 0;
-
-    io0 = 0;
-    if (leftstatus == 0) {
-      io0 = &x[xlen++];
-      io0->fd = 0;
-      io0->events = IOPAUSE_READ;
-    }
-    ioleft = 0;
-    if (leftstatus == 1) {
-      ioleft = &x[xlen++];
-      ioleft->fd = fdleft;
-      ioleft->events = IOPAUSE_WRITE;
-    }
-
-    ioright = 0;
-    if (rightstatus == 0) {
-      ioright = &x[xlen++];
-      ioright->fd = fdright;
-      ioright->events = IOPAUSE_READ;
-    }
-    io1 = 0;
-    if (rightstatus == 1) {
-      io1 = &x[xlen++];
-      io1->fd = 1;
-      io1->events = IOPAUSE_WRITE;
-    }
-
-    taia_now(&stamp);
-    taia_uint(&deadline,3600);
-    taia_add(&deadline,&stamp,&deadline);
-    iopause(x,xlen,&deadline,&stamp);
-
-    if (io0 && io0->revents) {
-      r = read(0,prebuf,sizeof prebuf);
-      if (r <= 0) {
-        leftstatus = -1;
-        close(fdleft);
-      }
-      else {
-        leftstatus = 1;
-	leftpos = 0;
-	leftlen = 0;
-	for (i = 0;i < r;++i) {
-	  ch = prebuf[i];
-	  if (ch == '\n')
-	    if (!leftflagcr)
-	      leftbuf[leftlen++] = '\r';
-	  leftbuf[leftlen++] = ch;
-	  leftflagcr = (ch == '\r');
-	}
-      }
-    }
-
-    if (ioleft && ioleft->revents) {
-      r = write(fdleft,leftbuf + leftpos,leftlen - leftpos);
-      if (r == -1) break;
-      leftpos += r;
-      if (leftpos == leftlen) leftstatus = 0;
-    }
-
-    if (ioright && ioright->revents) {
-      r = read(fdright,prebuf,sizeof prebuf);
-      if (r <= 0) break;
-      rightstatus = 1;
-      rightpos = 0;
-      rightlen = 0;
-      for (i = 0;i < r;++i) {
-	ch = prebuf[i];
-	if (ch == '\n')
-	  if (!rightflagcr)
-	    rightbuf[rightlen++] = '\r';
-	rightbuf[rightlen++] = ch;
-	rightflagcr = (ch == '\r');
-      }
-    }
-
-    if (io1 && io1->revents) {
-      r = write(1,rightbuf + rightpos,rightlen - rightpos);
-      if (r == -1) break;
-      rightpos += r;
-      if (rightpos == rightlen) rightstatus = 0;
-    }
-  }
-
-  _exit(0);
-}
-
-main(int argc,char **argv,char **envp)
-{
-  int piin[2];
-  int piout[2];
-
-  if (argc < 2)
-    strerr_die1x(100,"fixcrio: usage: fixcrio program [ arg ... ]");
-
-  if (pipe(piin) == -1)
-    strerr_die2sys(111,FATAL,"unable to create pipe: ");
-  if (pipe(piout) == -1)
-    strerr_die2sys(111,FATAL,"unable to create pipe: ");
-
-  switch(fork()) {
-    case -1:
-      strerr_die2sys(111,FATAL,"unable to fork: ");
-    case 0:
-      sig_ignore(sig_pipe);
-      close(piin[0]);
-      close(piout[1]);
-      doit(piin[1],piout[0]);
-  }
-
-  close(piin[1]);
-  close(piout[0]);
-  if (fd_move(0,piin[0]) == -1)
-    strerr_die2sys(111,FATAL,"unable to move descriptors: ");
-  if (fd_move(1,piout[1]) == -1)
-    strerr_die2sys(111,FATAL,"unable to move descriptors: ");
-
-  pathexec_run(argv[1],argv + 1,envp);
-  strerr_die4sys(111,FATAL,"unable to run ",argv[1],": ");
-}
diff -Naur tmp/ucspi-tcp-0.88/fmt.h ucspi-tcp-0.88/fmt.h
--- tmp/ucspi-tcp-0.88/fmt.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/fmt.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,25 +1,34 @@
+/*
+ * $Log: fmt.h,v $
+ * Revision 1.2  2005-05-13 23:52:27+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef FMT_H
 #define FMT_H
 
-#define FMT_ULONG 40 /* enough space to hold 2^128 - 1 in decimal, plus \0 */
-#define FMT_LEN ((char *) 0) /* convenient abbreviation */
+#define FMT_ULONG 40			/*- enough space to hold 2^128 - 1 in decimal, plus \0 */
+#define FMT_LEN ((char *) 0)	/*- convenient abbreviation */
 
-extern unsigned int fmt_uint(char *,unsigned int);
-extern unsigned int fmt_uint0(char *,unsigned int,unsigned int);
-extern unsigned int fmt_xint(char *,unsigned int);
-extern unsigned int fmt_nbbint(char *,unsigned int,unsigned int,unsigned int,unsigned int);
-extern unsigned int fmt_ushort(char *,unsigned short);
-extern unsigned int fmt_xshort(char *,unsigned short);
-extern unsigned int fmt_nbbshort(char *,unsigned int,unsigned int,unsigned int,unsigned short);
-extern unsigned int fmt_ulong(char *,unsigned long);
-extern unsigned int fmt_xlong(char *,unsigned long);
-extern unsigned int fmt_nbblong(char *,unsigned int,unsigned int,unsigned int,unsigned long);
+unsigned int    fmt_uint(char *, unsigned int);
+unsigned int    fmt_uint0(char *, unsigned int, unsigned int);
+unsigned int    fmt_xint(char *, unsigned int);
+unsigned int    fmt_nbbint(char *, unsigned int, unsigned int, unsigned int, unsigned int);
+unsigned int    fmt_ushort(char *, unsigned short);
+unsigned int    fmt_xshort(char *, unsigned short);
+unsigned int    fmt_nbbshort(char *, unsigned int, unsigned int, unsigned int, unsigned short);
+unsigned int    fmt_ulong(char *, unsigned long);
+unsigned int    fmt_xlong(char *, unsigned long);
+unsigned int    fmt_nbblong(char *, unsigned int, unsigned int, unsigned int, unsigned long);
 
-extern unsigned int fmt_plusminus(char *,int);
-extern unsigned int fmt_minus(char *,int);
-extern unsigned int fmt_0x(char *,int);
+unsigned int    fmt_plusminus(char *, int);
+unsigned int    fmt_minus(char *, int);
+unsigned int    fmt_0x(char *, int);
 
-extern unsigned int fmt_str(char *,char *);
-extern unsigned int fmt_strn(char *,char *,unsigned int);
+unsigned int    fmt_str(char *, char *);
+unsigned int    fmt_strn(char *, char *, unsigned int);
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/fmt_ulong.c ucspi-tcp-0.88/fmt_ulong.c
--- tmp/ucspi-tcp-0.88/fmt_ulong.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/fmt_ulong.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,13 +1,32 @@
+/*
+ * $Log: fmt_ulong.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "fmt.h"
 
-unsigned int fmt_ulong(register char *s,register unsigned long u)
+unsigned int
+fmt_ulong(register char *s, register unsigned long u)
 {
-  register unsigned int len; register unsigned long q;
-  len = 1; q = u;
-  while (q > 9) { ++len; q /= 10; }
-  if (s) {
-    s += len;
-    do { *--s = '0' + (u % 10); u /= 10; } while(u); /* handles u == 0 */
-  }
-  return len;
+	register unsigned int len;
+	register unsigned long q;
+	len = 1;
+	q = u;
+	while (q > 9)
+	{
+		++len;
+		q /= 10;
+	}
+	if (s)
+	{
+		s += len;
+		do
+		{
+			*--s = '0' + (u % 10);
+			u /= 10;
+		}
+		while (u);				/*- handles u == 0 */
+	}
+	return len;
 }
diff -Naur tmp/ucspi-tcp-0.88/fmt_xlong.c ucspi-tcp-0.88/fmt_xlong.c
--- tmp/ucspi-tcp-0.88/fmt_xlong.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/fmt_xlong.c	2008-07-27 18:41:45.000000000 +0530
@@ -0,0 +1,45 @@
+/*
+ * $Log: fmt_xlong.c,v $
+ * Revision 1.1  2005-06-10 09:04:19+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "fmt.h"
+
+char
+tohex(char num)
+{
+	if (num < 10)
+		return num + '0';
+	else
+	if (num < 16)
+		return num - 10 + 'a';
+	else
+		return -1;
+}
+
+unsigned int
+fmt_xlong(register char *s, register unsigned long u)
+{
+	register unsigned int len;
+	register unsigned long q;
+
+	len = 1;
+	q = u;
+	while (q > 15)
+	{
+		++len;
+		q /= 16;
+	}
+	if (s)
+	{
+		s += len;
+		do
+		{
+			*--s = tohex(u % 16);
+			u /= 16;
+		}
+		while (u);				/*- handles u == 0 */
+	}
+	return len;
+}
diff -Naur tmp/ucspi-tcp-0.88/fork.h1 ucspi-tcp-0.88/fork.h1
--- tmp/ucspi-tcp-0.88/fork.h1	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/fork.h1	1970-01-01 05:30:00.000000000 +0530
@@ -1,9 +0,0 @@
-#ifndef FORK_H
-#define FORK_H
-
-/* sysdep: -vfork */
-
-extern int fork();
-#define vfork fork
-
-#endif
diff -Naur tmp/ucspi-tcp-0.88/fork.h2 ucspi-tcp-0.88/fork.h2
--- tmp/ucspi-tcp-0.88/fork.h2	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/fork.h2	1970-01-01 05:30:00.000000000 +0530
@@ -1,9 +0,0 @@
-#ifndef FORK_H
-#define FORK_H
-
-/* sysdep: +vfork */
-
-extern int fork();
-extern int vfork();
-
-#endif
diff -Naur tmp/ucspi-tcp-0.88/gen_allocdefs.h ucspi-tcp-0.88/gen_allocdefs.h
--- tmp/ucspi-tcp-0.88/gen_allocdefs.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/gen_allocdefs.h	2008-07-27 18:39:40.000000000 +0530
@@ -1,3 +1,9 @@
+/*
+ * $Log: gen_allocdefs.h,v $
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef GEN_ALLOC_DEFS_H
 #define GEN_ALLOC_DEFS_H
 
diff -Naur tmp/ucspi-tcp-0.88/gen_alloc.h ucspi-tcp-0.88/gen_alloc.h
--- tmp/ucspi-tcp-0.88/gen_alloc.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/gen_alloc.h	2008-07-27 18:39:40.000000000 +0530
@@ -1,3 +1,9 @@
+/*
+ * $Log: gen_alloc.h,v $
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef GEN_ALLOC_H
 #define GEN_ALLOC_H
 
diff -Naur tmp/ucspi-tcp-0.88/getln2.c ucspi-tcp-0.88/getln2.c
--- tmp/ucspi-tcp-0.88/getln2.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/getln2.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,24 +1,44 @@
+/*
+ * $Log: getln2.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "byte.h"
 #include "getln.h"
 
-int getln2(buffer *ss,stralloc *sa,char **cont,unsigned int *clen,int sep)
+int
+getln2(buffer * ss, stralloc * sa, char **cont, unsigned int *clen, int sep)
 {
-  register char *x;
-  register unsigned int i;
-  int n;
- 
-  if (!stralloc_ready(sa,0)) return -1;
-  sa->len = 0;
- 
-  for (;;) {
-    n = buffer_feed(ss);
-    if (n < 0) return -1;
-    if (n == 0) { *clen = 0; return 0; }
-    x = buffer_PEEK(ss);
-    i = byte_chr(x,n,sep);
-    if (i < n) { buffer_SEEK(ss,*clen = i + 1); *cont = x; return 0; }
-    if (!stralloc_readyplus(sa,n)) return -1;
-    i = sa->len;
-    sa->len = i + buffer_get(ss,sa->s + i,n);
-  }
+	register char  *x;
+	register unsigned int i;
+	int             n;
+
+	if (!stralloc_ready(sa, 0))
+		return -1;
+	sa->len = 0;
+
+	for (;;)
+	{
+		n = buffer_feed(ss);
+		if (n < 0)
+			return -1;
+		if (n == 0)
+		{
+			*clen = 0;
+			return 0;
+		}
+		x = buffer_PEEK(ss);
+		i = byte_chr(x, n, sep);
+		if (i < n)
+		{
+			buffer_SEEK(ss, *clen = i + 1);
+			*cont = x;
+			return 0;
+		}
+		if (!stralloc_readyplus(sa, n))
+			return -1;
+		i = sa->len;
+		sa->len = i + buffer_get(ss, sa->s + i, n);
+	}
 }
diff -Naur tmp/ucspi-tcp-0.88/getln.c ucspi-tcp-0.88/getln.c
--- tmp/ucspi-tcp-0.88/getln.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/getln.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,14 +1,27 @@
+/*
+ * $Log: getln.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "byte.h"
 #include "getln.h"
 
-int getln(buffer *ss,stralloc *sa,int *match,int sep)
+int
+getln(buffer *ss, stralloc *sa, int *match, int sep)
 {
-  char *cont;
-  unsigned int clen;
+	char           *cont;
+	unsigned int    clen;
 
-  if (getln2(ss,sa,&cont,&clen,sep) == -1) return -1;
-  if (!clen) { *match = 0; return 0; }
-  if (!stralloc_catb(sa,cont,clen)) return -1;
-  *match = 1;
-  return 0;
+	if (getln2(ss, sa, &cont, &clen, sep) == -1)
+		return -1;
+	if (!clen)
+	{
+		*match = 0;
+		return 0;
+	}
+	if (!stralloc_catb(sa, cont, clen))
+		return -1;
+	*match = 1;
+	return 0;
 }
diff -Naur tmp/ucspi-tcp-0.88/getln.h ucspi-tcp-0.88/getln.h
--- tmp/ucspi-tcp-0.88/getln.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/getln.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,10 +1,19 @@
+/*
+ * $Log: getln.h,v $
+ * Revision 1.2  2005-05-13 23:45:33+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef GETLN_H
 #define GETLN_H
 
 #include "buffer.h"
 #include "stralloc.h"
 
-extern int getln(buffer *,stralloc *,int *,int);
-extern int getln2(buffer *,stralloc *,char **,unsigned int *,int);
+int             getln(buffer *, stralloc *, int *, int);
+int             getln2(buffer *, stralloc *, char **, unsigned int *, int);
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/.gitignore ucspi-tcp-0.88/.gitignore
--- tmp/ucspi-tcp-0.88/.gitignore	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/.gitignore	2009-09-22 01:53:01.072070845 +0530
@@ -0,0 +1,35 @@
+auto-str
+auto_home.c
+chkshsgr
+choose
+compile
+conf-home
+date@
+finger@
+hasmysql.h
+hassgact.h
+hassgprm.h
+hasshsgr.h
+haswaitp.h
+haveip6.h
+http@
+instcheck
+iopause.h
+load
+makelib
+mconnect
+mconnect-io
+mysql_config
+rblsmtpd
+rts
+select.h
+setup
+systype
+tcpcat
+tcpclient
+tcprules
+tcprulescheck
+tcpserver
+uint32.h
+uint64.h
+who@
diff -Naur tmp/ucspi-tcp-0.88/hasmysql.h1 ucspi-tcp-0.88/hasmysql.h1
--- tmp/ucspi-tcp-0.88/hasmysql.h1	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/hasmysql.h1	2008-07-30 11:47:38.000000000 +0530
@@ -0,0 +1 @@
+/* mysql: -libs, include */
diff -Naur tmp/ucspi-tcp-0.88/hasmysql.h2 ucspi-tcp-0.88/hasmysql.h2
--- tmp/ucspi-tcp-0.88/hasmysql.h2	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/hasmysql.h2	2008-07-30 11:46:44.000000000 +0530
@@ -0,0 +1 @@
+#define HAS_MYSQL 1
diff -Naur tmp/ucspi-tcp-0.88/haveip6.h1 ucspi-tcp-0.88/haveip6.h1
--- tmp/ucspi-tcp-0.88/haveip6.h1	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/haveip6.h1	2005-06-09 22:26:02.000000000 +0530
@@ -0,0 +1 @@
+
diff -Naur tmp/ucspi-tcp-0.88/haveip6.h2 ucspi-tcp-0.88/haveip6.h2
--- tmp/ucspi-tcp-0.88/haveip6.h2	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/haveip6.h2	2005-06-09 22:26:02.000000000 +0530
@@ -0,0 +1 @@
+#define LIBC_HAS_IP6 1
diff -Naur tmp/ucspi-tcp-0.88/hier.c ucspi-tcp-0.88/hier.c
--- tmp/ucspi-tcp-0.88/hier.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/hier.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,25 +1,61 @@
+/*
+ * $Log: hier.c,v $
+ * Revision 1.5  2008-06-30 09:39:14+05:30  Cprogrammer
+ * changed auto_home to auto_uspi_home
+ *
+ * Revision 1.4  2008-06-12 14:28:45+05:30  Cprogrammer
+ * changed perms of directories
+ *
+ * Revision 1.3  2005-06-03 09:07:01+05:30  Cprogrammer
+ * added creation of man page directory
+ *
+ * Revision 1.2  2005-05-13 23:33:02+05:30  Cprogrammer
+ * moved argv0, recordio, addcr, delcr, fixcrio to qmail
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "auto_home.h"
 
-void hier()
+void            h(char *, int, int, int);
+void            d(char *, char *, int, int, int);
+void            c(char *, char *, char *, int, int, int);
+
+char           *auto_ucspi_home = auto_home;
+
+void
+hier(inst_dir)
+	char           *inst_dir;
 {
-  h(auto_home,-1,-1,02755);
-  d(auto_home,"bin",-1,-1,02755);
+	if (inst_dir && *inst_dir)
+		auto_ucspi_home = inst_dir;
+	h(auto_ucspi_home, -1, -1, 0555);
+	d(auto_ucspi_home, "bin", -1, -1, 0555);
+	d(auto_ucspi_home, "man", -1, -1, 0555);
+	d(auto_ucspi_home, "man/man1", -1, -1, 0555);
 
-  c(auto_home,"bin","tcpserver",-1,-1,0755);
-  c(auto_home,"bin","tcprules",-1,-1,0755);
-  c(auto_home,"bin","tcprulescheck",-1,-1,0755);
-  c(auto_home,"bin","argv0",-1,-1,0755);
-  c(auto_home,"bin","recordio",-1,-1,0755);
-  c(auto_home,"bin","tcpclient",-1,-1,0755);
-  c(auto_home,"bin","who@",-1,-1,0755);
-  c(auto_home,"bin","date@",-1,-1,0755);
-  c(auto_home,"bin","finger@",-1,-1,0755);
-  c(auto_home,"bin","http@",-1,-1,0755);
-  c(auto_home,"bin","tcpcat",-1,-1,0755);
-  c(auto_home,"bin","mconnect",-1,-1,0755);
-  c(auto_home,"bin","mconnect-io",-1,-1,0755);
-  c(auto_home,"bin","addcr",-1,-1,0755);
-  c(auto_home,"bin","delcr",-1,-1,0755);
-  c(auto_home,"bin","fixcrio",-1,-1,0755);
-  c(auto_home,"bin","rblsmtpd",-1,-1,0755);
+	c(auto_ucspi_home, "bin", "tcpserver", -1, -1, 0755);
+	c(auto_ucspi_home, "bin", "tcprules", -1, -1, 0755);
+	c(auto_ucspi_home, "bin", "tcprulescheck", -1, -1, 0755);
+	c(auto_ucspi_home, "bin", "tcpclient", -1, -1, 0755);
+	c(auto_ucspi_home, "bin", "who@", -1, -1, 0755);
+	c(auto_ucspi_home, "bin", "date@", -1, -1, 0755);
+	c(auto_ucspi_home, "bin", "finger@", -1, -1, 0755);
+	c(auto_ucspi_home, "bin", "http@", -1, -1, 0755);
+	c(auto_ucspi_home, "bin", "tcpcat", -1, -1, 0755);
+	c(auto_ucspi_home, "bin", "mconnect", -1, -1, 0755);
+	c(auto_ucspi_home, "bin", "mconnect-io", -1, -1, 0755);
+	c(auto_ucspi_home, "bin", "rblsmtpd", -1, -1, 0755);
+	c(auto_ucspi_home, "man/man1", "tcpserver.1", -1, -1, 0644);
+	c(auto_ucspi_home, "man/man1", "tcprules.1", -1, -1, 0644);
+	c(auto_ucspi_home, "man/man1", "tcprulescheck.1", -1, -1, 0644);
+	c(auto_ucspi_home, "man/man1", "tcpclient.1", -1, -1, 0644);
+	c(auto_ucspi_home, "man/man1", "who@.1", -1, -1, 0644);
+	c(auto_ucspi_home, "man/man1", "date@.1", -1, -1, 0644);
+	c(auto_ucspi_home, "man/man1", "finger@.1", -1, -1, 0644);
+	c(auto_ucspi_home, "man/man1", "http@.1", -1, -1, 0644);
+	c(auto_ucspi_home, "man/man1", "tcpcat.1", -1, -1, 0644);
+	c(auto_ucspi_home, "man/man1", "mconnect.1", -1, -1, 0644);
+	c(auto_ucspi_home, "man/man1", "rblsmtpd.1", -1, -1, 0644);
 }
diff -Naur tmp/ucspi-tcp-0.88/http@.1 ucspi-tcp-0.88/http@.1
--- tmp/ucspi-tcp-0.88/http@.1	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/http@.1	2000-11-16 17:06:19.000000000 +0530
@@ -0,0 +1,68 @@
+.TH http@ 1
+.SH NAME
+http@ \- gets a web page from a remote host.
+.SH SYNOPSIS
+.B http@
+[
+.I host
+[
+.I page
+[
+.I port
+]
+]
+]
+.SH DESCRIPTION
+.B http@
+connects to
+.I port
+on
+.IR host ,
+sends
+.IP
+GET
+.I /page
+HTTP/1.0
+
+Host: host
+.P
+to
+.IR host ,
+and prints the contents of the response, removing CR from the end of each
+line. 
+
+If
+.I port
+is not supplied,
+.B http@
+uses TCP port 80 (HTTP). 
+
+If
+.I page
+is not supplied,
+.B http@
+asks for / from
+.IR host .
+
+If
+.I host
+is not supplied,
+.B http@
+connects to the local host. 
+.SH SEE ALSO
+tcpserver(1),
+tcprules(1),
+tcprulescheck(1),
+argv0(1),
+fixcrio(1),
+recordio(1),
+rblsmtpd(1),
+tcpclient(1),
+who@(1),
+date@(1),
+finger@(1),
+tcpcat(1),
+mconnect(1),
+tcp-environ(5)
+
+http://cr.yp.to/ucspi-tcp.html
diff -Naur tmp/ucspi-tcp-0.88/http@.sh ucspi-tcp-0.88/http@.sh
--- tmp/ucspi-tcp-0.88/http@.sh	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/http@.sh	2008-07-27 18:43:05.000000000 +0530
@@ -1,3 +1,9 @@
+#
+# $Log: http@.sh,v $
+# Revision 1.1  2003-12-31 19:57:58+05:30  Cprogrammer
+# Initial revision
+#
+#
 echo "GET /${2-} HTTP/1.0
 Host: ${1-0}:${3-80}
 " | HOME/bin/tcpclient -RHl0 -- "${1-0}" "${3-80}" sh -c '
diff -Naur tmp/ucspi-tcp-0.88/install.c ucspi-tcp-0.88/install.c
--- tmp/ucspi-tcp-0.88/install.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/install.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,149 +0,0 @@
-#include "buffer.h"
-#include "strerr.h"
-#include "error.h"
-#include "open.h"
-#include "readwrite.h"
-#include "exit.h"
-
-extern void hier();
-
-#define FATAL "install: fatal: "
-
-int fdsourcedir = -1;
-
-void h(home,uid,gid,mode)
-char *home;
-int uid;
-int gid;
-int mode;
-{
-  if (mkdir(home,0700) == -1)
-    if (errno != error_exist)
-      strerr_die4sys(111,FATAL,"unable to mkdir ",home,": ");
-  if (chown(home,uid,gid) == -1)
-    strerr_die4sys(111,FATAL,"unable to chown ",home,": ");
-  if (chmod(home,mode) == -1)
-    strerr_die4sys(111,FATAL,"unable to chmod ",home,": ");
-}
-
-void d(home,subdir,uid,gid,mode)
-char *home;
-char *subdir;
-int uid;
-int gid;
-int mode;
-{
-  if (chdir(home) == -1)
-    strerr_die4sys(111,FATAL,"unable to switch to ",home,": ");
-  if (mkdir(subdir,0700) == -1)
-    if (errno != error_exist)
-      strerr_die6sys(111,FATAL,"unable to mkdir ",home,"/",subdir,": ");
-  if (chown(subdir,uid,gid) == -1)
-    strerr_die6sys(111,FATAL,"unable to chown ",home,"/",subdir,": ");
-  if (chmod(subdir,mode) == -1)
-    strerr_die6sys(111,FATAL,"unable to chmod ",home,"/",subdir,": ");
-}
-
-char inbuf[BUFFER_INSIZE];
-char outbuf[BUFFER_OUTSIZE];
-buffer ssin;
-buffer ssout;
-
-void c(home,subdir,file,uid,gid,mode)
-char *home;
-char *subdir;
-char *file;
-int uid;
-int gid;
-int mode;
-{
-  int fdin;
-  int fdout;
-
-  if (fchdir(fdsourcedir) == -1)
-    strerr_die2sys(111,FATAL,"unable to switch back to source directory: ");
-
-  fdin = open_read(file);
-  if (fdin == -1)
-    strerr_die4sys(111,FATAL,"unable to read ",file,": ");
-  buffer_init(&ssin,read,fdin,inbuf,sizeof inbuf);
-
-  if (chdir(home) == -1)
-    strerr_die4sys(111,FATAL,"unable to switch to ",home,": ");
-  if (chdir(subdir) == -1)
-    strerr_die6sys(111,FATAL,"unable to switch to ",home,"/",subdir,": ");
-
-  fdout = open_trunc(file);
-  if (fdout == -1)
-    strerr_die6sys(111,FATAL,"unable to write .../",subdir,"/",file,": ");
-  buffer_init(&ssout,write,fdout,outbuf,sizeof outbuf);
-
-  switch(buffer_copy(&ssout,&ssin)) {
-    case -2:
-      strerr_die4sys(111,FATAL,"unable to read ",file,": ");
-    case -3:
-      strerr_die6sys(111,FATAL,"unable to write .../",subdir,"/",file,": ");
-  }
-
-  close(fdin);
-  if (buffer_flush(&ssout) == -1)
-    strerr_die6sys(111,FATAL,"unable to write .../",subdir,"/",file,": ");
-  if (fsync(fdout) == -1)
-    strerr_die6sys(111,FATAL,"unable to write .../",subdir,"/",file,": ");
-  if (close(fdout) == -1) /* NFS silliness */
-    strerr_die6sys(111,FATAL,"unable to write .../",subdir,"/",file,": ");
-
-  if (chown(file,uid,gid) == -1)
-    strerr_die6sys(111,FATAL,"unable to chown .../",subdir,"/",file,": ");
-  if (chmod(file,mode) == -1)
-    strerr_die6sys(111,FATAL,"unable to chmod .../",subdir,"/",file,": ");
-}
-
-void z(home,subdir,file,len,uid,gid,mode)
-char *home;
-char *subdir;
-char *file;
-int len;
-int uid;
-int gid;
-int mode;
-{
-  int fdout;
-
-  if (chdir(home) == -1)
-    strerr_die4sys(111,FATAL,"unable to switch to ",home,": ");
-  if (chdir(subdir) == -1)
-    strerr_die6sys(111,FATAL,"unable to switch to ",home,"/",subdir,": ");
-
-  fdout = open_trunc(file);
-  if (fdout == -1)
-    strerr_die6sys(111,FATAL,"unable to write .../",subdir,"/",file,": ");
-  buffer_init(&ssout,write,fdout,outbuf,sizeof outbuf);
-
-  while (len-- > 0)
-    if (buffer_put(&ssout,"",1) == -1)
-      strerr_die6sys(111,FATAL,"unable to write .../",subdir,"/",file,": ");
-
-  if (buffer_flush(&ssout) == -1)
-    strerr_die6sys(111,FATAL,"unable to write .../",subdir,"/",file,": ");
-  if (fsync(fdout) == -1)
-    strerr_die6sys(111,FATAL,"unable to write .../",subdir,"/",file,": ");
-  if (close(fdout) == -1) /* NFS silliness */
-    strerr_die6sys(111,FATAL,"unable to write .../",subdir,"/",file,": ");
-
-  if (chown(file,uid,gid) == -1)
-    strerr_die6sys(111,FATAL,"unable to chown .../",subdir,"/",file,": ");
-  if (chmod(file,mode) == -1)
-    strerr_die6sys(111,FATAL,"unable to chmod .../",subdir,"/",file,": ");
-}
-
-main()
-{
-  fdsourcedir = open_read(".");
-  if (fdsourcedir == -1)
-    strerr_die2sys(111,FATAL,"unable to open current directory: ");
-
-  umask(077);
-  hier();
-  _exit(0);
-}
diff -Naur tmp/ucspi-tcp-0.88/instcheck.c ucspi-tcp-0.88/instcheck.c
--- tmp/ucspi-tcp-0.88/instcheck.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/instcheck.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,108 +1,115 @@
+/*
+ * $Log: instcheck.c,v $
+ * Revision 1.3  2008-07-17 23:03:18+05:30  Cprogrammer
+ * use unistd.h instead of readwrite.h
+ *
+ * Revision 1.2  2008-06-30 09:39:35+05:30  Cprogrammer
+ * removed z()
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <unistd.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "strerr.h"
 #include "error.h"
-#include "readwrite.h"
 #include "exit.h"
 
-extern void hier();
+extern void     hier();
 
 #define FATAL "instcheck: fatal: "
 #define WARNING "instcheck: warning: "
 
-void perm(prefix1,prefix2,prefix3,file,type,uid,gid,mode)
-char *prefix1;
-char *prefix2;
-char *prefix3;
-char *file;
-int type;
-int uid;
-int gid;
-int mode;
-{
-  struct stat st;
-
-  if (stat(file,&st) == -1) {
-    if (errno == error_noent)
-      strerr_warn6(WARNING,prefix1,prefix2,prefix3,file," does not exist",0);
-    else
-      strerr_warn4(WARNING,"unable to stat .../",file,": ",&strerr_sys);
-    return;
-  }
-
-  if ((uid != -1) && (st.st_uid != uid))
-    strerr_warn6(WARNING,prefix1,prefix2,prefix3,file," has wrong owner",0);
-  if ((gid != -1) && (st.st_gid != gid))
-    strerr_warn6(WARNING,prefix1,prefix2,prefix3,file," has wrong group",0);
-  if ((st.st_mode & 07777) != mode)
-    strerr_warn6(WARNING,prefix1,prefix2,prefix3,file," has wrong permissions",0);
-  if ((st.st_mode & S_IFMT) != type)
-    strerr_warn6(WARNING,prefix1,prefix2,prefix3,file," has wrong type",0);
-}
-
-void h(home,uid,gid,mode)
-char *home;
-int uid;
-int gid;
-int mode;
-{
-  perm("","","",home,S_IFDIR,uid,gid,mode);
-}
-
-void d(home,subdir,uid,gid,mode)
-char *home;
-char *subdir;
-int uid;
-int gid;
-int mode;
-{
-  if (chdir(home) == -1)
-    strerr_die4sys(111,FATAL,"unable to switch to ",home,": ");
-  perm("",home,"/",subdir,S_IFDIR,uid,gid,mode);
-}
-
-void p(home,fifo,uid,gid,mode)
-char *home;
-char *fifo;
-int uid;
-int gid;
-int mode;
-{
-  if (chdir(home) == -1)
-    strerr_die4sys(111,FATAL,"unable to switch to ",home,": ");
-  perm("",home,"/",fifo,S_IFIFO,uid,gid,mode);
-}
-
-void c(home,subdir,file,uid,gid,mode)
-char *home;
-char *subdir;
-char *file;
-int uid;
-int gid;
-int mode;
-{
-  if (chdir(home) == -1)
-    strerr_die4sys(111,FATAL,"unable to switch to ",home,": ");
-  if (chdir(subdir) == -1)
-    strerr_die6sys(111,FATAL,"unable to switch to ",home,"/",subdir,": ");
-  perm(".../",subdir,"/",file,S_IFREG,uid,gid,mode);
-}
-
-void z(home,file,len,uid,gid,mode)
-char *home;
-char *file;
-int len;
-int uid;
-int gid;
-int mode;
-{
-  if (chdir(home) == -1)
-    strerr_die4sys(111,FATAL,"unable to switch to ",home,": ");
-  perm("",home,"/",file,S_IFREG,uid,gid,mode);
+void
+perm(prefix1, prefix2, prefix3, file, type, uid, gid, mode)
+	char           *prefix1;
+	char           *prefix2;
+	char           *prefix3;
+	char           *file;
+	int             type;
+	int             uid;
+	int             gid;
+	int             mode;
+{
+	struct stat     st;
+
+	if (stat(file, &st) == -1)
+	{
+		if (errno == error_noent)
+			strerr_warn6(WARNING, prefix1, prefix2, prefix3, file, " does not exist", 0);
+		else
+			strerr_warn4(WARNING, "unable to stat .../", file, ": ", &strerr_sys);
+		return;
+	}
+
+	if ((uid != -1) && (st.st_uid != uid))
+		strerr_warn6(WARNING, prefix1, prefix2, prefix3, file, " has wrong owner", 0);
+	if ((gid != -1) && (st.st_gid != gid))
+		strerr_warn6(WARNING, prefix1, prefix2, prefix3, file, " has wrong group", 0);
+	if ((st.st_mode & 07777) != mode)
+		strerr_warn6(WARNING, prefix1, prefix2, prefix3, file, " has wrong permissions", 0);
+	if ((st.st_mode & S_IFMT) != type)
+		strerr_warn6(WARNING, prefix1, prefix2, prefix3, file, " has wrong type", 0);
+}
+
+void
+h(home, uid, gid, mode)
+	char           *home;
+	int             uid;
+	int             gid;
+	int             mode;
+{
+	perm("", "", "", home, S_IFDIR, uid, gid, mode);
+}
+
+void
+d(home, subdir, uid, gid, mode)
+	char           *home;
+	char           *subdir;
+	int             uid;
+	int             gid;
+	int             mode;
+{
+	if (chdir(home) == -1)
+		strerr_die4sys(111, FATAL, "unable to switch to ", home, ": ");
+	perm("", home, "/", subdir, S_IFDIR, uid, gid, mode);
+}
+
+void
+p(home, fifo, uid, gid, mode)
+	char           *home;
+	char           *fifo;
+	int             uid;
+	int             gid;
+	int             mode;
+{
+	if (chdir(home) == -1)
+		strerr_die4sys(111, FATAL, "unable to switch to ", home, ": ");
+	perm("", home, "/", fifo, S_IFIFO, uid, gid, mode);
+}
+
+void
+c(home, subdir, file, uid, gid, mode)
+	char           *home;
+	char           *subdir;
+	char           *file;
+	int             uid;
+	int             gid;
+	int             mode;
+{
+	if (chdir(home) == -1)
+		strerr_die4sys(111, FATAL, "unable to switch to ", home, ": ");
+	if (chdir(subdir) == -1)
+		strerr_die6sys(111, FATAL, "unable to switch to ", home, "/", subdir, ": ");
+	perm(".../", subdir, "/", file, S_IFREG, uid, gid, mode);
 }
 
+int
 main()
 {
-  hier();
-  _exit(0);
+	hier();
+	_exit(0);
+	/*- Not reached */
 }
diff -Naur tmp/ucspi-tcp-0.88/iopause.c ucspi-tcp-0.88/iopause.c
--- tmp/ucspi-tcp-0.88/iopause.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/iopause.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,76 +1,102 @@
+/*
+ * $Log: iopause.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "taia.h"
 #include "select.h"
 #include "iopause.h"
 
-void iopause(iopause_fd *x,unsigned int len,struct taia *deadline,struct taia *stamp)
+void
+iopause(iopause_fd * x, unsigned int len, struct taia *deadline, struct taia *stamp)
 {
-  struct taia t;
-  int millisecs;
-  double d;
-  int i;
-
-  if (taia_less(deadline,stamp))
-    millisecs = 0;
-  else {
-    t = *stamp;
-    taia_sub(&t,deadline,&t);
-    d = taia_approx(&t);
-    if (d > 1000.0) d = 1000.0;
-    millisecs = d * 1000.0 + 20.0;
-  }
+	struct taia     t;
+	int             millisecs;
+	double          d;
+	int             i;
+
+	if (taia_less(deadline, stamp))
+		millisecs = 0;
+	else
+	{
+		t = *stamp;
+		taia_sub(&t, deadline, &t);
+		d = taia_approx(&t);
+		if (d > 1000.0)
+			d = 1000.0;
+		millisecs = d * 1000.0 + 20.0;
+	}
 
-  for (i = 0;i < len;++i)
-    x[i].revents = 0;
+	for (i = 0; i < len; ++i)
+		x[i].revents = 0;
 
 #ifdef IOPAUSE_POLL
 
-  poll(x,len,millisecs);
-  /* XXX: some kernels apparently need x[0] even if len is 0 */
-  /* XXX: how to handle EAGAIN? are kernels really this dumb? */
-  /* XXX: how to handle EINVAL? when exactly can this happen? */
+	poll(x, len, millisecs);
+	/*
+	 * XXX: some kernels apparently need x[0] even if len is 0 
+	 */
+	/*
+	 * XXX: how to handle EAGAIN? are kernels really this dumb? 
+	 */
+	/*
+	 * XXX: how to handle EINVAL? when exactly can this happen? 
+	 */
 
 #else
-{
+	{
 
-  struct timeval tv;
-  fd_set rfds;
-  fd_set wfds;
-  int nfds;
-  int fd;
-
-  FD_ZERO(&rfds);
-  FD_ZERO(&wfds);
-
-  nfds = 1;
-  for (i = 0;i < len;++i) {
-    fd = x[i].fd;
-    if (fd < 0) continue;
-    if (fd >= 8 * sizeof(fd_set)) continue; /*XXX*/
-
-    if (fd >= nfds) nfds = fd + 1;
-    if (x[i].events & IOPAUSE_READ) FD_SET(fd,&rfds);
-    if (x[i].events & IOPAUSE_WRITE) FD_SET(fd,&wfds);
-  }
-
-  tv.tv_sec = millisecs / 1000;
-  tv.tv_usec = 1000 * (millisecs % 1000);
-
-  if (select(nfds,&rfds,&wfds,(fd_set *) 0,&tv) <= 0)
-    return;
-    /* XXX: for EBADF, could seek out and destroy the bad descriptor */
-
-  for (i = 0;i < len;++i) {
-    fd = x[i].fd;
-    if (fd < 0) continue;
-    if (fd >= 8 * sizeof(fd_set)) continue; /*XXX*/
-
-    if (x[i].events & IOPAUSE_READ)
-      if (FD_ISSET(fd,&rfds)) x[i].revents |= IOPAUSE_READ;
-    if (x[i].events & IOPAUSE_WRITE)
-      if (FD_ISSET(fd,&wfds)) x[i].revents |= IOPAUSE_WRITE;
-  }
+		struct timeval  tv;
+		fd_set          rfds;
+		fd_set          wfds;
+		int             nfds;
+		int             fd;
+
+		FD_ZERO(&rfds);
+		FD_ZERO(&wfds);
+
+		nfds = 1;
+		for (i = 0; i < len; ++i)
+		{
+			fd = x[i].fd;
+			if (fd < 0)
+				continue;
+			if (fd >= 8 * sizeof(fd_set))
+				continue;
+			/*XXX*/ if (fd >= nfds)
+				nfds = fd + 1;
+			if (x[i].events & IOPAUSE_READ)
+				FD_SET(fd, &rfds);
+			if (x[i].events & IOPAUSE_WRITE)
+				FD_SET(fd, &wfds);
+		}
+
+		tv.tv_sec = millisecs / 1000;
+		tv.tv_usec = 1000 * (millisecs % 1000);
+
+		if (select(nfds, &rfds, &wfds, (fd_set *) 0, &tv) <= 0)
+			return;
+		/*
+		 * XXX: for EBADF, could seek out and destroy the bad descriptor 
+		 */
+
+		for (i = 0; i < len; ++i)
+		{
+			fd = x[i].fd;
+			if (fd < 0)
+				continue;
+			if (fd >= 8 * sizeof(fd_set))
+				continue;
+			/*XXX*/ if (x[i].events & IOPAUSE_READ)
+				if (FD_ISSET(fd, &rfds))
+					x[i].revents |= IOPAUSE_READ;
+			if (x[i].events & IOPAUSE_WRITE)
+				if (FD_ISSET(fd, &wfds))
+					x[i].revents |= IOPAUSE_WRITE;
+		}
 
-}
+	}
 #endif
 
 }
diff -Naur tmp/ucspi-tcp-0.88/ip4_fmt.c ucspi-tcp-0.88/ip4_fmt.c
--- tmp/ucspi-tcp-0.88/ip4_fmt.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/ip4_fmt.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,18 +1,43 @@
+/*
+ * $Log: ip4_fmt.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "fmt.h"
 #include "ip4.h"
 
-unsigned int ip4_fmt(char *s,char ip[4])
+unsigned int
+ip4_fmt(char *s, char ip[4])
 {
-  unsigned int len;
-  unsigned int i;
- 
-  len = 0;
-  i = fmt_ulong(s,(unsigned long) (unsigned char) ip[0]); len += i; if (s) s += i;
-  if (s) *s++ = '.'; ++len;
-  i = fmt_ulong(s,(unsigned long) (unsigned char) ip[1]); len += i; if (s) s += i;
-  if (s) *s++ = '.'; ++len;
-  i = fmt_ulong(s,(unsigned long) (unsigned char) ip[2]); len += i; if (s) s += i;
-  if (s) *s++ = '.'; ++len;
-  i = fmt_ulong(s,(unsigned long) (unsigned char) ip[3]); len += i; if (s) s += i;
-  return len;
+	unsigned int    len;
+	unsigned int    i;
+
+	len = 0;
+	i = fmt_ulong(s, (unsigned long) (unsigned char) ip[0]);
+	len += i;
+	if (s)
+		s += i;
+	if (s)
+		*s++ = '.';
+	++len;
+	i = fmt_ulong(s, (unsigned long) (unsigned char) ip[1]);
+	len += i;
+	if (s)
+		s += i;
+	if (s)
+		*s++ = '.';
+	++len;
+	i = fmt_ulong(s, (unsigned long) (unsigned char) ip[2]);
+	len += i;
+	if (s)
+		s += i;
+	if (s)
+		*s++ = '.';
+	++len;
+	i = fmt_ulong(s, (unsigned long) (unsigned char) ip[3]);
+	len += i;
+	if (s)
+		s += i;
+	return len;
 }
diff -Naur tmp/ucspi-tcp-0.88/ip4.h ucspi-tcp-0.88/ip4.h
--- tmp/ucspi-tcp-0.88/ip4.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/ip4.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,8 +1,21 @@
+/*
+ * $Log: ip4.h,v $
+ * Revision 1.3  2005-06-10 09:18:13+05:30  Cprogrammer
+ * added for ipv6 support
+ *
+ * Revision 1.2  2005-05-13 23:45:39+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef IP4_H
 #define IP4_H
 
-extern unsigned int ip4_scan(char *,char *);
-extern unsigned int ip4_fmt(char *,char *);
+extern char     ip4loopback[4]; /* = {127,0,0,1}; */
+unsigned int    ip4_scan(char *, char *);
+unsigned int    ip4_fmt(char *, char *);
 
 #define IP4_FMT 20
 
diff -Naur tmp/ucspi-tcp-0.88/ip4_scan.c ucspi-tcp-0.88/ip4_scan.c
--- tmp/ucspi-tcp-0.88/ip4_scan.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/ip4_scan.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,19 +1,55 @@
+/*
+ * $Log: ip4_scan.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "scan.h"
 #include "ip4.h"
 
-unsigned int ip4_scan(char *s,char ip[4])
+unsigned int
+ip4_scan(char *s, char ip[4])
 {
-  unsigned int i;
-  unsigned int len;
-  unsigned long u;
- 
-  len = 0;
-  i = scan_ulong(s,&u); if (!i) return 0; ip[0] = u; s += i; len += i;
-  if (*s != '.') return 0; ++s; ++len;
-  i = scan_ulong(s,&u); if (!i) return 0; ip[1] = u; s += i; len += i;
-  if (*s != '.') return 0; ++s; ++len;
-  i = scan_ulong(s,&u); if (!i) return 0; ip[2] = u; s += i; len += i;
-  if (*s != '.') return 0; ++s; ++len;
-  i = scan_ulong(s,&u); if (!i) return 0; ip[3] = u; s += i; len += i;
-  return len;
+	unsigned int    i;
+	unsigned int    len;
+	unsigned long   u;
+
+	len = 0;
+	i = scan_ulong(s, &u);
+	if (!i)
+		return 0;
+	ip[0] = u;
+	s += i;
+	len += i;
+	if (*s != '.')
+		return 0;
+	++s;
+	++len;
+	i = scan_ulong(s, &u);
+	if (!i)
+		return 0;
+	ip[1] = u;
+	s += i;
+	len += i;
+	if (*s != '.')
+		return 0;
+	++s;
+	++len;
+	i = scan_ulong(s, &u);
+	if (!i)
+		return 0;
+	ip[2] = u;
+	s += i;
+	len += i;
+	if (*s != '.')
+		return 0;
+	++s;
+	++len;
+	i = scan_ulong(s, &u);
+	if (!i)
+		return 0;
+	ip[3] = u;
+	s += i;
+	len += i;
+	return len;
 }
diff -Naur tmp/ucspi-tcp-0.88/ip6_fmt.c ucspi-tcp-0.88/ip6_fmt.c
--- tmp/ucspi-tcp-0.88/ip6_fmt.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/ip6_fmt.c	2008-07-27 18:41:45.000000000 +0530
@@ -0,0 +1,95 @@
+/*
+ * $Log: ip6_fmt.c,v $
+ * Revision 1.2  2005-06-10 12:10:40+05:30  Cprogrammer
+ * conditional ipv6 support
+ *
+ * Revision 1.1  2005-06-10 09:04:24+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+#include "fmt.h"
+#include "byte.h"
+#include "ip4.h"
+#include "ip6.h"
+
+unsigned int
+ip6_fmt(char *s, char ip[16])
+{
+	unsigned int    len;
+	unsigned int    i;
+	unsigned int    temp;
+	unsigned int    compressing;
+	int             j;
+
+	len = 0;
+	compressing = 0;
+	for (j = 0; j < 16; j += 2)
+	{
+		if (j == 12 && ip6_isv4mapped(ip))
+		{
+			temp = ip4_fmt(s, ip + 12);
+			len += temp;
+			s += temp;
+			break;
+		}
+		temp = ((unsigned long) (unsigned char) ip[j] << 8) + (unsigned long) (unsigned char) ip[j + 1];
+		if (temp == 0)
+		{
+			if (!compressing)
+			{
+				compressing = 1;
+				if (j == 0)
+				{
+					*s = ':';
+					s += 1;
+					++len;
+				}
+			}
+		} else
+		{
+			if (compressing)
+			{
+				compressing = 0;
+				*s = ':';
+				s += 1;
+				++len;
+			}
+			i = fmt_xlong(s, temp);
+			len += i;
+			if (s)
+				s += i;
+			if (s && j < 14)
+				*s++ = ':';
+			++len;
+		}
+	}
+	if (s)
+		*s = 0;
+	return len;
+}
+
+static char
+tohex(char num)
+{
+	if (num < 10)
+		return num + '0';
+	else
+	if (num < 16)
+		return num - 10 + 'a';
+	else
+		return -1;
+}
+
+unsigned int
+ip6_fmt_flat(char *s, char ip[16])
+{
+	int             i;
+	for (i = 0; i < 16; i++)
+	{
+		*s++ = tohex((unsigned char) ip[i] >> 4);
+		*s++ = tohex((unsigned char) ip[i] & 15);
+	}
+	return 32;
+}
+#endif
diff -Naur tmp/ucspi-tcp-0.88/ip6.h ucspi-tcp-0.88/ip6.h
--- tmp/ucspi-tcp-0.88/ip6.h	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/ip6.h	2008-07-27 18:41:52.000000000 +0530
@@ -0,0 +1,33 @@
+/*
+ * $Log: ip6.h,v $
+ * Revision 1.1  2005-06-10 12:12:12+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifndef IP6_H
+#define IP6_H
+
+#include "byte.h"
+
+unsigned int    ip6_scan(char *, char *);
+unsigned int    ip6_fmt(char *, char *);
+unsigned int    scan_ip6_flat(char *src, char *);
+unsigned int    fmt_ip6_flat(char *dest, char *);
+
+/*
+ * ip6 address syntax: (h = hex digit), no leading '0' required
+ * 1. hhhh:hhhh:hhhh:hhhh:hhhh:hhhh:hhhh:hhhh
+ * 2. any number of 0000 may be abbreviated as "::", but only once
+ * flat ip6 address syntax:
+ * hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
+ */
+
+#define IP6_FMT 40
+
+extern unsigned char V4mappedprefix[12]; /*- ={0,0,0,0,0,0,0,0,0,0,0xff,0xff}; */
+extern unsigned char V6loopback[16]; /*- ={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1}; */
+extern unsigned char V6any[16];	/*- ={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; */
+
+#define ip6_isv4mapped(ip) (byte_equal(ip,12,V4mappedprefix))
+
+#endif
diff -Naur tmp/ucspi-tcp-0.88/ip6_scan.c ucspi-tcp-0.88/ip6_scan.c
--- tmp/ucspi-tcp-0.88/ip6_scan.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/ip6_scan.c	2008-09-17 09:33:01.000000000 +0530
@@ -0,0 +1,120 @@
+/*
+ * $Log: ip6_scan.c,v $
+ * Revision 1.2  2008-09-17 09:32:49+05:30  Cprogrammer
+ * corrections for ip4_scan()
+ *
+ * Revision 1.1  2005-06-10 12:12:45+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+#include "scan.h"
+#include "ip4.h"
+#include "ip6.h"
+
+/*
+ * IPv6 addresses are really ugly to parse.
+ * Syntax: (h = hex digit)
+ *   1. hhhh:hhhh:hhhh:hhhh:hhhh:hhhh:hhhh:hhhh
+ *   2. any number of 0000 may be abbreviated as "::", but only once
+ *   3. The last two words may be written as IPv4 address
+ */
+
+unsigned int
+ip6_scan(char *s, char ip[16])
+{
+	unsigned int    i;
+	unsigned int    len = 0;
+	unsigned long   u;
+
+	char            suffix[16];
+	int             prefixlen = 0;
+	int             suffixlen = 0;
+
+	if ((i = ip4_scan((char *) s, ip + 12)))
+	{
+		unsigned char *c = V4mappedprefix;
+		if (byte_equal((char *) ip + 12, 4, (char *) V6any))
+			c = V6any;
+		for (len = 0; len < 12; ++len)
+			ip[len]= c[len];
+		return i;
+	}
+	for (i = 0; i < 16; i++)
+		ip[i] = 0;
+	for (;;)
+	{
+		if (*s == ':')
+		{
+			len++;
+			if (s[1] == ':')
+			{					/*
+								 * Found "::", skip to part 2 
+								 */
+				s += 2;
+				len++;
+				break;
+			}
+			s++;
+		}
+		if (!(i = scan_xlong((char *) s, &u)))
+			return 0;
+		if (prefixlen == 12 && s[i] == '.')
+		{
+			/*
+			 * the last 4 bytes may be written as IPv4 address 
+			 */
+			if ((i = ip4_scan((char *) s, ip + 12)))
+				return i + len;
+			else
+				return 0;
+		}
+		ip[prefixlen++] = (u >> 8);
+		ip[prefixlen++] = (u & 255);
+		s += i;
+		len += i;
+		if (prefixlen == 16)
+			return len;
+	}
+	/*
+	 * part 2, after "::" 
+	 */
+	for (;;)
+	{
+		if (*s == ':')
+		{
+			if (suffixlen == 0)
+				break;
+			s++;
+			len++;
+		} else
+		if (suffixlen != 0)
+			break;
+		if (!(i = scan_xlong((char *) s, &u)))
+		{
+			len--;
+			break;
+		}
+		if (suffixlen + prefixlen <= 12 && s[i] == '.')
+		{
+			int             j = ip4_scan((char *) s, suffix + suffixlen);
+			if (j)
+			{
+				suffixlen += 4;
+				len += j;
+				break;
+			} else
+				prefixlen = 12 - suffixlen;	/*- make end-of-loop test true */
+		}
+		suffix[suffixlen++] = (u >> 8);
+		suffix[suffixlen++] = (u & 255);
+		s += i;
+		len += i;
+		if (prefixlen + suffixlen == 16)
+			break;
+	}
+	for (i = 0; i < suffixlen; i++)
+		ip[16 - suffixlen + i] = suffix[i];
+	return len;
+}
+#endif
diff -Naur tmp/ucspi-tcp-0.88/Makefile ucspi-tcp-0.88/Makefile
--- tmp/ucspi-tcp-0.88/Makefile	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/Makefile	2009-08-12 09:01:39.539064723 +0530
@@ -1,17 +1,17 @@
 # Don't edit Makefile! Use conf-* for configuration.
-
 SHELL=/bin/sh
+OPENSSLBIN=openssl
+SSLINCS=-I/usr/kerberos/include
+INDIDIR := $(shell head -1 conf-home 2>/dev/null || echo "/var/indimail")
+DEFS := $(shell uname -s | tr "[:lower:]" "[:upper:]")
+SYSTEM :=  $(shell uname -s)
+mysql_libs = $(shell sh ./mysql_libs $(DEFS))
+mysql_inc  = $(shell ./mysql_config --include)
+SSLLIBS := -lssl -lcrypto
+#SSLLIBS := `if test $(SYSTEM) = Darwin ; then echo "-lssl -lcrypto" ; else echo "-lssl" ; fi`
 
 default: it
 
-addcr: \
-load addcr.o unix.a byte.a
-	./load addcr unix.a byte.a 
-
-addcr.o: \
-compile addcr.c buffer.h exit.h
-	./compile addcr.c
-
 alloc.o: \
 compile alloc.c alloc.h error.h
 	./compile alloc.c
@@ -20,20 +20,12 @@
 compile alloc_re.c alloc.h byte.h
 	./compile alloc_re.c
 
-argv0: \
-load argv0.o unix.a byte.a
-	./load argv0 unix.a byte.a 
-
-argv0.o: \
-compile argv0.c pathexec.h strerr.h
-	./compile argv0.c
-
 auto-str: \
 load auto-str.o unix.a byte.a
 	./load auto-str unix.a byte.a 
 
 auto-str.o: \
-compile auto-str.c buffer.h readwrite.h exit.h
+compile auto-str.c buffer.h exit.h
 	./compile auto-str.c
 
 auto_home.c: \
@@ -49,15 +41,15 @@
 	./compile buffer.c
 
 buffer_0.o: \
-compile buffer_0.c readwrite.h buffer.h
+compile buffer_0.c buffer.h
 	./compile buffer_0.c
 
 buffer_1.o: \
-compile buffer_1.c readwrite.h buffer.h
+compile buffer_1.c buffer.h
 	./compile buffer_1.c
 
 buffer_2.o: \
-compile buffer_2.c readwrite.h buffer.h
+compile buffer_2.c buffer.h
 	./compile buffer_2.c
 
 buffer_copy.o: \
@@ -75,13 +67,15 @@
 byte.a: \
 makelib byte_chr.o byte_copy.o byte_cr.o byte_diff.o byte_rchr.o \
 byte_zero.o case_diffb.o case_diffs.o fmt_ulong.o ip4_fmt.o \
-ip4_scan.o scan_ulong.o str_chr.o str_diff.o str_len.o str_start.o \
-uint16_pack.o uint16_unpack.o uint32_pack.o uint32_unpack.o
+ip4_scan.o ip6_scan.o scan_ulong.o str_chr.o str_diff.o str_len.o str_start.o \
+uint16_pack.o uint16_unpack.o uint32_pack.o uint32_unpack.o \
+ip6_fmt.o scan_xlong.o fmt_xlong.o
 	./makelib byte.a byte_chr.o byte_copy.o byte_cr.o \
 	byte_diff.o byte_rchr.o byte_zero.o case_diffb.o \
-	case_diffs.o fmt_ulong.o ip4_fmt.o ip4_scan.o scan_ulong.o \
+	case_diffs.o fmt_ulong.o ip4_fmt.o ip4_scan.o ip6_scan.o scan_ulong.o \
 	str_chr.o str_diff.o str_len.o str_start.o uint16_pack.o \
-	uint16_unpack.o uint32_pack.o uint32_unpack.o
+	uint16_unpack.o uint32_pack.o uint32_unpack.o \
+	ip6_fmt.o scan_xlong.o fmt_xlong.o
 
 byte_chr.o: \
 compile byte_chr.c byte.h
@@ -120,7 +114,7 @@
 	./makelib cdb.a cdb.o cdb_hash.o cdb_make.o
 
 cdb.o: \
-compile cdb.c readwrite.h error.h seek.h byte.h cdb.h uint32.h
+compile cdb.c error.h seek.h byte.h cdb.h uint32.h
 	./compile cdb.c
 
 cdb_hash.o: \
@@ -128,7 +122,7 @@
 	./compile cdb_hash.c
 
 cdb_make.o: \
-compile cdb_make.c readwrite.h seek.h error.h alloc.h cdb.h uint32.h \
+compile cdb_make.c seek.h error.h alloc.h cdb.h uint32.h \
 cdb_make.h buffer.h uint32.h
 	./compile cdb_make.c
 
@@ -151,6 +145,11 @@
 	> choose
 	chmod 755 choose
 
+tcpserver.1: tcpserver.9
+	cat tcpserver.9 \
+	| sed s}HOME}"`head -1 conf-home`"}g \
+	> tcpserver.1
+
 commands.o: \
 compile commands.c buffer.h stralloc.h gen_alloc.h str.h case.h \
 commands.h
@@ -159,7 +158,7 @@
 compile: \
 warn-auto.sh conf-cc
 	( cat warn-auto.sh; \
-	echo exec "`head -1 conf-cc`" '-c $${1+"$$@"}' \
+	echo exec "`head -1 conf-cc`" -D$(DEFS) '-c $${1+"$$@"}' \
 	) > compile
 	chmod 755 compile
 
@@ -170,18 +169,10 @@
 	> date@
 	chmod 755 date@
 
-delcr: \
-load delcr.o unix.a byte.a
-	./load delcr unix.a byte.a 
-
-delcr.o: \
-compile delcr.c buffer.h exit.h
-	./compile delcr.c
-
 dns.a: \
 makelib dns_dfd.o dns_domain.o dns_dtda.o dns_ip.o dns_ipq.o \
 dns_name.o dns_nd.o dns_packet.o dns_random.o dns_rcip.o dns_rcrw.o \
-dns_resolve.o dns_sortip.o dns_transmit.o dns_txt.o
+dns_resolve.o dns_sortip.o dns_transmit.o dns_txt.o 
 	./makelib dns.a dns_dfd.o dns_domain.o dns_dtda.o dns_ip.o \
 	dns_ipq.o dns_name.o dns_nd.o dns_packet.o dns_random.o \
 	dns_rcip.o dns_rcrw.o dns_resolve.o dns_sortip.o \
@@ -194,7 +185,7 @@
 
 dns_domain.o: \
 compile dns_domain.c error.h alloc.h case.h byte.h dns.h stralloc.h \
-gen_alloc.h iopause.h taia.h tai.h uint64.h taia.h
+gen_alloc.h iopause.h taia.h tai.h uint64.h haveip6.h
 	./compile dns_domain.c
 
 dns_dtda.o: \
@@ -204,23 +195,23 @@
 
 dns_ip.o: \
 compile dns_ip.c stralloc.h gen_alloc.h uint16.h byte.h dns.h \
-stralloc.h iopause.h taia.h tai.h uint64.h taia.h
-	./compile dns_ip.c
+stralloc.h iopause.h taia.h tai.h uint64.h taia.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` dns_ip.c
 
 dns_ipq.o: \
 compile dns_ipq.c stralloc.h gen_alloc.h case.h byte.h str.h dns.h \
-stralloc.h iopause.h taia.h tai.h uint64.h taia.h
-	./compile dns_ipq.c
+stralloc.h iopause.h taia.h tai.h uint64.h taia.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` dns_ipq.c
 
 dns_name.o: \
 compile dns_name.c stralloc.h gen_alloc.h uint16.h byte.h dns.h \
-stralloc.h iopause.h taia.h tai.h uint64.h taia.h
-	./compile dns_name.c
+stralloc.h iopause.h taia.h tai.h uint64.h ip6.h haveip6.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` dns_name.c
 
 dns_nd.o: \
 compile dns_nd.c byte.h fmt.h dns.h stralloc.h gen_alloc.h iopause.h \
-taia.h tai.h uint64.h taia.h
-	./compile dns_nd.c
+taia.h tai.h uint64.h taia.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` dns_nd.c
 
 dns_packet.o: \
 compile dns_packet.c error.h dns.h stralloc.h gen_alloc.h iopause.h \
@@ -234,31 +225,30 @@
 
 dns_rcip.o: \
 compile dns_rcip.c taia.h tai.h uint64.h openreadclose.h stralloc.h \
-gen_alloc.h byte.h ip4.h env.h dns.h stralloc.h iopause.h taia.h \
-taia.h
-	./compile dns_rcip.c
+gen_alloc.h byte.h ip4.h ip6.h env.h dns.h iopause.h haveip6.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` dns_rcip.c
 
 dns_rcrw.o: \
-compile dns_rcrw.c taia.h tai.h uint64.h env.h byte.h str.h \
+compile dns_rcrw.c taia.h tai.h env.h byte.h str.h \
 openreadclose.h stralloc.h gen_alloc.h dns.h stralloc.h iopause.h \
-taia.h taia.h
+haveip6.h
 	./compile dns_rcrw.c
 
 dns_resolve.o: \
-compile dns_resolve.c iopause.h taia.h tai.h uint64.h taia.h byte.h \
-dns.h stralloc.h gen_alloc.h iopause.h taia.h
-	./compile dns_resolve.c
+compile dns_resolve.c iopause.h taia.h tai.h uint64.h byte.h \
+dns.h stralloc.h gen_alloc.h iopause.h ip6.h haveip6.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` dns_resolve.c
 
 dns_sortip.o: \
 compile dns_sortip.c byte.h dns.h stralloc.h gen_alloc.h iopause.h \
-taia.h tai.h uint64.h taia.h
-	./compile dns_sortip.c
+taia.h tai.h uint64.h taia.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` dns_sortip.c
 
 dns_transmit.o: \
-compile dns_transmit.c socket.h uint16.h alloc.h error.h byte.h \
-readwrite.h uint16.h dns.h stralloc.h gen_alloc.h iopause.h taia.h \
-tai.h uint64.h taia.h
-	./compile dns_transmit.c
+compile dns_transmit.c socket.h alloc.h error.h byte.h \
+uint16.h dns.h stralloc.h gen_alloc.h iopause.h taia.h \
+tai.h uint32.h uint64.h taia.h conf-ip haveip6.h
+	./compile `grep -h -v "^#" conf-ip` dns_transmit.c
 
 dns_txt.o: \
 compile dns_txt.c stralloc.h gen_alloc.h uint16.h byte.h dns.h \
@@ -297,17 +287,15 @@
 	./load fixcrio time.a unix.a byte.a 
 
 fixcrio.o: \
-compile fixcrio.c sig.h buffer.h strerr.h byte.h readwrite.h exit.h \
-iopause.h taia.h tai.h uint64.h pathexec.h
+compile fixcrio.c sig.h buffer.h strerr.h byte.h exit.h \
+iopause.h taia.h tai.h uint64.h pathexec.h fd.h
 	./compile fixcrio.c
 
 fmt_ulong.o: \
 compile fmt_ulong.c fmt.h
 	./compile fmt_ulong.c
 
-fork.h: \
-choose compile load tryvfork.c fork.h1 fork.h2
-	./choose cl tryvfork fork.h1 fork.h2 > fork.h
+socket.h: haveip6.h
 
 getln.o: \
 compile getln.c byte.h getln.h buffer.h stralloc.h gen_alloc.h
@@ -317,6 +305,9 @@
 compile getln2.c byte.h getln.h buffer.h stralloc.h gen_alloc.h
 	./compile getln2.c
 
+hasmysql.h: \
+choose compile load mysql_config.c hasmysql.h1 hasmysql.h2
+	./choose R "./mysql_config --include" hasmysql.h1 hasmysql.h2 > hasmysql.h
 hassgact.h: \
 choose compile load trysgact.c hassgact.h1 hassgact.h2
 	./choose cl trysgact hassgact.h1 hassgact.h2 > hassgact.h
@@ -346,20 +337,20 @@
 	> http@
 	chmod 755 http@
 
-install: \
-load install.o hier.o auto_home.o unix.a byte.a
-	./load install hier.o auto_home.o unix.a byte.a 
-
-install.o: \
-compile install.c buffer.h strerr.h error.h open.h readwrite.h exit.h
-	./compile install.c
+setup: \
+load setup.o hier.o auto_home.o str_diffn.o unix.a byte.a
+	./load setup hier.o auto_home.o str_diffn.o unix.a byte.a 
+
+setup.o: \
+compile setup.c buffer.h strerr.h error.h open.h exit.h fmt.h str.h
+	./compile setup.c
 
 instcheck: \
 load instcheck.o hier.o auto_home.o unix.a byte.a
 	./load instcheck hier.o auto_home.o unix.a byte.a 
 
 instcheck.o: \
-compile instcheck.c strerr.h error.h readwrite.h exit.h
+compile instcheck.c strerr.h error.h exit.h
 	./compile instcheck.c
 
 iopause.h: \
@@ -379,15 +370,18 @@
 	./compile ip4_scan.c
 
 it: \
-prog install instcheck
+prog setup instcheck tcpserver.1
 
-load: \
-warn-auto.sh conf-ld
+load: warn-auto.sh conf-ld
 	( cat warn-auto.sh; \
 	echo 'main="$$1"; shift'; \
-	echo exec "`head -1 conf-ld`" \
-	'-o "$$main" "$$main".o $${1+"$$@"}' \
-	) > load
+	if test $(SYSTEM) = Darwin ; then \
+		echo exec "`head -1 conf-ld | sed s{-s{{`" \
+		'-o "$$main" "$$main".o $${1+"$$@"}'; \
+	else \
+		echo exec "`head -1 conf-ld`" \
+		'-o "$$main" "$$main".o $${1+"$$@"}'; \
+	fi) > load
 	chmod 755 load
 
 makelib: \
@@ -421,8 +415,8 @@
 	./load mconnect-io unix.a byte.a 
 
 mconnect-io.o: \
-compile mconnect-io.c sig.h wait.h fork.h buffer.h strerr.h \
-readwrite.h exit.h
+compile mconnect-io.c sig.h wait.h buffer.h strerr.h \
+exit.h
 	./compile mconnect-io.c
 
 ndelay_off.o: \
@@ -461,8 +455,8 @@
 	./compile pathexec_run.c
 
 prog: \
-tcpserver tcprules tcprulescheck argv0 recordio tcpclient who@ date@ \
-finger@ http@ tcpcat mconnect mconnect-io addcr delcr fixcrio \
+tcpserver tcprules tcprulescheck tcpclient who@ date@ \
+finger@ http@ tcpcat mconnect mconnect-io \
 rblsmtpd rts
 
 prot.o: \
@@ -476,30 +470,21 @@
 
 rblsmtpd.o: \
 compile rblsmtpd.c byte.h str.h scan.h fmt.h env.h exit.h sig.h \
-buffer.h readwrite.h sgetopt.h subgetopt.h strerr.h stralloc.h \
+buffer.h sgetopt.h subgetopt.h strerr.h stralloc.h \
 gen_alloc.h commands.h pathexec.h dns.h stralloc.h iopause.h taia.h \
-tai.h uint64.h taia.h
-	./compile rblsmtpd.c
+ip6.h tai.h uint64.h taia.h fd.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` rblsmtpd.c
 
 readclose.o: \
-compile readclose.c readwrite.h error.h readclose.h stralloc.h \
+compile readclose.c error.h readclose.h stralloc.h \
 gen_alloc.h
 	./compile readclose.c
 
-recordio: \
-load recordio.o time.a unix.a byte.a
-	./load recordio time.a unix.a byte.a 
-
-recordio.o: \
-compile recordio.c sig.h buffer.h strerr.h str.h byte.h readwrite.h \
-exit.h fmt.h iopause.h taia.h tai.h uint64.h pathexec.h
-	./compile recordio.c
-
-remoteinfo.o: \
-compile remoteinfo.c fmt.h buffer.h socket.h uint16.h error.h \
-iopause.h taia.h tai.h uint64.h timeoutconn.h uint16.h remoteinfo.h \
-stralloc.h gen_alloc.h uint16.h
-	./compile remoteinfo.c
+tcpremoteinfo.o: \
+compile tcpremoteinfo.c fmt.h buffer.h socket.h uint16.h error.h \
+iopause.h taia.h tai.h uint64.h timeoutconn.h tcpremoteinfo.h \
+stralloc.h gen_alloc.h uint32.h haveip6.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` tcpremoteinfo.c
 
 rts: \
 warn-auto.sh rts.sh conf-home
@@ -510,8 +495,8 @@
 
 rules.o: \
 compile rules.c alloc.h stralloc.h gen_alloc.h open.h cdb.h uint32.h \
-rules.h stralloc.h
-	./compile rules.c
+rules.h stralloc.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` rules.c
 
 scan_ulong.o: \
 compile scan_ulong.c scan.h
@@ -525,9 +510,12 @@
 choose compile trysysel.c select.h1 select.h2
 	./choose c trysysel select.h1 select.h2 > select.h
 
-setup: \
-it install
-	./install
+install-strip: install
+distclean: clean
+	/bin/rm -f conf-home
+
+install: it setup
+	./setup $(DESTDIR)$(INDIDIR)
 
 sgetopt.o: \
 compile sgetopt.c buffer.h sgetopt.h subgetopt.h subgetopt.h
@@ -557,16 +545,16 @@
 	rm -f trylsock.o trylsock
 
 socket_accept.o: \
-compile socket_accept.c byte.h socket.h uint16.h
-	./compile socket_accept.c
+compile socket_accept.c byte.h socket.h uint16.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_accept.c
 
 socket_bind.o: \
-compile socket_bind.c byte.h socket.h uint16.h
-	./compile socket_bind.c
+compile socket_bind.c byte.h socket.h uint16.h uint32.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_bind.c
 
 socket_conn.o: \
-compile socket_conn.c readwrite.h byte.h socket.h uint16.h
-	./compile socket_conn.c
+compile socket_conn.c byte.h socket.h uint16.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_conn.c
 
 socket_delay.o: \
 compile socket_delay.c socket.h uint16.h
@@ -577,24 +565,24 @@
 	./compile socket_listen.c
 
 socket_local.o: \
-compile socket_local.c byte.h socket.h uint16.h
-	./compile socket_local.c
+compile socket_local.c byte.h socket.h uint16.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_local.c
 
 socket_opts.o: \
 compile socket_opts.c socket.h uint16.h
 	./compile socket_opts.c
 
 socket_remote.o: \
-compile socket_remote.c byte.h socket.h uint16.h
-	./compile socket_remote.c
+compile socket_remote.c byte.h socket.h uint16.h uint32.h ip6.h haveip6.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_remote.c
 
 socket_tcp.o: \
-compile socket_tcp.c ndelay.h socket.h uint16.h
-	./compile socket_tcp.c
+compile socket_tcp.c ndelay.h socket.h uint16.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_tcp.c
 
 socket_udp.o: \
-compile socket_udp.c ndelay.h socket.h uint16.h
-	./compile socket_udp.c
+compile socket_udp.c ndelay.h socket.h uint16.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_udp.c
 
 str_chr.o: \
 compile str_chr.c str.h
@@ -604,6 +592,10 @@
 compile str_diff.c str.h
 	./compile str_diff.c
 
+str_diffn.o: \
+compile str_diffn.c str.h
+	./compile str_diffn.c
+
 str_len.o: \
 compile str_len.c str.h
 	./compile str_len.c
@@ -658,11 +650,13 @@
 compile subgetopt.c subgetopt.h
 	./compile subgetopt.c
 
-systype: \
-find-systype.sh conf-cc conf-ld trycpp.c x86cpuid.c
+systype: find-systype.sh conf-cc conf-ld trycpp.c x86cpuid.c
 	( cat warn-auto.sh; \
 	echo CC=\'`head -1 conf-cc`\'; \
-	echo LD=\'`head -1 conf-ld`\'; \
+	if test $(SYSTEM) = Darwin ; then \
+		echo LD=\'`head -1 conf-ld | sed s{-s{{`\'; \
+	else \
+		echo LD=\'`head -1 conf-ld`\'; fi ; \
 	cat find-systype.sh; \
 	) | sh > systype
 
@@ -710,18 +704,18 @@
 	chmod 755 tcpcat
 
 tcpclient: \
-load tcpclient.o remoteinfo.o timeoutconn.o dns.a time.a unix.a \
-byte.a socket.lib
-	./load tcpclient remoteinfo.o timeoutconn.o dns.a time.a \
-	unix.a byte.a  `cat socket.lib`
+load tcpclient.o tcpremoteinfo.o timeoutconn.o \
+dns.a time.a unix.a byte.a socket.lib
+	./load tcpclient tcpremoteinfo.o timeoutconn.o \
+	dns.a time.a unix.a byte.a `cat socket.lib`
 
 tcpclient.o: \
 compile tcpclient.c sig.h exit.h sgetopt.h subgetopt.h uint16.h fmt.h \
 scan.h str.h ip4.h uint16.h socket.h uint16.h fd.h stralloc.h \
 gen_alloc.h buffer.h error.h strerr.h pathexec.h timeoutconn.h \
-uint16.h remoteinfo.h stralloc.h uint16.h dns.h stralloc.h iopause.h \
-taia.h tai.h uint64.h taia.h
-	./compile tcpclient.c
+uint16.h tcpremoteinfo.h stralloc.h uint16.h dns.h stralloc.h iopause.h \
+taia.h tai.h uint64.h ip6.h byte.h taia.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` tcpclient.c; \
 
 tcprules: \
 load tcprules.o cdb.a unix.a byte.a
@@ -729,8 +723,9 @@
 
 tcprules.o: \
 compile tcprules.c strerr.h stralloc.h gen_alloc.h getln.h buffer.h \
-stralloc.h buffer.h exit.h fmt.h byte.h cdb_make.h buffer.h uint32.h
-	./compile tcprules.c
+stralloc.h buffer.h exit.h fmt.h byte.h cdb_make.h buffer.h uint32.h \
+open.h scan.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` tcprules.c
 
 tcprulescheck: \
 load tcprulescheck.o rules.o cdb.a unix.a byte.a
@@ -742,19 +737,35 @@
 	./compile tcprulescheck.c
 
 tcpserver: \
-load tcpserver.o rules.o remoteinfo.o timeoutconn.o cdb.a dns.a \
-time.a unix.a byte.a socket.lib
-	./load tcpserver rules.o remoteinfo.o timeoutconn.o cdb.a \
-	dns.a time.a unix.a byte.a  `cat socket.lib`
+load tcpserver.o rules.o tcpremoteinfo.o timeoutconn.o \
+control.o str_diffn.o auto_home.o cdb.a dns.a time.a \
+unix.a byte.a socket.lib mysql_config
+	./load tcpserver rules.o tcpremoteinfo.o timeoutconn.o \
+	control.o str_diffn.o auto_home.o \
+	cdb.a dns.a time.a unix.a byte.a `cat socket.lib` \
+	$(SSLLIBS) \
+	$(mysql_libs)
 
 tcpserver.o: \
 compile tcpserver.c uint16.h str.h byte.h fmt.h scan.h ip4.h fd.h \
-exit.h env.h prot.h open.h wait.h readwrite.h stralloc.h gen_alloc.h \
+exit.h env.h prot.h open.h wait.h stralloc.h gen_alloc.h \
 alloc.h buffer.h error.h strerr.h sgetopt.h subgetopt.h pathexec.h \
-socket.h uint16.h ndelay.h remoteinfo.h stralloc.h uint16.h rules.h \
+socket.h uint32.h ndelay.h tcpremoteinfo.h stralloc.h rules.h \
 stralloc.h sig.h dns.h stralloc.h iopause.h taia.h tai.h uint64.h \
-taia.h
-	./compile tcpserver.c
+ip6.h conf-tls conf-ip haveip6.h conf-mysqlrules \
+mysql_config hasmysql.h
+	./compile $(SSLINCS) $(mysql_inc) \
+	`grep -h -v "^#" conf-tls conf-ip conf-mysqlrules` \
+	tcpserver.c
+
+mysql_config.o: compile mysql_config.c conf-mysqlrules
+	./compile `grep -h -v "^#" conf-mysqlrules` mysql_config.c
+mysql_config: load mysql_config.o
+	./load mysql_config
+
+control.o: \
+compile control.c buffer.h stralloc.h scan.h error.h open.h getln.h env.h control.h
+	./compile control.c
 
 time.a: \
 makelib iopause.o tai_pack.o taia_add.o taia_approx.o taia_frac.o \
@@ -765,8 +776,8 @@
 
 timeoutconn.o: \
 compile timeoutconn.c ndelay.h socket.h uint16.h iopause.h taia.h \
-tai.h uint64.h error.h timeoutconn.h uint16.h
-	./compile timeoutconn.c
+tai.h uint64.h error.h timeoutconn.h uint16.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` timeoutconn.c
 
 uint16_pack.o: \
 compile uint16_pack.c uint16.h
@@ -806,7 +817,11 @@
 socket_opts.o socket_remote.o socket_tcp.o socket_udp.o \
 stralloc_cat.o stralloc_catb.o stralloc_cats.o stralloc_copy.o \
 stralloc_eady.o stralloc_opyb.o stralloc_opys.o stralloc_pend.o \
-strerr_die.o strerr_sys.o subgetopt.o wait_nohang.o wait_pid.o
+strerr_die.o strerr_sys.o subgetopt.o wait_nohang.o wait_pid.o \
+socket_conn6.o socket_bind6.o socket_accept6.o socket_recv6.o \
+socket_send6.o socket_local6.o socket_tcp6.o \
+socket_getifname.o socket_getifidx.o socket_v4mappedprefix.o \
+socket_ip4loopback.o socket_v6any.o socket_v6loopback.o
 	./makelib unix.a alloc.o alloc_re.o buffer.o buffer_0.o \
 	buffer_1.o buffer_2.o buffer_copy.o buffer_get.o \
 	buffer_put.o env.o error.o error_str.o fd_copy.o fd_move.o \
@@ -819,7 +834,11 @@
 	socket_udp.o stralloc_cat.o stralloc_catb.o stralloc_cats.o \
 	stralloc_copy.o stralloc_eady.o stralloc_opyb.o \
 	stralloc_opys.o stralloc_pend.o strerr_die.o strerr_sys.o \
-	subgetopt.o wait_nohang.o wait_pid.o
+	subgetopt.o wait_nohang.o wait_pid.o socket_conn6.o \
+	socket_bind6.o socket_accept6.o socket_recv6.o socket_send6.o \
+	socket_local6.o socket_tcp6.o \
+	socket_getifname.o socket_getifidx.o socket_v4mappedprefix.o \
+	socket_ip4loopback.o socket_v6any.o socket_v6loopback.o
 
 wait_nohang.o: \
 compile wait_nohang.c haswaitp.h
@@ -829,9 +848,105 @@
 compile wait_pid.c error.h haswaitp.h
 	./compile wait_pid.c
 
+socket_conn6.o: \
+compile socket_conn6.c socket.h byte.h uint16.h uint32.h error.h \
+ip4.h ip6.h haveip6.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_conn6.c
+
+socket_bind6.o: \
+compile socket_bind6.c socket.h byte.h uint16.h error.h ip6.h \
+uint32.h haveip6.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_bind6.c
+
+socket_accept6.o: \
+compile socket_accept6.c socket.h byte.h uint16.h ip6.h \
+uint32.h haveip6.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_accept6.c
+
+socket_recv6.o: \
+compile socket_recv6.c socket.h byte.h uint16.h ip6.h \
+uint32.h haveip6.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_recv6.c
+
+socket_send6.o: \
+compile socket_send6.c socket.h byte.h uint16.h error.h uint32.h \
+ip4.h ip6.h haveip6.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_send6.c
+
+socket_local6.o: \
+compile socket_local6.c socket.h byte.h uint16.h haveip6.h uint32.h \
+ip6.h haveip6.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_local6.c
+
+fmt_xlong.o: \
+compile fmt_xlong.c scan.h
+	./compile fmt_xlong.c
+
+scan_xlong.o: \
+compile scan_xlong.c scan.h
+	./compile scan_xlong.c
+
+ip6_fmt.o: \
+compile ip6_fmt.c byte.h fmt.h ip4.h ip6.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` ip6_fmt.c
+
+ip6_scan.o: \
+compile ip6_scan.c scan.h ip4.h ip6.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` ip6_scan.c
+
+socket_tcp6.o: \
+compile socket_tcp6.c ndelay.h socket.h uint16.h uint32.h haveip6.h conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_tcp6.c
+
+haveip6.h: \
+choose tryip6.c compile haveip6.h1 haveip6.h2 conf-ip
+	./compile `grep -h -v "^#" conf-ip` tryip6.c; \
+	cc tryip6.o -o tryip6; \
+	./choose r tryip6 haveip6.h1 haveip6.h2 > haveip6.h
+
+socket_getifname.o: \
+compile socket_getifname.c socket.h uint16.h uint32.h haveip6.h
+	./compile socket_getifname.c
+
+socket_getifidx.o: \
+compile socket_getifidx.c socket.h uint16.h uint32.h haveip6.h
+	./compile socket_getifidx.c
+
+socket_ip4loopback.o: \
+compile socket_ip4loopback.c
+	./compile socket_ip4loopback.c
+
+socket_v4mappedprefix.o: \
+compile socket_v4mappedprefix.c conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_v4mappedprefix.c
+
+socket_v6any.o: \
+compile socket_v6any.c conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_v6any.c
+
+socket_v6loopback.o: \
+compile socket_v6loopback.c conf-ip
+	./compile `grep -h -v "^#" conf-ip` socket_v6loopback.c
+
 who@: \
 warn-auto.sh who@.sh conf-home
 	cat warn-auto.sh who@.sh \
 	| sed s}HOME}"`head -1 conf-home`"}g \
 	> who@
 	chmod 755 who@
+cert:
+	${OPENSSLBIN} req -new -x509 -nodes \
+	-out cert.pem -days 366 \
+	-keyout cert.pem
+
+cert-req:
+	${OPENSSLBIN} req -new -nodes \
+	-out req.pem \
+	-keyout cert.pem
+	@echo
+	@echo "Send req.pem to your CA to obtain signed_req.pem, and do:"
+	@echo "cat signed_req.pem >> `head -1 conf-home`/control/cert.pem"
+
+
+clean:
+	rm -f `cat TARGETS`
diff -Naur tmp/ucspi-tcp-0.88/mconnect.1 ucspi-tcp-0.88/mconnect.1
--- tmp/ucspi-tcp-0.88/mconnect.1	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/mconnect.1	2000-11-16 17:06:19.000000000 +0530
@@ -0,0 +1,46 @@
+.TH mconnect 1
+.SH NAME
+mconnect \- connects to a remote SMTP server.
+.SH SYNOPSIS
+.B mconnect
+[
+.I host
+[
+.I port
+]
+]
+.SH DESCRIPTION
+.B mconnect
+connects to
+.I port
+on
+.IR host .
+It sends its input to
+.IR host ,
+adding a CR to each line. Meanwhile it prints anything it receives from
+.IR host .
+
+If
+.I port
+is not supplied, mconnect uses port 25 (SMTP). 
+
+If
+.I host
+is not supplied, mconnect connects to the local host.
+.SH SEE ALSO
+tcpserver(1),
+tcprules(1),
+tcprulescheck(1),
+argv0(1),
+fixcrio(1),
+recordio(1),
+rblsmtpd(1),
+tcpclient(1),
+who@(1),
+date@(1),
+finger@(1),
+http@(1),
+tcpcat(1),
+tcp-environ(5)
+
+http://cr.yp.to/ucspi-tcp.html
diff -Naur tmp/ucspi-tcp-0.88/mconnect-io.c ucspi-tcp-0.88/mconnect-io.c
--- tmp/ucspi-tcp-0.88/mconnect-io.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/mconnect-io.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,53 +1,75 @@
+/*
+ * $Log: mconnect-io.c,v $
+ * Revision 1.4  2008-07-25 16:49:26+05:30  Cprogrammer
+ * fix for darwin
+ *
+ * Revision 1.3  2008-07-17 23:03:52+05:30  Cprogrammer
+ * removed readwrite.h
+ *
+ * Revision 1.2  2005-06-10 09:12:57+05:30  Cprogrammer
+ * removed fork.h
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "sig.h"
 #include "wait.h"
-#include "fork.h"
 #include "buffer.h"
 #include "strerr.h"
-#include "readwrite.h"
 #include "exit.h"
+#include <unistd.h>
+#include <signal.h>
 
-char outbuf[512];
-buffer bout;
+char            outbuf[512];
+buffer          bout;
 
-char inbuf[512];
-buffer bin;
+char            inbuf[512];
+buffer          bin;
 
-int myread(int fd,char *buf,int len)
+ssize_t
+myread(int fd, char *buf, int len)
 {
-  buffer_flush(&bout);
-  return read(fd,buf,len);
+	buffer_flush(&bout);
+	return read(fd, buf, len);
 }
 
+int
 main()
 {
-  int pid;
-  int wstat;
-  char ch;
+	int             pid;
+	int             wstat;
+	char            ch;
+
+	sig_ignore(sig_pipe);
+
+	pid = fork();
+	if (pid == -1)
+		strerr_die2sys(111, "mconnect-io: fatal: ", "unable to fork: ");
+
+	if (!pid)
+	{
+		buffer_init(&bin, myread, 0, inbuf, sizeof inbuf);
+		buffer_init(&bout, write, 7, outbuf, sizeof outbuf);
+
+		while (buffer_get(&bin, &ch, 1) == 1)
+		{
+			if (ch == '\n')
+				buffer_put(&bout, "\r", 1);
+			buffer_put(&bout, &ch, 1);
+		}
+		_exit(0);
+	}
+
+	buffer_init(&bin, myread, 6, inbuf, sizeof inbuf);
+	buffer_init(&bout, write, 1, outbuf, sizeof outbuf);
 
-  sig_ignore(sig_pipe);
+	while (buffer_get(&bin, &ch, 1) == 1)
+		buffer_put(&bout, &ch, 1);
 
-  pid = fork();
-  if (pid == -1) strerr_die2sys(111,"mconnect-io: fatal: ","unable to fork: ");
+	kill(pid, sig_term);
+	wait_pid(&wstat, pid);
 
-  if (!pid) {
-    buffer_init(&bin,myread,0,inbuf,sizeof inbuf);
-    buffer_init(&bout,write,7,outbuf,sizeof outbuf);
-
-    while (buffer_get(&bin,&ch,1) == 1) {
-      if (ch == '\n') buffer_put(&bout,"\r",1);
-      buffer_put(&bout,&ch,1);
-    }
-    _exit(0);
-  }
-
-  buffer_init(&bin,myread,6,inbuf,sizeof inbuf);
-  buffer_init(&bout,write,1,outbuf,sizeof outbuf);
-
-  while (buffer_get(&bin,&ch,1) == 1)
-    buffer_put(&bout,&ch,1);
-
-  kill(pid,sig_term);
-  wait_pid(&wstat,pid);
-
-  _exit(0);
+	_exit(0);
+	/*- Not reached */
 }
diff -Naur tmp/ucspi-tcp-0.88/mconnect.sh ucspi-tcp-0.88/mconnect.sh
--- tmp/ucspi-tcp-0.88/mconnect.sh	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/mconnect.sh	2008-07-27 18:43:10.000000000 +0530
@@ -1 +1,7 @@
+#
+# $Log: mconnect.sh,v $
+# Revision 1.1  2003-12-31 19:50:30+05:30  Cprogrammer
+# Initial revision
+#
+#
 exec HOME/bin/tcpclient -RHl0 -- "${1-0}" "${2-25}" HOME/bin/mconnect-io
diff -Naur tmp/ucspi-tcp-0.88/mysql_config.c ucspi-tcp-0.88/mysql_config.c
--- tmp/ucspi-tcp-0.88/mysql_config.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/mysql_config.c	2009-07-11 08:56:35.823940645 +0530
@@ -0,0 +1,18 @@
+/*
+ * $Log: mysql_config.c,v $
+ * Revision 1.2  2009-07-11 08:55:52+05:30  Cprogrammer
+ * use /usr/local/mysql as the first mysql prefix
+ *
+ */
+#include <unistd.h>
+
+int
+main(int argc, char **argv)
+{
+#ifdef MYSQL_CONFIG
+	if (!access("/usr/local/mysql/bin/mysql_config", X_OK))
+		execv("/usr/local/mysql/bin/mysql_config", argv);
+	execvp("mysql_config", argv);
+#endif
+	return(1);
+}
diff -Naur tmp/ucspi-tcp-0.88/mysql_libs ucspi-tcp-0.88/mysql_libs
--- tmp/ucspi-tcp-0.88/mysql_libs	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/mysql_libs	2009-02-15 19:34:59.000000000 +0530
@@ -0,0 +1,29 @@
+#!/bin/sh
+# $Log: mysql_libs,v $
+# Revision 1.3  2009-02-15 19:34:42+05:30  Cprogrammer
+# made finding libs configurable
+#
+#
+if [ $# -ne 1 ] ; then
+	exit 0
+fi
+mysql_libs=`./mysql_config --libs`
+if [ $? -ne 0 ] ; then
+	echo "-Werror"
+	exit 1
+fi
+case "$1" in
+	DARWIN)
+	;;
+	*)
+	pre1="-Xlinker -R -Xlinker"
+	echo $mysql_libs | grep rdynamic > /dev/null
+	if [ $? -eq 0 ] ; then
+		pre2=`echo $mysql_libs|awk '{print $2}'|sed s}-L}}g`
+	else
+		pre2=`echo $mysql_libs|awk '{print $1}'|sed s}-L}}g`
+	fi
+	pre="$pre1 $pre2"
+esac
+echo $pre $mysql_libs
+exit 0
diff -Naur tmp/ucspi-tcp-0.88/ndelay.h ucspi-tcp-0.88/ndelay.h
--- tmp/ucspi-tcp-0.88/ndelay.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/ndelay.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,7 +1,16 @@
+/*
+ * $Log: ndelay.h,v $
+ * Revision 1.2  2005-05-13 23:45:49+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef NDELAY_H
 #define NDELAY_H
 
-extern int ndelay_on(int);
-extern int ndelay_off(int);
+int             ndelay_on(int);
+int             ndelay_off(int);
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/ndelay_off.c ucspi-tcp-0.88/ndelay_off.c
--- tmp/ucspi-tcp-0.88/ndelay_off.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/ndelay_off.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,3 +1,9 @@
+/*
+ * $Log: ndelay_off.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <fcntl.h>
 #include "ndelay.h"
@@ -6,7 +12,8 @@
 #define O_NONBLOCK O_NDELAY
 #endif
 
-int ndelay_off(int fd)
+int
+ndelay_off(int fd)
 {
-  return fcntl(fd,F_SETFL,fcntl(fd,F_GETFL,0) & ~O_NONBLOCK);
+	return fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~O_NONBLOCK);
 }
diff -Naur tmp/ucspi-tcp-0.88/ndelay_on.c ucspi-tcp-0.88/ndelay_on.c
--- tmp/ucspi-tcp-0.88/ndelay_on.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/ndelay_on.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,3 +1,9 @@
+/*
+ * $Log: ndelay_on.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <fcntl.h>
 #include "ndelay.h"
@@ -6,7 +12,8 @@
 #define O_NONBLOCK O_NDELAY
 #endif
 
-int ndelay_on(int fd)
+int
+ndelay_on(int fd)
 {
-  return fcntl(fd,F_SETFL,fcntl(fd,F_GETFL,0) | O_NONBLOCK);
+	return fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);
 }
diff -Naur tmp/ucspi-tcp-0.88/open.h ucspi-tcp-0.88/open.h
--- tmp/ucspi-tcp-0.88/open.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/open.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,10 +1,19 @@
+/*
+ * $Log: open.h,v $
+ * Revision 1.2  2005-05-13 23:45:57+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef OPEN_H
 #define OPEN_H
 
-extern int open_read(char *);
-extern int open_excl(char *);
-extern int open_append(char *);
-extern int open_trunc(char *);
-extern int open_write(char *);
+int             open_read(char *);
+int             open_excl(char *);
+extern int      open_append(char *);
+int             open_trunc(char *);
+int             open_write(char *);
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/open_read.c ucspi-tcp-0.88/open_read.c
--- tmp/ucspi-tcp-0.88/open_read.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/open_read.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,6 +1,15 @@
+/*
+ * $Log: open_read.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <fcntl.h>
 #include "open.h"
 
-int open_read(char *fn)
-{ return open(fn,O_RDONLY | O_NDELAY); }
+int
+open_read(char *fn)
+{
+	return open(fn, O_RDONLY | O_NDELAY);
+}
diff -Naur tmp/ucspi-tcp-0.88/openreadclose.c ucspi-tcp-0.88/openreadclose.c
--- tmp/ucspi-tcp-0.88/openreadclose.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/openreadclose.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,16 +1,26 @@
+/*
+ * $Log: openreadclose.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "error.h"
 #include "open.h"
 #include "readclose.h"
 #include "openreadclose.h"
 
-int openreadclose(char *fn,stralloc *sa,unsigned int bufsize)
+int
+openreadclose(char *fn, stralloc * sa, unsigned int bufsize)
 {
-  int fd;
-  fd = open_read(fn);
-  if (fd == -1) {
-    if (errno == error_noent) return 0;
-    return -1;
-  }
-  if (readclose(fd,sa,bufsize) == -1) return -1;
-  return 1;
+	int             fd;
+	fd = open_read(fn);
+	if (fd == -1)
+	{
+		if (errno == error_noent)
+			return 0;
+		return -1;
+	}
+	if (readclose(fd, sa, bufsize) == -1)
+		return -1;
+	return 1;
 }
diff -Naur tmp/ucspi-tcp-0.88/openreadclose.h ucspi-tcp-0.88/openreadclose.h
--- tmp/ucspi-tcp-0.88/openreadclose.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/openreadclose.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,8 +1,17 @@
+/*
+ * $Log: openreadclose.h,v $
+ * Revision 1.2  2005-05-13 23:46:02+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef OPENREADCLOSE_H
 #define OPENREADCLOSE_H
 
 #include "stralloc.h"
 
-extern int openreadclose(char *,stralloc *,unsigned int);
+int             openreadclose(char *, stralloc *, unsigned int);
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/open_trunc.c ucspi-tcp-0.88/open_trunc.c
--- tmp/ucspi-tcp-0.88/open_trunc.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/open_trunc.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,6 +1,15 @@
+/*
+ * $Log: open_trunc.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <fcntl.h>
 #include "open.h"
 
-int open_trunc(char *fn)
-{ return open(fn,O_WRONLY | O_NDELAY | O_TRUNC | O_CREAT,0644); }
+int
+open_trunc(char *fn)
+{
+	return open(fn, O_WRONLY | O_NDELAY | O_TRUNC | O_CREAT, 0644);
+}
diff -Naur tmp/ucspi-tcp-0.88/open_write.c ucspi-tcp-0.88/open_write.c
--- tmp/ucspi-tcp-0.88/open_write.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/open_write.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,6 +1,15 @@
+/*
+ * $Log: open_write.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <fcntl.h>
 #include "open.h"
 
-int open_write(char *fn)
-{ return open(fn,O_WRONLY | O_NDELAY); }
+int
+open_write(char *fn)
+{
+	return open(fn, O_WRONLY | O_NDELAY);
+}
diff -Naur tmp/ucspi-tcp-0.88/pathexec_env.c ucspi-tcp-0.88/pathexec_env.c
--- tmp/ucspi-tcp-0.88/pathexec_env.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/pathexec_env.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,3 +1,12 @@
+/*
+ * $Log: pathexec_env.c,v $
+ * Revision 1.2  2003-12-30 00:32:36+05:30  Cprogrammer
+ * removed unused variable
+ *
+ * Revision 1.1  2003-10-21 11:23:08+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "stralloc.h"
 #include "alloc.h"
 #include "str.h"
@@ -8,61 +17,75 @@
 static stralloc plus;
 static stralloc tmp;
 
-int pathexec_env(char *s,char *t)
+int
+pathexec_env(char *s, char *t)
 {
-  if (!s) return 1;
-  if (!stralloc_copys(&tmp,s)) return 0;
-  if (t) {
-    if (!stralloc_cats(&tmp,"=")) return 0;
-    if (!stralloc_cats(&tmp,t)) return 0;
-  }
-  if (!stralloc_0(&tmp)) return 0;
-  return stralloc_cat(&plus,&tmp);
+	if (!s)
+		return 1;
+	if (!stralloc_copys(&tmp, s))
+		return 0;
+	if (t)
+	{
+		if (!stralloc_cats(&tmp, "="))
+			return 0;
+		if (!stralloc_cats(&tmp, t))
+			return 0;
+	}
+	if (!stralloc_0(&tmp))
+		return 0;
+	return stralloc_cat(&plus, &tmp);
 }
 
-void pathexec(char **argv)
+void
+pathexec(char **argv)
 {
-  char *path;
-  char **e;
-  unsigned int elen;
-  unsigned int i;
-  unsigned int j;
-  unsigned int split;
-  unsigned int t;
-
-  if (!stralloc_cats(&plus,"")) return;
-
-  elen = 0;
-  for (i = 0;environ[i];++i)
-    ++elen;
-  for (i = 0;i < plus.len;++i)
-    if (!plus.s[i])
-      ++elen;
-
-  e = (char **) alloc((elen + 1) * sizeof(char *));
-  if (!e) return;
-
-  elen = 0;
-  for (i = 0;environ[i];++i)
-    e[elen++] = environ[i];
-
-  j = 0;
-  for (i = 0;i < plus.len;++i)
-    if (!plus.s[i]) {
-      split = str_chr(plus.s + j,'=');
-      for (t = 0;t < elen;++t)
-	if (byte_equal(plus.s + j,split,e[t]))
-	  if (e[t][split] == '=') {
-	    --elen;
-	    e[t] = e[elen];
-	    break;
-	  }
-      if (plus.s[j + split])
-	e[elen++] = plus.s + j;
-      j = i + 1;
-    }
-  e[elen] = 0;
-
-  pathexec_run(*argv,argv,e);
-  alloc_free(e);
+	char          **e;
+	unsigned int    elen;
+	unsigned int    i;
+	unsigned int    j;
+	unsigned int    split;
+	unsigned int    t;
+
+	if (!stralloc_cats(&plus, ""))
+		return;
+
+	elen = 0;
+	for (i = 0; environ[i]; ++i)
+		++elen;
+	for (i = 0; i < plus.len; ++i)
+	{
+		if (!plus.s[i])
+			++elen;
+	}
+	if(!(e = (char **) alloc((elen + 1) * sizeof(char *))))
+		return;
+	elen = 0;
+	for (i = 0; environ[i]; ++i)
+		e[elen++] = environ[i];
+	j = 0;
+	for (i = 0; i < plus.len; ++i)
+	{
+		if (!plus.s[i])
+		{
+			split = str_chr(plus.s + j, '=');
+			for (t = 0; t < elen; ++t)
+			{
+				if (byte_equal(plus.s + j, split, e[t]))
+				{
+					if (e[t][split] == '=')
+					{
+						--elen;
+						e[t] = e[elen];
+						break;
+					}
+				}
+			}
+			if (plus.s[j + split])
+				e[elen++] = plus.s + j;
+			j = i + 1;
+		}
+	}
+	e[elen] = 0;
+	pathexec_run(*argv, argv, e);
+	alloc_free(e);
 }
diff -Naur tmp/ucspi-tcp-0.88/pathexec.h ucspi-tcp-0.88/pathexec.h
--- tmp/ucspi-tcp-0.88/pathexec.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/pathexec.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,8 +1,17 @@
+/*
+ * $Log: pathexec.h,v $
+ * Revision 1.2  2005-05-13 23:46:06+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef PATHEXEC_H
 #define PATHEXEC_H
 
-extern void pathexec_run(char *,char **,char **);
-extern int pathexec_env(char *,char *);
-extern void pathexec(char **);
+void            pathexec_run(char *, char **, char **);
+int             pathexec_env(char *, char *);
+void            pathexec(char **);
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/pathexec_run.c ucspi-tcp-0.88/pathexec_run.c
--- tmp/ucspi-tcp-0.88/pathexec_run.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/pathexec_run.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,46 +1,66 @@
+/*
+ * $Log: pathexec_run.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "error.h"
 #include "stralloc.h"
 #include "str.h"
 #include "env.h"
 #include "pathexec.h"
+#include <unistd.h>
 
 static stralloc tmp;
 
-void pathexec_run(char *file,char **argv,char **envp)
+void
+pathexec_run(char *file, char **argv, char **envp)
 {
-  char *path;
-  unsigned int split;
-  int savederrno;
-
-  if (file[str_chr(file,'/')]) {
-    execve(file,argv,envp);
-    return;
-  }
-
-  path = env_get("PATH");
-  if (!path) path = "/bin:/usr/bin";
-
-  savederrno = 0;
-  for (;;) {
-    split = str_chr(path,':');
-    if (!stralloc_copyb(&tmp,path,split)) return;
-    if (!split)
-      if (!stralloc_cats(&tmp,".")) return;
-    if (!stralloc_cats(&tmp,"/"))  return;
-    if (!stralloc_cats(&tmp,file)) return;
-    if (!stralloc_0(&tmp)) return;
-
-    execve(tmp.s,argv,envp);
-    if (errno != error_noent) {
-      savederrno = errno;
-      if ((errno != error_acces) && (errno != error_perm) && (errno != error_isdir)) return;
-    }
-
-    if (!path[split]) {
-      if (savederrno) errno = savederrno;
-      return;
-    }
-    path += split;
-    path += 1;
-  }
+	char           *path;
+	unsigned int    split;
+	int             savederrno;
+
+	if (file[str_chr(file, '/')])
+	{
+		execve(file, argv, envp);
+		return;
+	}
+
+	path = env_get("PATH");
+	if (!path)
+		path = "/bin:/usr/bin";
+
+	savederrno = 0;
+	for (;;)
+	{
+		split = str_chr(path, ':');
+		if (!stralloc_copyb(&tmp, path, split))
+			return;
+		if (!split)
+			if (!stralloc_cats(&tmp, "."))
+				return;
+		if (!stralloc_cats(&tmp, "/"))
+			return;
+		if (!stralloc_cats(&tmp, file))
+			return;
+		if (!stralloc_0(&tmp))
+			return;
+
+		execve(tmp.s, argv, envp);
+		if (errno != error_noent)
+		{
+			savederrno = errno;
+			if ((errno != error_acces) && (errno != error_perm) && (errno != error_isdir))
+				return;
+		}
+
+		if (!path[split])
+		{
+			if (savederrno)
+				errno = savederrno;
+			return;
+		}
+		path += split;
+		path += 1;
+	}
 }
diff -Naur tmp/ucspi-tcp-0.88/prot.c ucspi-tcp-0.88/prot.c
--- tmp/ucspi-tcp-0.88/prot.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/prot.c	2008-07-27 18:41:45.000000000 +0530
@@ -1,19 +1,35 @@
+/*
+ * $Log: prot.c,v $
+ * Revision 1.2  2007-06-10 10:15:28+05:30  Cprogrammer
+ * fixed compilation warning
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "hasshsgr.h"
 #include "prot.h"
+#include <unistd.h>
+#include <grp.h>
 
-int prot_gid(int gid)
+int
+prot_gid(unsigned int gid)
 {
 #ifdef HASSHORTSETGROUPS
-  short x[2];
-  x[0] = gid; x[1] = 73; /* catch errors */
-  if (setgroups(1,x) == -1) return -1;
+	short           x[2];
+	x[0] = gid;
+	x[1] = 73;					/*- catch errors */
+	if (setgroups(1, x) == -1)
+		return -1;
 #else
-  if (setgroups(1,&gid) == -1) return -1;
+	if (setgroups(1, &gid) == -1)
+		return -1;
 #endif
-  return setgid(gid); /* _should_ be redundant, but on some systems it isn't */
+	return setgid(gid);			/*- _should_ be redundant, but on some systems it isn't */
 }
 
-int prot_uid(int uid)
+int
+prot_uid(int uid)
 {
-  return setuid(uid);
+	return setuid(uid);
 }
diff -Naur tmp/ucspi-tcp-0.88/prot.h ucspi-tcp-0.88/prot.h
--- tmp/ucspi-tcp-0.88/prot.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/prot.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,7 +1,19 @@
+/*
+ * $Log: prot.h,v $
+ * Revision 1.3  2007-06-10 10:15:37+05:30  Cprogrammer
+ * fixed compilation warning
+ *
+ * Revision 1.2  2005-05-13 23:46:11+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef PROT_H
 #define PROT_H
 
-extern int prot_gid(int);
-extern int prot_uid(int);
+int             prot_gid(unsigned int);
+int             prot_uid(int);
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/rblsmtpd.1 ucspi-tcp-0.88/rblsmtpd.1
--- tmp/ucspi-tcp-0.88/rblsmtpd.1	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/rblsmtpd.1	2009-01-28 19:28:51.000000000 +0530
@@ -0,0 +1,145 @@
+.TH rblsmtpd 1
+.SH NAME
+rblsmtpd \- blocks mail from RBL-listed sites. It works with any SMTP server that can run under
+.BR tcpserver (1)
+.SH SYNOPSIS
+.B rblsmtpd
+.I opts
+.I prog
+.SH DESCRIPTION
+.I opts
+is a series of getopt-style options.
+.I prog
+consists of one or more arguments.
+
+Normally
+.B rblsmtpd
+runs
+.IR prog .
+.I prog
+is expected to carry out an SMTP conversation to receive incoming mail messages. 
+
+However,
+.B rblsmtpd
+does not invoke
+.I prog
+if it is told to block mail from this client. Instead it carries out its own limited SMTP conversation, temporarily rejecting all attempts to send a message. Meanwhile it prints one line on descriptor 2 to log its activity.
+
+.B rblsmtpd
+drops the limited SMTP conversation after 60 seconds, even if the client has not quit by then.
+.SH OPTIONS
+.TP
+.B \-t \fIn
+Change the timeout to
+.I n
+seconds.
+.P
+.B Blocked clients
+.P
+If the $RBLSMTPD environment variable is set and is nonempty,
+.B rblsmtpd
+blocks mail. It uses $RBLSMTPD as an error message for the client. Normally
+.B rblsmtpd
+runs under
+.BR tcpserver (1);
+you can use
+.BR tcprules (1)
+to set $RBLSMTPD for selected clients. Any occurrence of %IP% in $RBLSMTPD gets replaced with the IP address of the remote client.
+
+If $RBLSMTPD is set and is empty,
+.B rblsmtpd
+does not block mail. 
+
+If $RBLSMTPD is not set,
+.B rblsmtpd
+looks up $TCPREMOTEIP in the RBL, and blocks mail if $TCPREMOTEIP is listed.
+.B tcpserver
+sets up $TCPREMOTEIP as the IP address of the remote host.
+.TP
+.B \-r \fIbase
+Use
+.I base
+as an RBL source. An IP address
+.I a.b.c.d
+is listed by that source if
+.I d.c.b.a.base
+has a TXT record.
+.B rblsmtpd
+uses the contents of the TXT record as an error message for the client.
+.TP
+.B \-a \fIbase
+Use
+.I base
+as an anti-RBL source. An IP address
+.I a.b.c.d
+is anti-listed by that source if
+.I d.c.b.a.base
+has an A record. In this case
+.B rblsmtpd
+does not block mail.
+.P
+You may supply any number of
+.B \-r
+and
+.B \-a
+options.
+.B rblsmtpd
+tries each source in turn until it finds one that lists or anti-lists $TCPREMOTEIP. It also tries an RBL source of rbl.maps.vix.com if you do not supply any
+.B -r
+options. See http://maps.vix.com/rbl/ for more information about rbl.maps.vix.com. 
+
+If you want to run your own RBL source or anti-RBL source for
+.BR rblsmtpd ,
+you can use
+.B rbldns
+from the DNScache (djbdns) package.
+.P
+.B Temporary errors
+.P
+Normally, if $RBLSMTPD is set, and does not start with a hyphen '-'
+.B rblsmtpd
+uses a 451 error code in its limited SMTP conversation. This tells legitimate clients to try again later. It gives innocent relay operators a chance to see the problem, prohibit relaying, get off the RBL, and get the mail delivered. 
+
+However, if $RBLSMTPD begins with a hyphen,
+.B rblsmtpd
+removes the hyphen and uses a 553 error code. This tells legitimate clients to bounce the message immediately. 
+
+There are several error-handling options for RBL lookups:
+.TP
+.B \-B
+(Default.) Use a 451 error code for IP addresses listed in the RBL.
+.TP
+.B \-b
+Use a 553 error code for IP addresses listed in the RBL.
+.TP
+.B \-C
+(Default.) Handle RBL lookups in a ``fail-open'' mode. If an RBL lookup fails temporarily, assume that the address is not listed; if an anti-RBL lookup fails temporarily, assume that the address is anti-listed. Unfortunately, a knowledgeable attacker can force an RBL lookup or an anti-RBL lookup to fail temporarily, so that his mail is not blocked.
+.TP
+.B \-c
+Handle RBL lookups in a ``fail-closed'' mode. If an RBL lookup fails temporarily, assume that the address is listed (but use a 451 error code even with -b). If an anti-RBL lookup fails temporarily, assume that the address is not anti-listed (but use a 451 error code even if a subsequent RBL lookup succeeds with -b). Unfortunately, this sometimes delays legitimate mail.
+.TP
+.B \-w \fIdelay
+Use
+.I delay
+for adding a delay after the SMTP client has initiated the SMTP session and before qmail-smtpd answers with "220 ESMTP"
+.TP
+.B \-W
+The delay is control via the environment variable GREETDELAY, which is typically set by means of tcpserver's rule-set file.
+
+.SH SEE ALSO
+tcpserver(1),
+tcprules(1),
+tcprulescheck(1),
+fixcrio(1),
+recordio(1),
+rblsmtpd(1),
+tcpclient(1),
+who@(1),
+date@(1),
+finger@(1),
+http@(1),
+tcpcat(1),
+mconnect(1),
+tcp-environ(5)
+
+http://cr.yp.to/ucspi-tcp.html
diff -Naur tmp/ucspi-tcp-0.88/rblsmtpd.c ucspi-tcp-0.88/rblsmtpd.c
--- tmp/ucspi-tcp-0.88/rblsmtpd.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/rblsmtpd.c	2009-08-15 20:55:23.783234310 +0530
@@ -1,3 +1,31 @@
+/*
+ * $Log: rblsmtpd.c,v $
+ * Revision 1.8  2009-08-12 10:09:55+05:30  Cprogrammer
+ * IPV6 Modifications
+ *
+ * Revision 1.7  2009-01-03 13:05:40+05:30  Cprogrammer
+ * added greetdelay functionality, %IP% substitution
+ *
+ * Revision 1.6  2008-07-25 16:49:33+05:30  Cprogrammer
+ * fix for darwin
+ *
+ * Revision 1.5  2008-07-17 23:04:02+05:30  Cprogrammer
+ * removed readwrite.h
+ *
+ * Revision 1.4  2007-06-10 10:16:03+05:30  Cprogrammer
+ * fixed usage description
+ *
+ * Revision 1.3  2005-06-10 12:11:22+05:30  Cprogrammer
+ * conditional ipv6 compilation
+ *
+ * Revision 1.2  2005-06-03 09:07:55+05:30  Cprogrammer
+ * removed default base rbl.maps.vix.com
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <unistd.h>
 #include "byte.h"
 #include "str.h"
 #include "scan.h"
@@ -6,193 +34,464 @@
 #include "exit.h"
 #include "sig.h"
 #include "buffer.h"
-#include "readwrite.h"
+#ifdef DARWIN
+#define opteof -1
+#else
 #include "sgetopt.h"
+#endif
 #include "strerr.h"
 #include "stralloc.h"
 #include "commands.h"
 #include "pathexec.h"
 #include "dns.h"
+#ifdef IPV6
+#include "ip6.h"
+#endif
 
 #define FATAL "rblsmtpd: fatal: "
 
-void nomem(void)
+#ifndef	lint
+static char     sccsid[] = "$Id: rblsmtpd.c,v 1.8 2009-08-12 10:09:55+05:30 Cprogrammer Stab mbhangui $";
+#endif
+
+void
+nomem(void)
 {
-  strerr_die2x(111,FATAL,"out of memory");
+	strerr_die2x(111, FATAL, "out of memory");
 }
-void usage(void)
+
+void
+usage(void)
 {
-  strerr_die1x(100,"rblsmtpd: usage: rblsmtpd [ -b ] [ -R ] [ -t timeout ] [ -r base ] [ -a base ] smtpd [ arg ... ]");
+	strerr_die1x(100, "usage: rblsmtpd -r base [ -b ] [ -R ] [ -t timeout ] [ -a base ] [-W] [-w delay] smtpd [ arg ... ]");
 }
 
-char *ip_env;
+char           *ip_env;
 static stralloc ip_reverse;
 
-void ip_init(void)
-{
-  unsigned int i;
-  unsigned int j;
+#ifdef IPV6
+char           *tcp_proto;
 
-  ip_env = env_get("TCPREMOTEIP");
-  if (!ip_env) ip_env = "";
-
-  if (!stralloc_copys(&ip_reverse,"")) nomem();
+static inline char
+tohex(char c)
+{
+	return (c >= 10 ? c - 10 + 'a' : c + '0');
+}
+#endif
 
-  i = str_len(ip_env);
-  while (i) {
-    for (j = i;j > 0;--j) if (ip_env[j - 1] == '.') break;
-    if (!stralloc_catb(&ip_reverse,ip_env + j,i - j)) nomem();
-    if (!stralloc_cats(&ip_reverse,".")) nomem();
-    if (!j) break;
-    i = j - 1;
-  }
+void
+ip_init(void)
+{
+	unsigned int    i;
+	unsigned int    j;
+#ifdef IPV6
+	unsigned char   remoteip[16];
+	char            hexval;
+#endif
+
+#ifdef IPV6
+	if (!(tcp_proto = env_get("PROTO")))
+		tcp_proto = "";
+#endif
+	if (!(ip_env = env_get("TCPREMOTEIP")))
+		ip_env = "";
+	if (!stralloc_copys(&ip_reverse, ""))
+		nomem();
+	i = str_len(ip_env);
+#ifdef IPV6
+	if (str_diff(tcp_proto, "TCP6") != 0)
+	{
+		/*- IPV4 */
+		while (i)
+		{
+			for (j = i; j > 0; --j)
+				if (ip_env[j - 1] == '.')
+					break;
+			if (!stralloc_catb(&ip_reverse, ip_env + j, i - j))
+				nomem();
+			if (!stralloc_cats(&ip_reverse, "."))
+				nomem();
+			if (!j)
+				break;
+			i = j - 1;
+		}
+	} else
+	{
+		if (!(i = ip6_scan(ip_env, (char *) remoteip)))
+			return;
+		for (j = 16; j < 0;j--)
+		{
+			hexval = tohex(remoteip[j - 1] & 15);
+			if (!stralloc_catb(&ip_reverse, &hexval, 1))
+				nomem();
+			if (!stralloc_cats(&ip_reverse, "."))
+				nomem();
+			hexval = tohex(remoteip[j - 1] >> 4);
+			if (!stralloc_catb(&ip_reverse, &hexval, 1))
+				nomem();
+			if (!stralloc_cats(&ip_reverse, "."))
+				nomem();
+		}
+		if (!stralloc_cats(&ip_reverse, "ipv6."))
+			nomem();
+	}
+#else
+	while (i)
+	{
+		for (j = i; j > 0; --j)
+			if (ip_env[j - 1] == '.')
+				break;
+		if (!stralloc_catb(&ip_reverse, ip_env + j, i - j))
+			nomem();
+		if (!stralloc_cats(&ip_reverse, "."))
+			nomem();
+		if (!j)
+			break;
+		i = j - 1;
+	}
+#endif
 }
 
-unsigned long timeout = 60;
-int flagrblbounce = 0;
-int flagfailclosed = 0;
-int flagmustnotbounce = 0;
+unsigned long   timeout = 60;
+int             flagrblbounce = 0;
+int             flagfailclosed = 0;
+int             flagmustnotbounce = 0;
 
-int decision = 0; /* 0 undecided, 1 accept, 2 reject, 3 bounce */
-static stralloc text; /* defined if decision is 2 or 3 */
+int             decision = 0;	/*- 0 undecided, 1 accept, 2 reject, 3 bounce */
+static stralloc text;			/*- defined if decision is 2 or 3 */
 
 static stralloc tmp;
 
-void rbl(char *base)
+void
+rbl(char *base)
 {
-  if (decision) return;
-  if (!stralloc_copy(&tmp,&ip_reverse)) nomem();
-  if (!stralloc_cats(&tmp,base)) nomem();
-  if (dns_txt(&text,&tmp) == -1) {
-    flagmustnotbounce = 1;
-    if (flagfailclosed) {
-      if (!stralloc_copys(&text,"temporary RBL lookup error")) nomem();
-      decision = 2;
-    }
-    return;
-  }
-  if (text.len)
-    if (flagrblbounce)
-      decision = 3;
-    else
-      decision = 2;
-}
-
-void antirbl(char *base)
-{
-  if (decision) return;
-  if (!stralloc_copy(&tmp,&ip_reverse)) nomem();
-  if (!stralloc_cats(&tmp,base)) nomem();
-  if (dns_ip4(&text,&tmp) == -1) {
-    flagmustnotbounce = 1;
-    if (!flagfailclosed)
-      decision = 1;
-    return;
-  }
-  if (text.len)
-    decision = 1;
+	int             i;
+	char           *altreply = 0;
+
+	if (decision)
+		return;
+	if (!stralloc_copy(&tmp, &ip_reverse))
+		nomem();
+	i = str_chr(base, ':');
+	if (base[i])
+	{
+		base[i] = 0;
+		altreply = base + i + 1;
+	}
+	if (!stralloc_cats(&tmp, base))
+		nomem();
+	if (altreply)
+	{
+#ifdef IPV6
+		if (dns_ip6(&text, &tmp) == -1)
+#else
+		if (dns_ip4(&text, &tmp) == -1)
+#endif
+		{
+			flagmustnotbounce = 1;
+			if (flagfailclosed)
+			{
+				if (!stralloc_copys(&text, "temporary RBL lookup error"))
+					nomem();
+				decision = 2;
+			}
+			return;
+		}
+		if (text.len)
+		{
+			if (!stralloc_copys(&text, ""))
+				nomem();
+			while (*altreply)
+			{
+				i = str_chr(altreply, '%');
+				if (!stralloc_catb(&text, altreply, i))
+					nomem();
+				if (altreply[i] && altreply[i + 1] == 'I' && altreply[i + 2] == 'P' && altreply[i + 3] == '%')
+				{
+					if (!stralloc_catb(&text, ip_env, str_len(ip_env)))
+						nomem();
+					altreply += i + 4;
+				} else
+				if (altreply[i])
+				{
+					if (!stralloc_cats(&text, "%"))
+						nomem();
+					altreply += i + 1;
+				} else
+					altreply += i;
+			}
+		}
+	} else
+	{
+		if (dns_txt(&text, &tmp) == -1)
+		{
+			flagmustnotbounce = 1;
+			if (flagfailclosed)
+			{
+				if (!stralloc_copys(&text, "temporary RBL lookup error"))
+					nomem();
+				decision = 2;
+			}
+			return;
+		}
+	}
+	if (text.len)
+	{
+		if (flagrblbounce)
+			decision = 3;
+		else
+			decision = 2;
+	}
 }
 
-char strnum[FMT_ULONG];
+void
+antirbl(char *base)
+{
+	if (decision)
+		return;
+	if (!stralloc_copy(&tmp, &ip_reverse))
+		nomem();
+	if (!stralloc_cats(&tmp, base))
+		nomem();
+#ifdef IPV6
+	if (dns_ip6(&text, &tmp) == -1)
+#else
+	if (dns_ip4(&text, &tmp) == -1)
+#endif
+	{
+		flagmustnotbounce = 1;
+		if (!flagfailclosed)
+			decision = 1;
+		return;
+	}
+	if (text.len)
+		decision = 1;
+}
+
+char            strnum[FMT_ULONG];
 static stralloc message;
 
-char inspace[64]; buffer in = BUFFER_INIT(read,0,inspace,sizeof inspace);
-char outspace[1]; buffer out = BUFFER_INIT(write,1,outspace,sizeof outspace);
+char            inspace[64];
+buffer          in = BUFFER_INIT(read, 0, inspace, sizeof inspace);
+char            outspace[1];
+buffer          out = BUFFER_INIT(write, 1, outspace, sizeof outspace);
+
+void
+delay(unsigned long delay)
+{
+	unsigned long   u;
+	char           *x;
+	static stralloc info;
+
+	if ((x = env_get("GREETDELAY")))
+	{
+		scan_ulong(x, &u);
+		delay= u;
+	}
+	if (!stralloc_copys(&info, "greetdelay: "))
+		nomem();
+	buffer_puts(buffer_2, "rblsmtpd: ");
+	buffer_puts(buffer_2, ip_env);
+	buffer_puts(buffer_2, " pid ");
+	buffer_put(buffer_2, strnum, fmt_ulong(strnum,getpid()));
+	buffer_puts(buffer_2, ": ");
+	buffer_put(buffer_2, info.s, info.len);
+	buffer_put(buffer_2, strnum, fmt_ulong(strnum,delay));
+	buffer_puts(buffer_2, "\n");
+	buffer_flush(buffer_2);
+	if (!stralloc_cats(&info, "\r\n"))
+		nomem();
+	if (delay)
+		sleep(delay);
+}
+
+void
+reject()
+{
+	buffer_putflush(&out, message.s, message.len);
+}
+
+void
+accept()
+{
+	buffer_putsflush(&out, "250 rblsmtpd.local\r\n");
+}
 
-void reject() { buffer_putflush(&out,message.s,message.len); }
-void accept() { buffer_putsflush(&out,"250 rblsmtpd.local\r\n"); }
-void greet()  { buffer_putsflush(&out,"220 rblsmtpd.local\r\n"); }
-void quit()   { buffer_putsflush(&out,"221 rblsmtpd.local\r\n"); _exit(0); }
-void drop()   { _exit(0); }
+void
+greet()
+{
+	buffer_putsflush(&out, "220 rblsmtpd.local\r\n");
+}
+
+void
+quit()
+{
+	buffer_putsflush(&out, "221 rblsmtpd.local\r\n");
+	_exit(0);
+}
+
+void
+drop()
+{
+	_exit(0);
+}
 
 struct commands smtpcommands[] = {
-  { "quit", quit, 0 }
-, { "helo", accept, 0 }
-, { "ehlo", accept, 0 }
-, { "mail", accept, 0 }
-, { "rset", accept, 0 }
-, { "noop", accept, 0 }
-, { 0, reject, 0 }
-} ;
-
-void rblsmtpd(void)
-{
-  int i;
-
-  if (flagmustnotbounce || (decision == 2)) {
-    if (!stralloc_copys(&message,"451 ")) nomem();
-  }
-  else
-    if (!stralloc_copys(&message,"553 ")) nomem();
-
-  if (text.len > 200) text.len = 200;
-  if (!stralloc_cat(&message,&text)) nomem();
-  for (i = 0;i < message.len;++i)
-    if ((message.s[i] < 32) || (message.s[i] > 126))
-      message.s[i] = '?';
-  
-  buffer_puts(buffer_2,"rblsmtpd: ");
-  buffer_puts(buffer_2,ip_env);
-  buffer_puts(buffer_2," pid ");
-  buffer_put(buffer_2,strnum,fmt_ulong(strnum,getpid()));
-  buffer_puts(buffer_2,": ");
-  buffer_put(buffer_2,message.s,message.len);
-  buffer_puts(buffer_2,"\n");
-  buffer_flush(buffer_2);
-
-  if (!stralloc_cats(&message,"\r\n")) nomem();
-
-  if (!timeout)
-    reject();
-  else {
-    sig_catch(sig_alarm,drop);
-    alarm(timeout);
-    greet();
-    commands(&in,smtpcommands);
-  }
-  _exit(0);
-}
-
-main(int argc,char **argv,char **envp)
-{
-  int flagwantdefaultrbl = 1;
-  char *x;
-  int opt;
-
-  ip_init();
-
-  x = env_get("RBLSMTPD");
-  if (x) {
-    if (!*x)
-      decision = 1;
-    else if (*x == '-') {
-      if (!stralloc_copys(&text,x + 1)) nomem();
-      decision = 3;
-    }
-    else {
-      if (!stralloc_copys(&text,x)) nomem();
-      decision = 2;
-    }
-  }
-
-  while ((opt = getopt(argc,argv,"bBcCt:r:a:")) != opteof)
-    switch(opt) {
-      case 'b': flagrblbounce = 1; break;
-      case 'B': flagrblbounce = 0; break;
-      case 'c': flagfailclosed = 1; break;
-      case 'C': flagfailclosed = 0; break;
-      case 't': scan_ulong(optarg,&timeout); break;
-      case 'r': rbl(optarg); flagwantdefaultrbl = 0; break;
-      case 'a': antirbl(optarg); break;
-      default: usage();
-    }
+	{"quit", quit, 0}
+	, {"helo", accept, 0}
+	, {"ehlo", accept, 0}
+	, {"mail", accept, 0}
+	, {"rset", accept, 0}
+	, {"noop", accept, 0}
+	, {0, reject, 0}
+};
+
+void
+rblsmtpd(void)
+{
+	int             i;
 
-  argv += optind;
-  if (!*argv) usage();
+	if (flagmustnotbounce || (decision == 2))
+	{
+		if (!stralloc_copys(&message, "451 "))
+			nomem();
+	} else
+	if (!stralloc_copys(&message, "553 "))
+		nomem();
+
+	if (text.len > 200)
+		text.len = 200;
+	if (!stralloc_cat(&message, &text))
+		nomem();
+	for (i = 0; i < message.len; ++i)
+		if ((message.s[i] < 32) || (message.s[i] > 126))
+			message.s[i] = '?';
+
+	buffer_puts(buffer_2, "rblsmtpd: ");
+	buffer_puts(buffer_2, ip_env);
+	buffer_puts(buffer_2, " pid ");
+	buffer_put(buffer_2, strnum, fmt_ulong(strnum, getpid()));
+	buffer_puts(buffer_2, ": ");
+	buffer_put(buffer_2, message.s, message.len);
+	buffer_puts(buffer_2, "\n");
+	buffer_flush(buffer_2);
+
+	if (!stralloc_cats(&message, "\r\n"))
+		nomem();
+
+	if (!timeout)
+		reject();
+	else
+	{
+		sig_catch(sig_alarm, drop);
+		alarm(timeout);
+		greet();
+		commands(&in, smtpcommands);
+	}
+	_exit(0);
+}
 
-  if (flagwantdefaultrbl) rbl("rbl.maps.vix.com");
-  if (decision >= 2) rblsmtpd();
+int
+main(int argc, char **argv, char **envp)
+{
+	int             flagwantdefaultrbl = 1;
+	char           *x, *altreply = 0;
+	int             i, opt;
+	unsigned long   greetdelay = 0;
+
+	ip_init();
+	if ((x = env_get("RBLSMTPD")))
+	{
+		if (!*x)
+			decision = 1;
+		else
+		if (*x == '-')
+		{
+			altreply = x + 1;
+			decision = 3;
+		} else
+		{
+			altreply = x;
+			decision = 2;
+		}
+		if (!stralloc_copys(&text, ""))
+			nomem();
+		while (*altreply)
+		{
+			i = str_chr(altreply, '%');
+			if (!stralloc_catb(&text, altreply, i))
+				nomem();
+			if (altreply[i] && altreply[i + 1] == 'I' && altreply[i + 2] == 'P' && altreply[i + 3] == '%')
+			{
+				if (!stralloc_catb(&text, ip_env, str_len(ip_env)))
+					nomem();
+				altreply += i + 4;
+			} else
+			if (altreply[i])
+			{
+				if (!stralloc_cats(&text, "%"))
+					nomem();
+				altreply += i + 1;
+			} else
+				altreply += i;
+		}
+		buffer_puts(buffer_2, "RBLSMTPD=");
+		buffer_put(buffer_2, text.s, text.len);
+		buffer_puts(buffer_2, "\n");
+		buffer_flush(buffer_2);
+	}
+	while ((opt = getopt(argc, argv, "bBcCt:r:a:")) != opteof)
+	{
+		switch (opt)
+		{
+		case 'b':
+			flagrblbounce = 1;
+			break;
+		case 'B':
+			flagrblbounce = 0;
+			break;
+		case 'c':
+			flagfailclosed = 1;
+			break;
+		case 'C':
+			flagfailclosed = 0;
+			break;
+		case 't':
+			scan_ulong(optarg, &timeout);
+			break;
+		case 'r':
+			rbl(optarg);
+			flagwantdefaultrbl = 0;
+			break;
+		case 'W':
+			delay(greetdelay);
+			break;
+		case 'w':
+			scan_ulong(optarg, &greetdelay);
+			delay(greetdelay);
+			break;
+		case 'a':
+			antirbl(optarg);
+			break;
+		default:
+			usage();
+		}
+	}
+	argv += optind;
+	if (!*argv)
+		usage();
+	if (flagwantdefaultrbl)
+		usage();
+	if (decision >= 2)
+		rblsmtpd();
+	pathexec_run(*argv, argv, envp);
+	strerr_die4sys(111, FATAL, "unable to run ", *argv, ": ");
+	/*- Not reached */
+	return(0);
+}
 
-  pathexec_run(*argv,argv,envp);
-  strerr_die4sys(111,FATAL,"unable to run ",*argv,": ");
+void
+getversion_rblsmtpd_c()
+{
+	write(1, sccsid, 0);
 }
diff -Naur tmp/ucspi-tcp-0.88/readclose.c ucspi-tcp-0.88/readclose.c
--- tmp/ucspi-tcp-0.88/readclose.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/readclose.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,21 +1,47 @@
-#include "readwrite.h"
+/*
+ * $Log: readclose.c,v $
+ * Revision 1.2  2008-07-17 23:04:08+05:30  Cprogrammer
+ * removed readwrite.h
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "error.h"
 #include "readclose.h"
+#include <unistd.h>
 
-int readclose_append(int fd,stralloc *sa,unsigned int bufsize)
+int
+readclose_append(int fd, stralloc * sa, unsigned int bufsize)
 {
-  int r;
-  for (;;) {
-    if (!stralloc_readyplus(sa,bufsize)) { close(fd); return -1; }
-    r = read(fd,sa->s + sa->len,bufsize);
-    if (r == -1) if (errno == error_intr) continue;
-    if (r <= 0) { close(fd); return r; }
-    sa->len += r;
-  }
+	int             r;
+	for (;;)
+	{
+		if (!stralloc_readyplus(sa, bufsize))
+		{
+			close(fd);
+			return -1;
+		}
+		r = read(fd, sa->s + sa->len, bufsize);
+		if (r == -1)
+			if (errno == error_intr)
+				continue;
+		if (r <= 0)
+		{
+			close(fd);
+			return r;
+		}
+		sa->len += r;
+	}
 }
 
-int readclose(int fd,stralloc *sa,unsigned int bufsize)
+int
+readclose(int fd, stralloc * sa, unsigned int bufsize)
 {
-  if (!stralloc_copys(sa,"")) { close(fd); return -1; }
-  return readclose_append(fd,sa,bufsize);
+	if (!stralloc_copys(sa, ""))
+	{
+		close(fd);
+		return -1;
+	}
+	return readclose_append(fd, sa, bufsize);
 }
diff -Naur tmp/ucspi-tcp-0.88/readclose.h ucspi-tcp-0.88/readclose.h
--- tmp/ucspi-tcp-0.88/readclose.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/readclose.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,9 +1,18 @@
+/*
+ * $Log: readclose.h,v $
+ * Revision 1.2  2005-05-13 23:46:15+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef READCLOSE_H
 #define READCLOSE_H
 
 #include "stralloc.h"
 
-extern int readclose_append(int,stralloc *,unsigned int);
-extern int readclose(int,stralloc *,unsigned int);
+int             readclose_append(int, stralloc *, unsigned int);
+int             readclose(int, stralloc *, unsigned int);
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/readwrite.h ucspi-tcp-0.88/readwrite.h
--- tmp/ucspi-tcp-0.88/readwrite.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/readwrite.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,7 +0,0 @@
-#ifndef READWRITE_H
-#define READWRITE_H
-
-extern int read();
-extern int write();
-
-#endif
diff -Naur tmp/ucspi-tcp-0.88/recordio.c ucspi-tcp-0.88/recordio.c
--- tmp/ucspi-tcp-0.88/recordio.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/recordio.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,178 +0,0 @@
-#include "sig.h"
-#include "buffer.h"
-#include "strerr.h"
-#include "str.h"
-#include "byte.h"
-#include "readwrite.h"
-#include "exit.h"
-#include "fmt.h"
-#include "iopause.h"
-#include "pathexec.h"
-
-#define FATAL "recordio: fatal: "
-
-char pid[FMT_ULONG];
-
-char recordbuf[512];
-buffer ssrecord = BUFFER_INIT(write,2,recordbuf,sizeof recordbuf);
-
-void record(char *buf,int len,char *direction) /* 1 <= len <= 256 */
-{
-  int i;
-
-  while (len) {
-    buffer_puts(&ssrecord,pid);
-    buffer_puts(&ssrecord,direction);
-
-    i = byte_chr(buf,len,'\n');
-    buffer_put(&ssrecord,buf,i);
-
-    if (i == len) {
-      buffer_puts(&ssrecord,"+\n");
-      buffer_flush(&ssrecord);
-      return;
-    }
-
-    buffer_puts(&ssrecord," \n");
-    buffer_flush(&ssrecord);
-    buf += i + 1;
-    len -= i + 1;
-  }
-}
-
-int leftstatus = 0;
-char leftbuf[256];
-int leftlen;
-int leftpos;
-
-int rightstatus = 0;
-char rightbuf[256];
-int rightlen;
-int rightpos;
-
-void doit(int fdleft,int fdright) /* copy 0 -> fdleft, copy fdright -> 1 */
-{
-  struct taia stamp;
-  struct taia deadline;
-  iopause_fd x[4];
-  int xlen;
-  iopause_fd *io0;
-  iopause_fd *ioleft;
-  iopause_fd *io1;
-  iopause_fd *ioright;
-  int r;
-
-  for (;;) {
-    xlen = 0;
-
-    io0 = 0;
-    if (leftstatus == 0) {
-      io0 = &x[xlen++];
-      io0->fd = 0;
-      io0->events = IOPAUSE_READ;
-    }
-    ioleft = 0;
-    if (leftstatus == 1) {
-      ioleft = &x[xlen++];
-      ioleft->fd = fdleft;
-      ioleft->events = IOPAUSE_WRITE;
-    }
-
-    ioright = 0;
-    if (rightstatus == 0) {
-      ioright = &x[xlen++];
-      ioright->fd = fdright;
-      ioright->events = IOPAUSE_READ;
-    }
-    io1 = 0;
-    if (rightstatus == 1) {
-      io1 = &x[xlen++];
-      io1->fd = 1;
-      io1->events = IOPAUSE_WRITE;
-    }
-
-    taia_now(&stamp);
-    taia_uint(&deadline,3600);
-    taia_add(&deadline,&stamp,&deadline);
-    iopause(x,xlen,&deadline,&stamp);
-
-    if (io0 && io0->revents) {
-      r = read(0,leftbuf,sizeof leftbuf);
-      if (r <= 0) {
-        leftstatus = -1;
-        close(fdleft);
-        buffer_puts(&ssrecord,pid);
-        buffer_puts(&ssrecord," < [EOF]\n");
-        buffer_flush(&ssrecord);
-      }
-      else {
-        leftstatus = 1; leftpos = 0; leftlen = r;
-        record(leftbuf,r," < ");
-      }
-    }
-
-    if (ioleft && ioleft->revents) {
-      r = write(fdleft,leftbuf + leftpos,leftlen - leftpos);
-      if (r == -1) break;
-      leftpos += r;
-      if (leftpos == leftlen) leftstatus = 0;
-    }
-
-    if (ioright && ioright->revents) {
-      r = read(fdright,rightbuf,sizeof rightbuf);
-      if (r <= 0) {
-        buffer_puts(&ssrecord,pid);
-        buffer_puts(&ssrecord," > [EOF]\n");
-        buffer_flush(&ssrecord);
-        break;
-      }
-      rightstatus = 1; rightpos = 0; rightlen = r;
-      record(rightbuf,r," > ");
-    }
-
-    if (io1 && io1->revents) {
-      r = write(1,rightbuf + rightpos,rightlen - rightpos);
-      if (r == -1) break;
-      rightpos += r;
-      if (rightpos == rightlen) rightstatus = 0;
-    }
-  }
-
-  _exit(0);
-}
-
-main(int argc,char **argv,char **envp)
-{
-  int piin[2];
-  int piout[2];
-
-  pid[fmt_ulong(pid,getpid())] = 0;
-
-  if (argc < 2)
-    strerr_die1x(100,"recordio: usage: recordio program [ arg ... ]");
-
-  if (pipe(piin) == -1)
-    strerr_die2sys(111,FATAL,"unable to create pipe: ");
-  if (pipe(piout) == -1)
-    strerr_die2sys(111,FATAL,"unable to create pipe: ");
-
-  switch(fork()) {
-    case -1:
-      strerr_die2sys(111,FATAL,"unable to fork: ");
-    case 0:
-      sig_ignore(sig_pipe);
-      close(piin[0]);
-      close(piout[1]);
-      doit(piin[1],piout[0]);
-  }
-
-  close(piin[1]);
-  close(piout[0]);
-  if (fd_move(0,piin[0]) == -1)
-    strerr_die2sys(111,FATAL,"unable to move descriptors: ");
-  if (fd_move(1,piout[1]) == -1)
-    strerr_die2sys(111,FATAL,"unable to move descriptors: ");
-
-  pathexec_run(argv[1],argv + 1,envp);
-  strerr_die4sys(111,FATAL,"unable to run ",argv[1],": ");
-}
diff -Naur tmp/ucspi-tcp-0.88/remoteinfo.c ucspi-tcp-0.88/remoteinfo.c
--- tmp/ucspi-tcp-0.88/remoteinfo.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/remoteinfo.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,98 +0,0 @@
-#include "fmt.h"
-#include "buffer.h"
-#include "socket.h"
-#include "error.h"
-#include "iopause.h"
-#include "timeoutconn.h"
-#include "remoteinfo.h"
-
-static struct taia now;
-static struct taia deadline;
-
-static int mywrite(int fd,char *buf,int len)
-{
-  iopause_fd x;
-
-  x.fd = fd;
-  x.events = IOPAUSE_WRITE;
-  for (;;) {
-    taia_now(&now);
-    iopause(&x,1,&deadline,&now);
-    if (x.revents) break;
-    if (taia_less(&deadline,&now)) {
-      errno = error_timeout;
-      return -1;
-    }
-  }
-  return write(fd,buf,len);
-}
-
-static int myread(int fd,char *buf,int len)
-{
-  iopause_fd x;
-
-  x.fd = fd;
-  x.events = IOPAUSE_READ;
-  for (;;) {
-    taia_now(&now);
-    iopause(&x,1,&deadline,&now);
-    if (x.revents) break;
-    if (taia_less(&deadline,&now)) {
-      errno = error_timeout;
-      return -1;
-    }
-  }
-  return read(fd,buf,len);
-}
-
-static int doit(stralloc *out,int s,char ipremote[4],uint16 portremote,char iplocal[4],uint16 portlocal,unsigned int timeout)
-{
-  buffer b;
-  char bspace[128];
-  char strnum[FMT_ULONG];
-  int numcolons;
-  char ch;
-
-  if (socket_bind4(s,iplocal,0) == -1) return -1;
-  if (timeoutconn(s,ipremote,113,timeout) == -1) return -1;
-
-  buffer_init(&b,mywrite,s,bspace,sizeof bspace);
-  buffer_put(&b,strnum,fmt_ulong(strnum,portremote));
-  buffer_put(&b," , ",3);
-  buffer_put(&b,strnum,fmt_ulong(strnum,portlocal));
-  buffer_put(&b,"\r\n",2);
-  if (buffer_flush(&b) == -1) return -1;
-
-  buffer_init(&b,myread,s,bspace,sizeof bspace);
-  numcolons = 0;
-  for (;;) {
-    if (buffer_get(&b,&ch,1) != 1) return -1;
-    if ((ch == ' ') || (ch == '\t') || (ch == '\r')) continue;
-    if (ch == '\n') return 0;
-    if (numcolons < 3) {
-      if (ch == ':') ++numcolons;
-    }
-    else {
-      if (!stralloc_append(out,&ch)) return -1;
-      if (out->len > 256) return 0;
-    }
-  }
-}
-
-int remoteinfo(stralloc *out,char ipremote[4],uint16 portremote,char iplocal[4],uint16 portlocal,unsigned int timeout)
-{
-  int s;
-  int r;
-
-  if (!stralloc_copys(out,"")) return -1;
-
-  taia_now(&now);
-  taia_uint(&deadline,timeout);
-  taia_add(&deadline,&now,&deadline);
-
-  s = socket_tcp();
-  if (s == -1) return -1;
-  r = doit(out,s,ipremote,portremote,iplocal,portlocal,timeout);
-  close(s);
-  return r;
-}
diff -Naur tmp/ucspi-tcp-0.88/remoteinfo.h ucspi-tcp-0.88/remoteinfo.h
--- tmp/ucspi-tcp-0.88/remoteinfo.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/remoteinfo.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,9 +0,0 @@
-#ifndef REMOTEINFO_H
-#define REMOTEINFO_H
-
-#include "stralloc.h"
-#include "uint16.h"
-
-extern int remoteinfo(stralloc *,char *,uint16,char *,uint16,unsigned int);
-
-#endif
diff -Naur tmp/ucspi-tcp-0.88/rts.exp ucspi-tcp-0.88/rts.exp
--- tmp/ucspi-tcp-0.88/rts.exp	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/rts.exp	1970-01-01 05:30:00.000000000 +0530
@@ -1,435 +0,0 @@
---- tcpclient prints usage message without enough arguments
-tcpclient: usage: tcpclient [ -hHrRdDqQv ] [ -i localip ] [ -p localport ] [ -T timeoutconn ] [ -l localname ] [ -t timeoutinfo ] host port program
-100
---- tcpclient prints error message with unknown port name
-tcpclient: fatal: unable to figure out port number for nonexistentport
-111
---- tcpclient prints error message when connection fails
-tcpclient: unable to connect to 127.0.0.1 port 16: connection refused
-111
---- tcpclient -q does not print error message when connection fails
-111
---- tcpclient understands empty host name as synonym for 0
-tcpclient: unable to connect to 127.0.0.1 port 16: connection refused
-111
---- tcpclient understands unbracketed IP address
-tcpclient: unable to connect to 127.0.0.1 port 16: connection refused
-111
---- tcpclient understands bracketed IP address
-tcpclient: unable to connect to 127.0.0.1 port 16: connection refused
-111
---- tcpclient prints error message with unknown host name
-tcpclient: fatal: no IP address for nonexistent.local.
-111
---- tcpclient prints error message with unresolvable host name
-tcpclient: fatal: temporarily unable to figure out IP address for thislabelistoolongbecausednshasalimitof63charactersinasinglelabel.: protocol error
-111
---- tcpserver prints usage message without enough arguments
-tcpserver: usage: tcpserver [ -1UXpPhHrRoOdDqQv ] [ -c limit ] [ -x rules.cdb ] [ -B banner ] [ -g gid ] [ -u uid ] [ -b backlog ] [ -l localname ] [ -t timeout ] host port program
-100
---- tcpserver -u 1 attempts to set uid to 1
-tcpserver: fatal: unable to set uid: permission denied
-111
---- tcpserver -U reads $UID
-tcpserver: fatal: unable to set uid: permission denied
-111
---- tcpserver -g 2 attempts to set gid to 2
-tcpserver: fatal: unable to set gid: permission denied
-111
---- tcpserver -U reads $GID
-tcpserver: fatal: unable to set gid: permission denied
-111
---- tcpserver prints error message with unknown port name
-tcpserver: fatal: unable to figure out port number for nonexistentport
-111
---- tcpserver prints error message with unknown host name
-tcpserver: fatal: no IP address for nonexistent.local.
-111
---- tcpserver prints error message with unresolvable host name
-tcpserver: fatal: temporarily unable to figure out IP address for thislabelistoolongbecausednshasalimitof63charactersinasinglelabel.: protocol error
-111
---- tcpserver prints error message with non-local host name
-tcpserver: fatal: unable to bind: address not available
-111
---- tcpserver sets basic environment variables
-bannerPROTO=TCP
-TCPLOCALHOST=Local
-TCPLOCALIP=127.0.0.1
-TCPLOCALPORT=50016
-TCPREMOTEHOST=localhost
-TCPREMOTEIP=127.0.0.1
-TCPREMOTEPORT=50017
-TCPREMOTEINFO=unset
-0
---- tcpclient recognizes -D, -i, -r, -h, -t
-bannerPROTO=TCP
-TCPLOCALHOST=Local
-TCPLOCALIP=127.0.0.1
-TCPLOCALPORT=50016
-TCPREMOTEHOST=localhost
-TCPREMOTEIP=127.0.0.1
-TCPREMOTEPORT=50018
-TCPREMOTEINFO=unset
-0
---- tcpclient sets basic environment variables
-PROTO=TCP
-TCPLOCALHOST=Local
-TCPLOCALIP=127.0.0.1
-TCPLOCALPORT=50019
-TCPREMOTEHOST=unset
-TCPREMOTEIP=127.0.0.1
-TCPREMOTEPORT=50016
-TCPREMOTEINFO=unset
-0
---- tcpclient looks up host names properly
-PROTO=TCP
-TCPLOCALHOST=localhost
-TCPLOCALIP=127.0.0.1
-TCPLOCALPORT=50020
-TCPREMOTEHOST=localhost
-TCPREMOTEIP=127.0.0.1
-TCPREMOTEPORT=50016
-TCPREMOTEINFO=unset
-0
---- tcpclient -v works
-tcpclient: connected to 127.0.0.1 port 50016
-ok
-0
---- tcpserver prints error message with used port
-tcpserver: fatal: unable to bind: address already used
-111
---- tcpcat works
-bannerPROTO=TCP
-TCPLOCALHOST=Local
-TCPLOCALIP=127.0.0.1
-TCPLOCALPORT=50016
-TCPREMOTEHOST=localhost
-TCPREMOTEIP=127.0.0.1
-TCPREMOTEINFO=unset
-0
---- mconnect works
-bannerPROTO=TCP
-TCPLOCALHOST=Local
-TCPLOCALIP=127.0.0.1
-TCPLOCALPORT=50016
-TCPREMOTEHOST=localhost
-TCPREMOTEIP=127.0.0.1
-TCPREMOTEINFO=unset
-0
---- tcprules prints usage message without enough arguments
-tcprules: usage: tcprules rules.cdb rules.tmp
-100
---- tcprules prints error message if it cannot create tmp
-tcprules: fatal: unable to create /dev/nonexistent/tmp: file does not exist
-111
---- tcprules prints error message if it cannot move tmp to cdb
-tcprules: fatal: unable to move test.tmp to /dev/nonexistent/cdb: file does not exist
-111
---- tcprules creates a cdb file
-0
---- tcprulescheck sees deny
-rule 1.2.3.4:
-deny connection
-0
---- tcprulescheck does not apply deny to another host
-default:
-allow connection
-0
---- tcprules replaces a cdb file
-0
---- tcprulescheck finds rule with address and info
-rule joe@127.0.0.1:
-set environment variable which=first
-allow connection
-0
---- tcprulescheck finds rule with address
-rule 18.23.0.32:
-set environment variable which=second
-allow connection
-0
---- tcprulescheck finds one-dot wildcard
-rule 127.:
-set environment variable which=third
-allow connection
-0
---- tcprulescheck finds zero-dot wildcard
-rule :
-set environment variable which=fourth
-allow connection
-0
---- tcprules handles comments, address ranges, multiple variables
-0
-rule 127.0.:
-set environment variable which=first
-set environment variable where=whatever
-allow connection
-rule 127.1.:
-set environment variable which=first
-set environment variable where=whatever
-allow connection
-rule 127.2.:
-set environment variable which=first
-set environment variable where=whatever
-allow connection
-rule 127.3.:
-set environment variable which=first
-set environment variable where=whatever
-allow connection
-rule 127.4.:
-set environment variable which=first
-set environment variable where=whatever
-allow connection
-rule 127.5.:
-set environment variable which=first
-set environment variable where=whatever
-allow connection
-default:
-allow connection
-default:
-allow connection
-default:
-allow connection
-default:
-allow connection
-default:
-allow connection
---- tcprules handles host names
-0
-rule =known.edu:
-set environment variable which=known
-allow connection
-rule :
-set environment variable which=anybody
-allow connection
-rule :
-set environment variable which=anybody
-allow connection
-rule =.abuser.edu:
-deny connection
-rule =.abuser.edu:
-deny connection
---- tcprulescheck searches for rules in the proper order
-0
-rule xyz@86.75.30.9:
-set environment variable which=first
-allow connection
-rule xyz@86.75.30.9:
-set environment variable which=first
-allow connection
-rule xyz@=one.two.three:
-set environment variable which=second
-allow connection
-rule 86.75.30.9:
-set environment variable which=third
-allow connection
-rule 86.75.30.9:
-set environment variable which=third
-allow connection
-rule 86.75.30.9:
-set environment variable which=third
-allow connection
-rule 86.75.30.9:
-set environment variable which=third
-allow connection
-rule =one.two.three:
-set environment variable which=fourth
-allow connection
-rule =one.two.three:
-set environment variable which=fourth
-allow connection
-rule 86.75.30.:
-set environment variable which=fifth
-allow connection
-rule 86.75.30.:
-set environment variable which=fifth
-allow connection
-rule 86.75.:
-set environment variable which=sixth
-allow connection
-rule 86.75.:
-set environment variable which=sixth
-allow connection
-rule 86.75.:
-set environment variable which=sixth
-allow connection
-rule 86.75.:
-set environment variable which=sixth
-allow connection
-rule 86.:
-set environment variable which=seventh
-allow connection
-rule 86.:
-set environment variable which=seventh
-allow connection
-rule 86.:
-set environment variable which=seventh
-allow connection
-rule 86.:
-set environment variable which=seventh
-allow connection
-rule =.two.three:
-set environment variable which=eighth
-allow connection
-rule =.two.three:
-set environment variable which=eighth
-allow connection
-rule =.three:
-set environment variable which=ninth
-allow connection
-rule =.three:
-set environment variable which=ninth
-allow connection
-rule =:
-set environment variable which=tenth
-allow connection
-rule =:
-set environment variable which=tenth
-allow connection
-rule :
-set environment variable which=eleventh
-allow connection
-rule :
-set environment variable which=eleventh
-allow connection
---- addcr leaves an empty file alone
-0
---- addcr leaves a partial final line alone
-test0
---- addcr adds CR after the first line
-test^M
-0
---- addcr adds CR after the second line
-test^M
-test2^M
-0
---- addcr handles nulls
-t^@st^M
-0
---- delcr leaves an empty file alone
-0
---- delcr leaves a non-CR line alone
-test
-0
---- delcr removes CR if a line has it
-test
-0
---- delcr converts CR CR LF to CR LF
-test^M
-0
---- delcr does not remove CR from a partial final line
-test^M0
---- delcr handles a non-CR partial final line
-test0
---- delcr handles nulls
-t^@st
-0
---- fixcrio works
-^M
-hi^M
-there^M
-bye^M
---- recordio works
-... < test $
-... > test $
-... < [EOF]$
-... > [EOF]$
---- recordio handles multiple-line packets
-... < test $
-... < test2 $
-... > test $
-... > test2 $
-... < [EOF]$
-... > [EOF]$
---- recordio handles partial final lines
-... < test+$
-... > test+$
-... < [EOF]$
-... > [EOF]$
---- argv0 works
-zero
-0
---- argv0 requires arguments
-argv0: usage: argv0 realname program [ arg ... ]
-100
---- rblsmtpd does not find 127.0.0.1 on the RBL
-ok
-0
---- rblsmtpd finds 127.0.0.2 on the RBL
-rblsmtpd: 127.0.0.2 pid x: 451 Blackholed - see <URL:http://mail-abuse.org/cgi-bin/lookup?127.0.0.2>
-220 rblsmtpd.local^M
-451 Blackholed - see <URL:http://mail-abuse.org/cgi-bin/lookup?127.0.0.2>^M
-221 rblsmtpd.local^M
-0
---- rblsmtpd -b uses a permanent error code
-rblsmtpd: 127.0.0.2 pid x: 553 Blackholed - see <URL:http://mail-abuse.org/cgi-bin/lookup?127.0.0.2>
-220 rblsmtpd.local^M
-553 Blackholed - see <URL:http://mail-abuse.org/cgi-bin/lookup?127.0.0.2>^M
-221 rblsmtpd.local^M
-0
---- rblsmtpd quits after a timeout
-rblsmtpd: 127.0.0.2 pid x: 451 Blackholed - see <URL:http://mail-abuse.org/cgi-bin/lookup?127.0.0.2>
-220 rblsmtpd.local^M
-0
---- rblsmtpd prints an immediate error message with -t0
-rblsmtpd: 127.0.0.2 pid x: 451 Blackholed - see <URL:http://mail-abuse.org/cgi-bin/lookup?127.0.0.2>
-451 Blackholed - see <URL:http://mail-abuse.org/cgi-bin/lookup?127.0.0.2>^M
-0
---- rblsmtpd understands an empty $RBLSMTPD
-ok
-0
---- rblsmtpd understands a nonempty $RBLSMTPD
-rblsmtpd: 127.0.0.2 pid x: 451 Error
-220 rblsmtpd.local^M
-451 Error^M
-221 rblsmtpd.local^M
-0
---- rblsmtpd understands a permanent $RBLSMTPD
-rblsmtpd: 127.0.0.2 pid x: 553 Error
-220 rblsmtpd.local^M
-553 Error^M
-221 rblsmtpd.local^M
-0
---- rblsmtpd understands -r
-ok
-0
---- rblsmtpd understands -a
-ok
-0
---- tcpserver -1v prints proper messages
-50016
-tcpserver: status: 0/2
-tcpserver: status: 1/2
-tcpserver: pid x from 127.0.0.1
-tcpserver: ok x Local:127.0.0.1:50016 localhost:127.0.0.1::x
-tcpserver: end x status 0
-tcpserver: status: 0/2
-tcpserver: status: 1/2
-tcpserver: pid x from 127.0.0.1
-tcpserver: ok x Local:127.0.0.1:50016 localhost:127.0.0.1::x
-tcpserver: end x status 0
-tcpserver: status: 0/2
-tcpserver: status: 1/2
-tcpserver: pid x from 127.0.0.1
-tcpserver: ok x Local:127.0.0.1:50016 localhost:127.0.0.1::x
-tcpserver: end x status 0
-tcpserver: status: 0/2
-tcpserver: status: 1/2
-tcpserver: pid x from 127.0.0.1
-tcpserver: ok x Local:127.0.0.1:50016 localhost:127.0.0.1::x
-tcpserver: end x status 0
-tcpserver: status: 0/2
-tcpserver: status: 1/2
-tcpserver: pid x from 127.0.0.1
-tcpserver: ok x Local:127.0.0.1:50016 localhost:127.0.0.1::x
-tcpserver: end x status 0
-tcpserver: status: 0/2
-tcpserver: status: 1/2
-tcpserver: pid x from 127.0.0.1
-tcpserver: ok x Local:127.0.0.1:50016 localhost:127.0.0.1::x
-tcpserver: end x status 0
-tcpserver: status: 0/2
-tcpserver: status: 1/2
-tcpserver: pid x from 127.0.0.1
-tcpserver: ok x Local:127.0.0.1:50016 localhost:127.0.0.1::x
-tcpserver: end x status 0
-tcpserver: status: 0/2
diff -Naur tmp/ucspi-tcp-0.88/rts.sh ucspi-tcp-0.88/rts.sh
--- tmp/ucspi-tcp-0.88/rts.sh	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/rts.sh	2008-07-27 18:43:13.000000000 +0530
@@ -1 +1,7 @@
+#
+# $Log: rts.sh,v $
+# Revision 1.1  2003-12-31 19:57:58+05:30  Cprogrammer
+# Initial revision
+#
+#
 env - PATH="`pwd`:$PATH" sh rts.tests 2>&1 | cat -v
diff -Naur tmp/ucspi-tcp-0.88/rules.c ucspi-tcp-0.88/rules.c
--- tmp/ucspi-tcp-0.88/rules.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/rules.c	2009-08-13 14:41:58.930312442 +0530
@@ -1,100 +1,138 @@
+/*
+ * $Log: rules.c,v $
+ * Revision 1.3  2009-08-13 14:41:49+05:30  Cprogrammer
+ * beautified code
+ *
+ * Revision 1.2  2005-06-10 09:13:06+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "alloc.h"
 #include "stralloc.h"
 #include "open.h"
 #include "cdb.h"
 #include "rules.h"
 
-stralloc rules_name = {0};
+stralloc        rules_name = { 0 };
 
 static struct cdb c;
 
-static int dorule(void (*callback)(char *,unsigned int))
+static int
+dorule(void     (*callback) (char *, unsigned int))
 {
-  char *data;
-  unsigned int datalen;
+	char           *data;
+	unsigned int    datalen;
 
-  switch(cdb_find(&c,rules_name.s,rules_name.len)) {
-    case -1: return -1;
-    case 0: return 0;
-  }
-
-  datalen = cdb_datalen(&c);
-  data = alloc(datalen);
-  if (!data) return -1;
-  if (cdb_read(&c,data,datalen,cdb_datapos(&c)) == -1) {
-    alloc_free(data);
-    return -1;
-  }
-
-  callback(data,datalen);
-  alloc_free(data);
-  return 1;
+	switch (cdb_find(&c, rules_name.s, rules_name.len))
+	{
+	case -1:
+		return -1;
+	case 0:
+		return 0;
+	}
+
+	datalen = cdb_datalen(&c);
+	if (!(data = alloc(datalen)))
+		return -1;
+	if (cdb_read(&c, data, datalen, cdb_datapos(&c)) == -1)
+	{
+		alloc_free(data);
+		return -1;
+	}
+	callback(data, datalen);
+	alloc_free(data);
+	return 1;
 }
 
-static int doit(void (*callback)(char *,unsigned int),char *ip,char *host,char *info)
+static int
+doit(void       (*callback) (char *, unsigned int), char *ip, char *host, char *info)
 {
-  int r;
+	int             r;
 
-  if (info) {
-    if (!stralloc_copys(&rules_name,info)) return -1;
-    if (!stralloc_cats(&rules_name,"@")) return -1;
-    if (!stralloc_cats(&rules_name,ip)) return -1;
-    r = dorule(callback);
-    if (r) return r;
-
-    if (host) {
-      if (!stralloc_copys(&rules_name,info)) return -1;
-      if (!stralloc_cats(&rules_name,"@=")) return -1;
-      if (!stralloc_cats(&rules_name,host)) return -1;
-      r = dorule(callback);
-      if (r) return r;
-    }
-  }
-
-  if (!stralloc_copys(&rules_name,ip)) return -1;
-  r = dorule(callback);
-  if (r) return r;
-
-  if (host) {
-    if (!stralloc_copys(&rules_name,"=")) return -1;
-    if (!stralloc_cats(&rules_name,host)) return -1;
-    r = dorule(callback);
-    if (r) return r;
-  }
-
-  if (!stralloc_copys(&rules_name,ip)) return -1;
-  while (rules_name.len > 0) {
-    if (ip[rules_name.len - 1] == '.') {
-      r = dorule(callback);
-      if (r) return r;
-    }
-    --rules_name.len;
-  }
-
-  if (host) {
-    while (*host) {
-      if (*host == '.') {
-        if (!stralloc_copys(&rules_name,"=")) return -1;
-        if (!stralloc_cats(&rules_name,host)) return -1;
-	r = dorule(callback);
-	if (r) return r;
-      }
-      ++host;
-    }
-    if (!stralloc_copys(&rules_name,"=")) return -1;
-    r = dorule(callback);
-    if (r) return r;
-  }
-
-  rules_name.len = 0;
-  return dorule(callback);
+	if (info)
+	{
+		if (!stralloc_copys(&rules_name, info))
+			return -1;
+		if (!stralloc_cats(&rules_name, "@"))
+			return -1;
+		if (!stralloc_cats(&rules_name, ip))
+			return -1;
+		if ((r = dorule(callback)))
+			return r;
+		if (host)
+		{
+			if (!stralloc_copys(&rules_name, info))
+				return -1;
+			if (!stralloc_cats(&rules_name, "@="))
+				return -1;
+			if (!stralloc_cats(&rules_name, host))
+				return -1;
+			if ((r = dorule(callback)))
+				return r;
+		}
+	}
+	if (!stralloc_copys(&rules_name, ip))
+		return -1;
+	if ((r = dorule(callback)))
+		return r;
+	if (host)
+	{
+		if (!stralloc_copys(&rules_name, "="))
+			return -1;
+		if (!stralloc_cats(&rules_name, host))
+			return -1;
+		if ((r = dorule(callback)))
+			return r;
+	}
+
+	if (!stralloc_copys(&rules_name, ip))
+		return -1;
+	while (rules_name.len > 0)
+	{
+#ifdef IPV6
+		if (ip[rules_name.len - 1] == '.' || ip[rules_name.len - 1] == ':')
+#else
+		if (ip[rules_name.len - 1] == '.')
+#endif
+		{
+			if ((r = dorule(callback)))
+				return r;
+		}
+		--rules_name.len;
+	}
+	if (host)
+	{
+		while (*host)
+		{
+			if (*host == '.')
+			{
+				if (!stralloc_copys(&rules_name, "="))
+					return -1;
+				if (!stralloc_cats(&rules_name, host))
+					return -1;
+				if ((r = dorule(callback)))
+					return r;
+			}
+			++host;
+		}
+		if (!stralloc_copys(&rules_name, "="))
+			return -1;
+		if ((r = dorule(callback)))
+			return r;
+	}
+	rules_name.len = 0;
+	return dorule(callback);
 }
 
-int rules(void (*callback)(char *,unsigned int),int fd,char *ip,char *host,char *info)
+int
+rules(void      (*callback) (char *, unsigned int), int fd, char *ip, char *host, char *info)
 {
-  int r;
-  cdb_init(&c,fd);
-  r = doit(callback,ip,host,info);
-  cdb_free(&c);
-  return r;
+	int             r;
+	cdb_init(&c, fd);
+	r = doit(callback, ip, host, info);
+	cdb_free(&c);
+	return r;
 }
diff -Naur tmp/ucspi-tcp-0.88/rules.h ucspi-tcp-0.88/rules.h
--- tmp/ucspi-tcp-0.88/rules.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/rules.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,9 +1,18 @@
+/*
+ * $Log: rules.h,v $
+ * Revision 1.2  2005-05-13 23:46:28+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef RULES_H
 #define RULES_H
 
 #include "stralloc.h"
 
 extern stralloc rules_name;
-extern int rules(void (*)(char *,unsigned int),int,char *,char *,char *);
+int             rules(void (*)(char *, unsigned int), int, char *, char *, char *);
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/scan.h ucspi-tcp-0.88/scan.h
--- tmp/ucspi-tcp-0.88/scan.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/scan.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,28 +1,37 @@
+/*
+ * $Log: scan.h,v $
+ * Revision 1.2  2005-05-13 23:46:45+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef SCAN_H
 #define SCAN_H
 
-extern unsigned int scan_uint(char *,unsigned int *);
-extern unsigned int scan_xint(char *,unsigned int *);
-extern unsigned int scan_nbbint(char *,unsigned int,unsigned int,unsigned int,unsigned int *);
-extern unsigned int scan_ushort(char *,unsigned short *);
-extern unsigned int scan_xshort(char *,unsigned short *);
-extern unsigned int scan_nbbshort(char *,unsigned int,unsigned int,unsigned int,unsigned short *);
-extern unsigned int scan_ulong(char *,unsigned long *);
-extern unsigned int scan_xlong(char *,unsigned long *);
-extern unsigned int scan_nbblong(char *,unsigned int,unsigned int,unsigned int,unsigned long *);
-
-extern unsigned int scan_plusminus(char *,int *);
-extern unsigned int scan_0x(char *,unsigned int *);
-
-extern unsigned int scan_whitenskip(char *,unsigned int);
-extern unsigned int scan_nonwhitenskip(char *,unsigned int);
-extern unsigned int scan_charsetnskip(char *,char *,unsigned int);
-extern unsigned int scan_noncharsetnskip(char *,char *,unsigned int);
+unsigned int    scan_uint(char *, unsigned int *);
+unsigned int    scan_xint(char *, unsigned int *);
+unsigned int    scan_nbbint(char *, unsigned int, unsigned int, unsigned int, unsigned int *);
+unsigned int    scan_ushort(char *, unsigned short *);
+unsigned int    scan_xshort(char *, unsigned short *);
+unsigned int    scan_nbbshort(char *, unsigned int, unsigned int, unsigned int, unsigned short *);
+unsigned int    scan_ulong(char *, unsigned long *);
+unsigned int    scan_xlong(char *, unsigned long *);
+unsigned int    scan_nbblong(char *, unsigned int, unsigned int, unsigned int, unsigned long *);
+
+unsigned int    scan_plusminus(char *, int *);
+unsigned int    scan_0x(char *, unsigned int *);
+
+unsigned int    scan_whitenskip(char *, unsigned int);
+unsigned int    scan_nonwhitenskip(char *, unsigned int);
+unsigned int    scan_charsetnskip(char *, char *, unsigned int);
+unsigned int    scan_noncharsetnskip(char *, char *, unsigned int);
 
-extern unsigned int scan_strncmp(char *,char *,unsigned int);
-extern unsigned int scan_memcmp(char *,char *,unsigned int);
+unsigned int    scan_strncmp(char *, char *, unsigned int);
+unsigned int    scan_memcmp(char *, char *, unsigned int);
 
-extern unsigned int scan_long(char *,long *);
-extern unsigned int scan_8long(char *,unsigned long *);
+unsigned int    scan_long(char *, long *);
+unsigned int    scan_8long(char *, unsigned long *);
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/scan_ulong.c ucspi-tcp-0.88/scan_ulong.c
--- tmp/ucspi-tcp-0.88/scan_ulong.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/scan_ulong.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,14 +1,22 @@
+/*
+ * $Log: scan_ulong.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "scan.h"
 
-unsigned int scan_ulong(register char *s,register unsigned long *u)
+unsigned int
+scan_ulong(register char *s, register unsigned long *u)
 {
-  register unsigned int pos = 0;
-  register unsigned long result = 0;
-  register unsigned long c;
-  while ((c = (unsigned long) (unsigned char) (s[pos] - '0')) < 10) {
-    result = result * 10 + c;
-    ++pos;
-  }
-  *u = result;
-  return pos;
+	register unsigned int pos = 0;
+	register unsigned long result = 0;
+	register unsigned long c;
+	while ((c = (unsigned long) (unsigned char) (s[pos] - '0')) < 10)
+	{
+		result = result * 10 + c;
+		++pos;
+	}
+	*u = result;
+	return pos;
 }
diff -Naur tmp/ucspi-tcp-0.88/scan_xlong.c ucspi-tcp-0.88/scan_xlong.c
--- tmp/ucspi-tcp-0.88/scan_xlong.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/scan_xlong.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,36 @@
+/*
+ * $Log: scan_xlong.c,v $
+ * Revision 1.1  2005-06-10 09:04:21+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "scan.h"
+
+static int
+fromhex(unsigned char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	else
+	if (c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	else
+	if (c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	return -1;
+}
+
+unsigned int
+scan_xlong(char *src, unsigned long *dest)
+{
+	register const char *tmp = src;
+	register int    l = 0;
+	register unsigned char c;
+	while ((c = fromhex(*tmp)) < 16)
+	{
+		l = (l << 4) + c;
+		++tmp;
+	}
+	*dest = l;
+	return tmp - src;
+}
diff -Naur tmp/ucspi-tcp-0.88/seek.h ucspi-tcp-0.88/seek.h
--- tmp/ucspi-tcp-0.88/seek.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/seek.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,14 +1,21 @@
+/*
+ * $Log: seek.h,v $
+ * Revision 1.2  2005-05-13 23:46:49+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef SEEK_H
 #define SEEK_H
 
 typedef unsigned long seek_pos;
 
-extern seek_pos seek_cur(int);
-
-extern int seek_set(int,seek_pos);
-extern int seek_end(int);
-
-extern int seek_trunc(int,seek_pos);
+unsigned long   seek_cur(int);
+int             seek_set(int, seek_pos);
+int             seek_end(int);
+int             seek_trunc(int, seek_pos);
 
 #define seek_begin(fd) (seek_set((fd),(seek_pos) 0))
 
diff -Naur tmp/ucspi-tcp-0.88/seek_set.c ucspi-tcp-0.88/seek_set.c
--- tmp/ucspi-tcp-0.88/seek_set.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/seek_set.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,7 +1,19 @@
+/*
+ * $Log: seek_set.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include "seek.h"
+#include <unistd.h>
 
-#define SET 0 /* sigh */
+#define SET 0					/*- sigh */
 
-int seek_set(int fd,seek_pos pos)
-{ if (lseek(fd,(off_t) pos,SET) == -1) return -1; return 0; }
+int
+seek_set(int fd, seek_pos pos)
+{
+	if (lseek(fd, (off_t) pos, SET) == -1)
+		return -1;
+	return 0;
+}
diff -Naur tmp/ucspi-tcp-0.88/setup.c ucspi-tcp-0.88/setup.c
--- tmp/ucspi-tcp-0.88/setup.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/setup.c	2009-02-08 10:10:17.000000000 +0530
@@ -0,0 +1,229 @@
+/*
+ * $Log: setup.c,v $
+ * Revision 1.2  2009-02-08 10:10:11+05:30  Cprogrammer
+ * allow installation as non-root user
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "buffer.h"
+#include "fmt.h"
+#include "str.h"
+#include "strerr.h"
+#include "error.h"
+#include "open.h"
+#include "exit.h"
+#include <unistd.h>
+#include <sys/stat.h>
+
+extern void     hier();
+
+#define FATAL "install: fatal: "
+
+int             fdsourcedir = -1;
+uid_t           my_uid;
+
+void            dd(char *, int, int, int, char *, char *);
+void            df(int, int, int, char *, char *, char *, int);
+
+void
+h(home, uid, gid, mode)
+	char           *home;
+	int             uid;
+	int             gid;
+	int             mode;
+{
+	if (mkdir(home, my_uid ? 0755 : 0700) == -1 && errno != error_exist)
+		strerr_die4sys(111, FATAL, "unable to mkdir ", home, ": ");
+	if (!my_uid && chown(home, uid, gid) == -1)
+		strerr_die4sys(111, FATAL, "unable to chown ", home, ": ");
+	if (!my_uid && chmod(home, mode) == -1)
+		strerr_die4sys(111, FATAL, "unable to chmod ", home, ": ");
+	dd("/usr/bin/mkdir", uid, gid, mode, home, 0);
+}
+
+void
+d(home, subdir, uid, gid, mode)
+	char           *home;
+	char           *subdir;
+	int             uid;
+	int             gid;
+	int             mode;
+{
+	if (chdir(home) == -1)
+		strerr_die4sys(111, FATAL, "unable to switch to ", home, ": ");
+	if (mkdir(subdir, my_uid ? 0755 : 0700) == -1 && errno != error_exist)
+		strerr_die6sys(111, FATAL, "unable to mkdir ", home, "/", subdir, ": ");
+	if (!my_uid && chown(subdir, uid, gid) == -1)
+		strerr_die6sys(111, FATAL, "unable to chown ", home, "/", subdir, ": ");
+	if (!my_uid && chmod(subdir, mode) == -1)
+		strerr_die6sys(111, FATAL, "unable to chmod ", home, "/", subdir, ": ");
+	dd("/usr/bin/mkdir", uid, gid, mode, home, subdir);
+}
+
+void
+dd(cmd, uid, gid, mode, home, subdir)
+	char           *cmd;
+	int             uid;
+	int             gid;
+	int             mode;
+	char           *home;
+	char           *subdir;
+{
+	int             a[3];
+	int             d, i, count;
+	static char     strnum[FMT_ULONG];
+
+	buffer_puts(buffer_2, cmd);
+	buffer_puts(buffer_2, " -m ");
+	d = mode;
+	for(count = i = 0;d != 0 && i < 3;++i)
+	{
+		a[i] = d % 8;
+		d /= 8;
+		count += 1;
+	}
+	buffer_puts(buffer_2, "0");
+	for(i = count - 1;i >= 0;--i)
+	{
+		strnum[fmt_ulong(strnum, a[i])] = 0;
+		buffer_puts(buffer_2, strnum);
+	}
+	buffer_puts(buffer_2, " ");
+	buffer_puts(buffer_2, home);
+	if (subdir)
+	{
+		buffer_puts(buffer_2, "/");
+		buffer_puts(buffer_2, subdir);
+	}
+	buffer_puts(buffer_2, "\n");
+	if (uid != -1 && gid != -1)
+	{
+		buffer_puts(buffer_2, "/usr/bin/chown ");
+		buffer_puts(buffer_2, "-1:-1 ");
+		buffer_puts(buffer_2, home);
+		if (subdir)
+		{
+			buffer_puts(buffer_2, "/");
+			buffer_puts(buffer_2, subdir);
+		}
+		buffer_puts(buffer_2, "\n");
+	}
+	buffer_flush(buffer_2);
+}
+
+void
+df(uid, gid, mode, file, home, subdir, strip)
+	int             uid;
+	int             gid;
+	int             mode;
+	char           *file;
+	char           *home;
+	char           *subdir;
+	int             strip;
+{
+	int             a[3];
+	int             d, i, count;
+	static char     strnum[FMT_ULONG];
+
+	buffer_puts(buffer_2, "/usr/bin/install -c ");
+	if (uid != -1 && gid != -1)
+		buffer_puts(buffer_2, "-o -1 -g -1 ");
+	buffer_puts(buffer_2, "-m ");
+	d = mode;
+	for(count = i = 0;d != 0 && i < 3;++i)
+	{
+		a[i] = d % 8;
+		d /= 8;
+		count += 1;
+	}
+	buffer_puts(buffer_2, "0");
+	for(i = count - 1;i >= 0;--i)
+	{
+		strnum[fmt_ulong(strnum, a[i])] = 0;
+		buffer_puts(buffer_2, strnum);
+	}
+	buffer_puts(buffer_2, " ");
+	if (strip)
+		buffer_puts(buffer_2, "-s ");
+	buffer_puts(buffer_2, file);
+	buffer_puts(buffer_2, " ");
+	buffer_puts(buffer_2, home);
+	buffer_puts(buffer_2, "/");
+	buffer_puts(buffer_2, subdir);
+	buffer_puts(buffer_2, "/");
+	buffer_puts(buffer_2, file);
+	buffer_puts(buffer_2, "\n");
+	buffer_flush(buffer_2);
+}
+
+char            inbuf[BUFFER_INSIZE];
+char            outbuf[BUFFER_OUTSIZE];
+buffer          ssin;
+buffer          ssout;
+
+void
+c(home, subdir, file, uid, gid, mode)
+	char           *home;
+	char           *subdir;
+	char           *file;
+	int             uid;
+	int             gid;
+	int             mode;
+{
+	int             fdin, fdout;
+	int             is_prog = 0;
+
+	if (fchdir(fdsourcedir) == -1)
+		strerr_die2sys(111, FATAL, "unable to switch back to source directory: ");
+	if ((fdin = open_read(file)) == -1)
+		strerr_die4sys(111, FATAL, "unable to read ", file, ": ");
+	buffer_init(&ssin, read, fdin, inbuf, sizeof inbuf);
+	if (chdir(home) == -1)
+		strerr_die4sys(111, FATAL, "unable to switch to ", home, ": ");
+	if (chdir(subdir) == -1)
+		strerr_die6sys(111, FATAL, "unable to switch to ", home, "/", subdir, ": ");
+	if ((fdout = open_trunc(file)) == -1)
+		strerr_die6sys(111, FATAL, "unable to write .../", subdir, "/", file, ": ");
+	buffer_init(&ssout, write, fdout, outbuf, sizeof outbuf);
+	switch (buffer_copy(&ssout, &ssin))
+	{
+	case -2:
+		strerr_die4sys(111, FATAL, "unable to read ", file, ": ");
+	case -3:
+		strerr_die6sys(111, FATAL, "unable to write .../", subdir, "/", file, ": ");
+	}
+	close(fdin);
+	if (buffer_flush(&ssout) == -1)
+		strerr_die6sys(111, FATAL, "unable to write .../", subdir, "/", file, ": ");
+	if (fsync(fdout) == -1)
+		strerr_die6sys(111, FATAL, "unable to write .../", subdir, "/", file, ": ");
+	if (close(fdout) == -1)		/*- NFS silliness */
+		strerr_die6sys(111, FATAL, "unable to write .../", subdir, "/", file, ": ");
+	if (!my_uid && chown(file, uid, gid) == -1)
+		strerr_die6sys(111, FATAL, "unable to chown .../", subdir, "/", file, ": ");
+	if (!my_uid && chmod(file, mode) == -1)
+		strerr_die6sys(111, FATAL, "unable to chmod .../", subdir, "/", file, ": ");
+	if (!str_diffn(subdir, "bin", 3))
+		is_prog = 1;
+	df(uid, gid, mode, file, home, subdir, is_prog ? 1 : 0);
+}
+
+int
+main(int argc, char **argv)
+{
+	int             i;
+
+	my_uid = getuid();
+	if ((fdsourcedir = open_read(".")) == -1)
+		strerr_die2sys(111, FATAL, "unable to open current directory: ");
+	umask(077);
+	if (argc == 1)
+		hier(0);
+	else
+	for (i = 1;i < argc;i++)
+		hier(argv[i]);
+	_exit(0);
+	/*- Not reached */
+}
diff -Naur tmp/ucspi-tcp-0.88/sgetopt.c ucspi-tcp-0.88/sgetopt.c
--- tmp/ucspi-tcp-0.88/sgetopt.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/sgetopt.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,14 +1,20 @@
-/* sgetopt.c, sgetopt.h: (yet another) improved getopt clone, outer layer
-D. J. Bernstein, djb@pobox.com.
-Depends on subgetopt.h, buffer.h.
-No system requirements.
-19991219: Switched to buffer.h.
-19970208: Cleanups.
-931201: Baseline.
-No known patent problems.
-
-Documentation in sgetopt.3.
-*/
+/*
+ * $Log: sgetopt.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ *
+ * sgetopt.c, sgetopt.h: (yet another) improved getopt clone, outer layer
+ * D. J. Bernstein, djb@pobox.com.
+ * Depends on subgetopt.h, buffer.h.
+ * No system requirements.
+ * 19991219: Switched to buffer.h.
+ * 19970208: Cleanups.
+ * 931201: Baseline.
+ * No known patent problems.
+ * 
+ * Documentation in sgetopt.3.
+ */
 
 #include "buffer.h"
 #define SGETOPTNOSHORT
@@ -22,30 +28,38 @@
 #define optproblem subgetoptproblem
 #define optprogname sgetoptprogname
 
-int opterr = 1;
-char *optprogname = 0;
+int             opterr = 1;
+char           *optprogname = 0;
 
-int getopt(int argc,char **argv,char *opts)
+int
+getopt(int argc, char **argv, char *opts)
 {
-  int c;
-  char *s;
+	int             c;
+	char           *s;
 
-  if (!optprogname) {
-    optprogname = *argv;
-    if (!optprogname) optprogname = "";
-    for (s = optprogname;*s;++s) if (*s == '/') optprogname = s + 1;
-  }
-  c = subgetopt(argc,argv,opts);
-  if (opterr)
-    if (c == '?') {
-      char chp[2]; chp[0] = optproblem; chp[1] = '\n';
-      buffer_puts(buffer_2,optprogname);
-      if (argv[optind] && (optind < argc))
-        buffer_puts(buffer_2,": illegal option -- ");
-      else
-        buffer_puts(buffer_2,": option requires an argument -- ");
-      buffer_put(buffer_2,chp,2);
-      buffer_flush(buffer_2);
-    }
-  return c;
+	if (!optprogname)
+	{
+		optprogname = *argv;
+		if (!optprogname)
+			optprogname = "";
+		for (s = optprogname; *s; ++s)
+			if (*s == '/')
+				optprogname = s + 1;
+	}
+	c = subgetopt(argc, argv, opts);
+	if (opterr)
+		if (c == '?')
+		{
+			char            chp[2];
+			chp[0] = optproblem;
+			chp[1] = '\n';
+			buffer_puts(buffer_2, optprogname);
+			if (argv[optind] && (optind < argc))
+				buffer_puts(buffer_2, ": illegal option -- ");
+			else
+				buffer_puts(buffer_2, ": option requires an argument -- ");
+			buffer_put(buffer_2, chp, 2);
+			buffer_flush(buffer_2);
+		}
+	return c;
 }
diff -Naur tmp/ucspi-tcp-0.88/sgetopt.h ucspi-tcp-0.88/sgetopt.h
--- tmp/ucspi-tcp-0.88/sgetopt.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/sgetopt.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,3 +1,15 @@
+/*
+ * $Log: sgetopt.h,v $
+ * Revision 1.3  2008-07-26 09:45:46+05:30  Cprogrammer
+ * added getopt definition
+ *
+ * Revision 1.2  2005-05-13 23:46:54+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef SGETOPT_H
 #define SGETOPT_H
 
@@ -12,10 +24,14 @@
 #define opteof subgetoptdone
 #endif
 
+
 #include "subgetopt.h"
 
-extern int sgetoptmine(int,char **,char *);
-extern int sgetopterr;
-extern char *sgetoptprogname;
 
+extern int      sgetopterr;
+extern char    *sgetoptprogname;
+
+#ifndef SGETOPTNOSHORT
+int             getopt(int, char **, char *);
+#endif
 #endif
diff -Naur tmp/ucspi-tcp-0.88/sig_block.c ucspi-tcp-0.88/sig_block.c
--- tmp/ucspi-tcp-0.88/sig_block.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/sig_block.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,38 +1,47 @@
+/*
+ * $Log: sig_block.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <signal.h>
 #include "sig.h"
 #include "hassgprm.h"
 
-void sig_block(int sig)
+void
+sig_block(int sig)
 {
 #ifdef HASSIGPROCMASK
-  sigset_t ss;
-  sigemptyset(&ss);
-  sigaddset(&ss,sig);
-  sigprocmask(SIG_BLOCK,&ss,(sigset_t *) 0);
+	sigset_t        ss;
+	sigemptyset(&ss);
+	sigaddset(&ss, sig);
+	sigprocmask(SIG_BLOCK, &ss, (sigset_t *) 0);
 #else
-  sigblock(1 << (sig - 1));
+	sigblock(1 << (sig - 1));
 #endif
 }
 
-void sig_unblock(int sig)
+void
+sig_unblock(int sig)
 {
 #ifdef HASSIGPROCMASK
-  sigset_t ss;
-  sigemptyset(&ss);
-  sigaddset(&ss,sig);
-  sigprocmask(SIG_UNBLOCK,&ss,(sigset_t *) 0);
+	sigset_t        ss;
+	sigemptyset(&ss);
+	sigaddset(&ss, sig);
+	sigprocmask(SIG_UNBLOCK, &ss, (sigset_t *) 0);
 #else
-  sigsetmask(sigsetmask(~0) & ~(1 << (sig - 1)));
+	sigsetmask(sigsetmask(~0) & ~(1 << (sig - 1)));
 #endif
 }
 
-void sig_blocknone(void)
+void
+sig_blocknone(void)
 {
 #ifdef HASSIGPROCMASK
-  sigset_t ss;
-  sigemptyset(&ss);
-  sigprocmask(SIG_SETMASK,&ss,(sigset_t *) 0);
+	sigset_t        ss;
+	sigemptyset(&ss);
+	sigprocmask(SIG_SETMASK, &ss, (sigset_t *) 0);
 #else
-  sigsetmask(0);
+	sigsetmask(0);
 #endif
 }
diff -Naur tmp/ucspi-tcp-0.88/sig.c ucspi-tcp-0.88/sig.c
--- tmp/ucspi-tcp-0.88/sig.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/sig.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,12 +1,18 @@
+/*
+ * $Log: sig.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <signal.h>
 #include "sig.h"
 
-int sig_alarm = SIGALRM;
-int sig_child = SIGCHLD;
-int sig_cont = SIGCONT;
-int sig_hangup = SIGHUP;
-int sig_pipe = SIGPIPE;
-int sig_term = SIGTERM;
+int             sig_alarm = SIGALRM;
+int             sig_child = SIGCHLD;
+int             sig_cont = SIGCONT;
+int             sig_hangup = SIGHUP;
+int             sig_pipe = SIGPIPE;
+int             sig_term = SIGTERM;
 
-void (*sig_defaulthandler)() = SIG_DFL;
-void (*sig_ignorehandler)() = SIG_IGN;
+void            (*sig_defaulthandler) () = SIG_DFL;
+void            (*sig_ignorehandler) () = SIG_IGN;
diff -Naur tmp/ucspi-tcp-0.88/sig_catch.c ucspi-tcp-0.88/sig_catch.c
--- tmp/ucspi-tcp-0.88/sig_catch.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/sig_catch.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,16 +1,23 @@
+/*
+ * $Log: sig_catch.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <signal.h>
 #include "sig.h"
 #include "hassgact.h"
 
-void sig_catch(int sig,void (*f)())
+void
+sig_catch(int sig, void (*f) ())
 {
 #ifdef HASSIGACTION
-  struct sigaction sa;
-  sa.sa_handler = f;
-  sa.sa_flags = 0;
-  sigemptyset(&sa.sa_mask);
-  sigaction(sig,&sa,(struct sigaction *) 0);
+	struct sigaction sa;
+	sa.sa_handler = f;
+	sa.sa_flags = 0;
+	sigemptyset(&sa.sa_mask);
+	sigaction(sig, &sa, (struct sigaction *) 0);
 #else
-  signal(sig,f); /* won't work under System V, even nowadays---dorks */
+	signal(sig, f);				/*- won't work under System V, even nowadays---dorks */
 #endif
 }
diff -Naur tmp/ucspi-tcp-0.88/sig.h ucspi-tcp-0.88/sig.h
--- tmp/ucspi-tcp-0.88/sig.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/sig.h	2008-07-27 18:39:40.000000000 +0530
@@ -1,3 +1,9 @@
+/*
+ * $Log: sig.h,v $
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef SIG_H
 #define SIG_H
 
diff -Naur tmp/ucspi-tcp-0.88/sig_pause.c ucspi-tcp-0.88/sig_pause.c
--- tmp/ucspi-tcp-0.88/sig_pause.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/sig_pause.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,14 +1,21 @@
+/*
+ * $Log: sig_pause.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <signal.h>
 #include "sig.h"
 #include "hassgprm.h"
 
-void sig_pause(void)
+void
+sig_pause(void)
 {
 #ifdef HASSIGPROCMASK
-  sigset_t ss;
-  sigemptyset(&ss);
-  sigsuspend(&ss);
+	sigset_t        ss;
+	sigemptyset(&ss);
+	sigsuspend(&ss);
 #else
-  sigpause(0);
+	sigpause(0);
 #endif
 }
diff -Naur tmp/ucspi-tcp-0.88/socket_accept6.c ucspi-tcp-0.88/socket_accept6.c
--- tmp/ucspi-tcp-0.88/socket_accept6.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/socket_accept6.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,55 @@
+/*
+ * $Log: socket_accept6.c,v $
+ * Revision 1.1  2005-06-10 12:13:24+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include "byte.h"
+#include "socket.h"
+#include "ip6.h"
+
+int
+socket_accept6(int s, char ip[16], uint16 * port, uint32 * scope_id)
+{
+#ifdef LIBC_HAS_IP6
+	struct sockaddr_in6 sa;
+#else
+	struct sockaddr_in sa;
+#endif
+	unsigned int    dummy = sizeof sa;
+	int             fd;
+
+	fd = accept(s, (struct sockaddr *) &sa, &dummy);
+	if (fd == -1)
+		return -1;
+
+#ifdef LIBC_HAS_IP6
+	if (sa.sin6_family == AF_INET)
+	{
+		struct sockaddr_in *sa4 = (struct sockaddr_in *) &sa;
+		byte_copy(ip, 12, V4mappedprefix);
+		byte_copy(ip + 12, 4, (char *) &sa4->sin_addr);
+		uint16_unpack_big((char *) &sa4->sin_port, port);
+		return fd;
+	}
+	byte_copy(ip, 16, (char *) &sa.sin6_addr);
+	uint16_unpack_big((char *) &sa.sin6_port, port);
+	if (scope_id)
+		*scope_id = sa.sin6_scope_id;
+
+	return fd;
+#else
+	byte_copy(ip, 12, V4mappedprefix);
+	byte_copy(ip + 12, 4, (char *) &sa.sin_addr);
+	uint16_unpack_big((char *) &sa.sin_port, port);
+	if (scope_id)
+		*scope_id = 0;
+	return fd;
+#endif
+}
+#endif
diff -Naur tmp/ucspi-tcp-0.88/socket_accept.c ucspi-tcp-0.88/socket_accept.c
--- tmp/ucspi-tcp-0.88/socket_accept.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/socket_accept.c	2008-09-17 09:33:40.000000000 +0530
@@ -1,3 +1,16 @@
+/*
+ * $Log: socket_accept.c,v $
+ * Revision 1.3  2008-07-25 16:49:38+05:30  Cprogrammer
+ * remove compilation warning
+ *
+ * Revision 1.2  2005-06-10 12:15:49+05:30  Cprogrammer
+ * conditional ipv4 compilation
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifndef IPV6
 #include <sys/types.h>
 #include <sys/param.h>
 #include <sys/socket.h>
@@ -5,17 +18,25 @@
 #include "byte.h"
 #include "socket.h"
 
-int socket_accept4(int s,char ip[4],uint16 *port)
+int
+socket_accept4(int s, char ip[4], uint16 * port)
 {
-  struct sockaddr_in sa;
-  int dummy = sizeof sa;
-  int fd;
+	struct sockaddr_in sa;
+	int             dummy = sizeof sa;
+	int             fd;
 
-  fd = accept(s,(struct sockaddr *) &sa,&dummy);
-  if (fd == -1) return -1;
-
-  byte_copy(ip,4,(char *) &sa.sin_addr);
-  uint16_unpack_big((char *) &sa.sin_port,port);
+	if ((fd = accept(s, (struct sockaddr *) &sa, &dummy)) == -1)
+		return -1;
+	byte_copy(ip, 4, (char *) &sa.sin_addr);
+	uint16_unpack_big((char *) &sa.sin_port, port);
+	return fd;
+}
+#endif
 
-  return fd;
+void
+getversion_socket_accept4_c()
+{
+	static char    *x = "$Id: socket_accept.c,v 1.3 2008-07-25 16:49:38+05:30 Cprogrammer Stab mbhangui $";
+	x++;
+	return;
 }
diff -Naur tmp/ucspi-tcp-0.88/socket_bind6.c ucspi-tcp-0.88/socket_bind6.c
--- tmp/ucspi-tcp-0.88/socket_bind6.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/socket_bind6.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,67 @@
+/*
+ * $Log: socket_bind6.c,v $
+ * Revision 1.1  2005-06-12 23:31:39+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include "byte.h"
+#include "socket.h"
+#include "ip6.h"
+#include "error.h"
+
+extern int          noipv6;
+
+int
+socket_bind6(int s, char ip[16], uint16 port, uint32 scope_id)
+{
+#ifdef LIBC_HAS_IP6
+	struct sockaddr_in6 sa;
+
+	if (noipv6)
+	{
+		int             i;
+		for (i = 0; i < 16; i++)
+		{
+			if (ip[i] != 0)
+				break;
+		}
+		if (i == 16 || ip6_isv4mapped(ip))
+			return socket_bind4(s, ip + 12, port);
+	}
+	byte_zero(&sa, sizeof sa);
+	sa.sin6_family = AF_INET6;
+	uint16_pack_big((char *) &sa.sin6_port, port);
+	/*
+	 * implicit: sa.sin6_flowinfo = 0; 
+	 */
+	byte_copy((char *) &sa.sin6_addr, 16, ip);
+	sa.sin6_scope_id = scope_id;
+	return bind(s, (struct sockaddr *) &sa, sizeof sa);
+#else
+	int             i;
+	for (i = 0; i < 16; i++)
+	{
+		if (ip[i] != 0)
+			break;
+	}
+	if (i == 16 || ip6_isv4mapped(ip))
+		return socket_bind4(s, ip + 12, port);
+	errno = error_proto;
+	return -1;
+#endif
+}
+
+int
+socket_bind6_reuse(int s, char ip[16], uint16 port, uint32 scope_id)
+{
+	int             opt = 1;
+
+	setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof opt);
+	return socket_bind6(s, ip, port, scope_id);
+}
+#endif
diff -Naur tmp/ucspi-tcp-0.88/socket_bind.c ucspi-tcp-0.88/socket_bind.c
--- tmp/ucspi-tcp-0.88/socket_bind.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/socket_bind.c	2008-07-27 18:41:46.000000000 +0530
@@ -1,33 +1,45 @@
-#include <sys/types.h>
-#include <sys/param.h>
+/*
+ * $Log: socket_bind.c,v $
+ * Revision 1.2  2005-06-10 12:16:58+05:30  Cprogrammer
+ * removed unneeded header files
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include "byte.h"
 #include "socket.h"
 
-int socket_bind4(int s,char ip[4],uint16 port)
+int
+socket_bind4(int s, char ip[4], uint16 port)
 {
-  struct sockaddr_in sa;
+	struct sockaddr_in sa;
 
-  byte_zero(&sa,sizeof sa);
-  sa.sin_family = AF_INET;
-  uint16_pack_big((char *) &sa.sin_port,port);
-  byte_copy((char *) &sa.sin_addr,4,ip);
+	byte_zero(&sa, sizeof sa);
+	sa.sin_family = AF_INET;
+	uint16_pack_big((char *) &sa.sin_port, port);
+	byte_copy((char *) &sa.sin_addr, 4, ip);
 
-  return bind(s,(struct sockaddr *) &sa,sizeof sa);
+	return bind(s, (struct sockaddr *) &sa, sizeof sa);
 }
 
-int socket_bind4_reuse(int s,char ip[4],uint16 port)
+int
+socket_bind4_reuse(int s, char ip[4], uint16 port)
 {
-  int opt = 1;
-  setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&opt,sizeof opt);
-  return socket_bind4(s,ip,port);
+	int             opt = 1;
+	setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof opt);
+	return socket_bind4(s, ip, port);
 }
 
-void socket_tryreservein(int s,int size)
+void
+socket_tryreservein(int s, int size)
 {
-  while (size >= 1024) {
-    if (setsockopt(s,SOL_SOCKET,SO_RCVBUF,&size,sizeof size) == 0) return;
-    size -= (size >> 5);
-  }
+	while (size >= 1024)
+	{
+		if (setsockopt(s, SOL_SOCKET, SO_RCVBUF, &size, sizeof size) == 0)
+			return;
+		size -= (size >> 5);
+	}
 }
diff -Naur tmp/ucspi-tcp-0.88/socket_conn6.c ucspi-tcp-0.88/socket_conn6.c
--- tmp/ucspi-tcp-0.88/socket_conn6.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/socket_conn6.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,53 @@
+/*
+ * $Log: socket_conn6.c,v $
+ * Revision 1.2  2005-06-10 12:17:10+05:30  Cprogrammer
+ * conditional ipv6 compilation
+ *
+ * Revision 1.1  2005-06-10 09:01:57+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <errno.h>
+#include "byte.h"
+#include "uint32.h"
+#include "socket.h"
+#include "ip4.h"
+#include "ip6.h"
+
+extern int          noipv6;
+
+int
+socket_connect6(int s, char ip[16], uint16 port, uint32 scope_id)
+{
+#ifdef LIBC_HAS_IP6
+	struct sockaddr_in6 sa;
+
+	if (noipv6)
+	{
+		if (ip6_isv4mapped(ip))
+			return socket_connect4(s, ip + 12, port);
+		if (byte_equal(ip, 16, V6loopback))
+			return socket_connect4(s, ip4loopback, port);
+	}
+	byte_zero(&sa, sizeof sa);
+	sa.sin6_family = PF_INET6;
+	uint16_pack_big((char *) &sa.sin6_port, port);
+	sa.sin6_flowinfo = 0;
+	sa.sin6_scope_id = scope_id;
+	byte_copy((char *) &sa.sin6_addr, 16, ip);
+	return connect(s, (struct sockaddr *) &sa, sizeof sa);
+#else
+	if (ip6_isv4mapped(ip))
+		return socket_connect4(s, ip + 12, port);
+	if (byte_equal(ip, 16, V6loopback))
+		return socket_connect4(s, ip4loopback, port);
+	errno = EPROTONOSUPPORT;
+	return -1;
+#endif
+}
+#endif
diff -Naur tmp/ucspi-tcp-0.88/socket_conn.c ucspi-tcp-0.88/socket_conn.c
--- tmp/ucspi-tcp-0.88/socket_conn.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/socket_conn.c	2008-07-27 18:41:46.000000000 +0530
@@ -1,33 +1,56 @@
-#include <sys/types.h>
-#include <sys/param.h>
+/*
+ * $Log: socket_conn.c,v $
+ * Revision 1.5  2008-07-25 16:50:04+05:30  Cprogrammer
+ * fix for darwin
+ *
+ * Revision 1.4  2008-07-17 23:04:17+05:30  Cprogrammer
+ * use unistd.h instead of readwrite.h
+ *
+ * Revision 1.3  2007-06-10 10:16:53+05:30  Cprogrammer
+ * fixed compilation warning
+ *
+ * Revision 1.2  2005-06-10 12:17:19+05:30  Cprogrammer
+ * removed unneeded header files
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <unistd.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
-#include "readwrite.h"
 #include "byte.h"
 #include "socket.h"
 
-int socket_connect4(int s,char ip[4],uint16 port)
+int
+socket_connect4(int s, char ip[4], uint16 port)
 {
-  struct sockaddr_in sa;
+	struct sockaddr_in sa;
 
-  byte_zero(&sa,sizeof sa);
-  sa.sin_family = AF_INET;
-  uint16_pack_big((char *) &sa.sin_port,port);
-  byte_copy((char *) &sa.sin_addr,4,ip);
+	byte_zero(&sa, sizeof sa);
+	sa.sin_family = AF_INET;
+	uint16_pack_big((char *) &sa.sin_port, port);
+	byte_copy((char *) &sa.sin_addr, 4, ip);
 
-  return connect(s,(struct sockaddr *) &sa,sizeof sa);
+	return connect(s, (struct sockaddr *) &sa, sizeof sa);
 }
 
-int socket_connected(int s)
+int
+socket_connected(int s)
 {
-  struct sockaddr_in sa;
-  int dummy;
-  char ch;
+	struct sockaddr_in sa;
+#if defined(__socklen_t_defined) || defined(_SOCKLEN_T)
+	socklen_t       dummy;
+#else
+	int             dummy;
+#endif
+	char            ch;
 
-  dummy = sizeof sa;
-  if (getpeername(s,(struct sockaddr *) &sa,&dummy) == -1) {
-    read(s,&ch,1); /* sets errno */
-    return 0;
-  }
-  return 1;
+	dummy = sizeof sa;
+	if (getpeername(s, (struct sockaddr *) &sa, &dummy) == -1)
+	{
+		read(s, &ch, 1);		/*- sets errno */
+		return 0;
+	}
+	return 1;
 }
diff -Naur tmp/ucspi-tcp-0.88/socket_delay.c ucspi-tcp-0.88/socket_delay.c
--- tmp/ucspi-tcp-0.88/socket_delay.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/socket_delay.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,11 +1,18 @@
+/*
+ * $Log: socket_delay.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <sys/param.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include "socket.h"
 
-int socket_tcpnodelay(int s)
+int
+socket_tcpnodelay(int s)
 {
-  int opt = 1;
-  return setsockopt(s,IPPROTO_TCP,1,&opt,sizeof opt); /* 1 == TCP_NODELAY */
+	int             opt = 1;
+	return setsockopt(s, IPPROTO_TCP, 1, &opt, sizeof opt);	/*- 1 == TCP_NODELAY */
 }
diff -Naur tmp/ucspi-tcp-0.88/socket_getifidx.c ucspi-tcp-0.88/socket_getifidx.c
--- tmp/ucspi-tcp-0.88/socket_getifidx.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/socket_getifidx.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,20 @@
+/*
+ * $Log: socket_getifidx.c,v $
+ * Revision 1.2  2005-06-10 12:17:33+05:30  Cprogrammer
+ * added uint32.h
+ *
+ * Revision 1.1  2005-06-10 09:03:23+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#include "uint32.h"
+#include "socket.h"
+
+uint32
+socket_getifidx(char *ifname)
+{
+	return if_nametoindex(ifname);
+}
diff -Naur tmp/ucspi-tcp-0.88/socket_getifname.c ucspi-tcp-0.88/socket_getifname.c
--- tmp/ucspi-tcp-0.88/socket_getifname.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/socket_getifname.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,28 @@
+/*
+ * $Log: socket_getifname.c,v $
+ * Revision 1.2  2005-06-10 12:17:40+05:30  Cprogrammer
+ * added uint32.h
+ *
+ * Revision 1.1  2005-06-10 09:03:34+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#include "uint32.h"
+#include "socket.h"
+
+static char     ifname[IFNAMSIZ];
+
+char     *
+socket_getifname(uint32 interface)
+{
+	char           *tmp = if_indextoname(interface, ifname);
+
+	if (tmp)
+		return tmp;
+	else
+		return "[unknown]";
+}
diff -Naur tmp/ucspi-tcp-0.88/socket.h ucspi-tcp-0.88/socket.h
--- tmp/ucspi-tcp-0.88/socket.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/socket.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,22 +1,65 @@
+/*
+ * $Log: socket.h,v $
+ * Revision 1.3  2005-06-10 09:13:16+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef SOCKET_H
 #define SOCKET_H
 
+#include "haveip6.h"
 #include "uint16.h"
+#ifdef LIBC_HAS_IP6
+#include "uint32.h"
+#endif
+#include <sys/socket.h>
 
-extern int socket_tcp(void);
-extern int socket_udp(void);
+int             socket_tcp(void);
+int             socket_udp(void);
+int             socket_connect4(int, char *, uint16);
+int             socket_connected(int);
+int             socket_bind4(int, char *, uint16);
+int             socket_bind4_reuse(int, char *, uint16);
+int             socket_listen(int, int);
+int             socket_accept4(int, char *, uint16 *);
+int             socket_recv4(int, char *, int, char *, uint16 *);
+int             socket_send4(int, char *, int, char *, uint16);
+int             socket_local4(int, char *, uint16 *);
+int             socket_remote4(int, char *, uint16 *);
+void            socket_tryreservein(int, int);
+#ifdef LIBC_HAS_IP6
+int             socket_tcp6(void);
+int             socket_udp6(void);
+int             socket_connect6(int, char *, uint16, uint32);
+int             socket_bind6(int, char *, uint16, uint32);
+int             socket_bind6_reuse(int, char *, uint16, uint32);
+int             socket_accept6(int, char *, uint16 *, uint32 *);
+int             socket_recv6(int, char *, unsigned int, char *, uint16 *, uint32 *);
+int             socket_send6(int, char *, unsigned int, char *, uint16, uint32);
+int             socket_local6(int, char *ip, uint16 *, uint32 *);
+int             socket_remote6(int, char *ip, uint16 *, uint32 *);
 
-extern int socket_connect4(int,char *,uint16);
-extern int socket_connected(int);
-extern int socket_bind4(int,char *,uint16);
-extern int socket_bind4_reuse(int,char *,uint16);
-extern int socket_listen(int,int);
-extern int socket_accept4(int,char *,uint16 *);
-extern int socket_recv4(int,char *,int,char *,uint16 *);
-extern int socket_send4(int,char *,int,char *,uint16);
-extern int socket_local4(int,char *,uint16 *);
-extern int socket_remote4(int,char *,uint16 *);
+/*- enable sending udp packets to the broadcast address */
+int             socket_broadcast(int);
+/*- join a multicast group on the given interface */
+int             socket_mcjoin4(int, char *, char *);
+int             socket_mcjoin6(int, char *, int);
+/*- leave a multicast group on the given interface */
+int             socket_mcleave4(int, char *);
+int             socket_mcleave6(int, char *);
+/*- set multicast TTL/hop count for outgoing packets */
+int             socket_mcttl4(int, char);
+int             socket_mcttl6(int, char);
+/*- enable multicast loopback */
+int             socket_mcloop4(int, char);
+int             socket_mcloop6(int, char);
 
-extern void socket_tryreservein(int,int);
+char           *socket_getifname(uint32);
+uint32          socket_getifidx(char *);
+extern int      noipv6;
+#endif
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/socket_ip4loopback.c ucspi-tcp-0.88/socket_ip4loopback.c
--- tmp/ucspi-tcp-0.88/socket_ip4loopback.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/socket_ip4loopback.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,7 @@
+/*
+ * $Log: socket_ip4loopback.c,v $
+ * Revision 1.1  2005-06-10 09:04:08+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+const char      ip4loopback[4] = { 127, 0, 0, 1 };
diff -Naur tmp/ucspi-tcp-0.88/socket_listen.c ucspi-tcp-0.88/socket_listen.c
--- tmp/ucspi-tcp-0.88/socket_listen.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/socket_listen.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,10 +1,17 @@
+/*
+ * $Log: socket_listen.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <sys/param.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include "socket.h"
 
-int socket_listen(int s,int backlog)
+int
+socket_listen(int s, int backlog)
 {
-  return listen(s,backlog);
+	return listen(s, backlog);
 }
diff -Naur tmp/ucspi-tcp-0.88/socket_local6.c ucspi-tcp-0.88/socket_local6.c
--- tmp/ucspi-tcp-0.88/socket_local6.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/socket_local6.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,53 @@
+/*
+ * $Log: socket_local6.c,v $
+ * Revision 1.2  2005-06-10 12:17:52+05:30  Cprogrammer
+ * conditional ipv6 compilation
+ *
+ * Revision 1.1  2005-06-10 09:02:15+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include "byte.h"
+#include "socket.h"
+#include "ip6.h"
+
+int
+socket_local6(int s, char ip[16], uint16 * port, uint32 * scope_id)
+{
+#ifdef LIBC_HAS_IP6
+	struct sockaddr_in6 sa;
+#else
+	struct sockaddr_in sa;
+#endif
+	unsigned int    dummy = sizeof sa;
+
+	if (getsockname(s, (struct sockaddr *) &sa, &dummy) == -1)
+		return -1;
+#ifdef LIBC_HAS_IP6
+	if (sa.sin6_family == AF_INET)
+	{
+		struct sockaddr_in *sa4 = (struct sockaddr_in *) &sa;
+		byte_copy(ip, 12, V4mappedprefix);
+		byte_copy(ip + 12, 4, (char *) &sa4->sin_addr);
+		uint16_unpack_big((char *) &sa4->sin_port, port);
+		return 0;
+	}
+	byte_copy(ip, 16, (char *) &sa.sin6_addr);
+	uint16_unpack_big((char *) &sa.sin6_port, port);
+	if (scope_id)
+		*scope_id = sa.sin6_scope_id;
+#else
+	byte_copy(ip, 12, V4mappedprefix);
+	byte_copy(ip + 12, 4, (char *) &sa.sin_addr);
+	uint16_unpack_big((char *) &sa.sin_port, port);
+	if (scope_id)
+		*scope_id = 0;
+#endif
+	return 0;
+}
+#endif
diff -Naur tmp/ucspi-tcp-0.88/socket_local.c ucspi-tcp-0.88/socket_local.c
--- tmp/ucspi-tcp-0.88/socket_local.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/socket_local.c	2008-09-17 09:33:43.000000000 +0530
@@ -1,3 +1,16 @@
+/*
+ * $Log: socket_local.c,v $
+ * Revision 1.3  2008-07-25 16:50:09+05:30  Cprogrammer
+ * remove compilation warning
+ *
+ * Revision 1.2  2005-06-10 12:18:04+05:30  Cprogrammer
+ * conditional ipv6 compilation
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifndef IPV6
 #include <sys/types.h>
 #include <sys/param.h>
 #include <sys/socket.h>
@@ -5,13 +18,24 @@
 #include "byte.h"
 #include "socket.h"
 
-int socket_local4(int s,char ip[4],uint16 *port)
+int
+socket_local4(int s, char ip[4], uint16 * port)
 {
-  struct sockaddr_in sa;
-  int dummy = sizeof sa;
+	struct sockaddr_in sa;
+	int             dummy = sizeof sa;
 
-  if (getsockname(s,(struct sockaddr *) &sa,&dummy) == -1) return -1;
-  byte_copy(ip,4,(char *) &sa.sin_addr);
-  uint16_unpack_big((char *) &sa.sin_port,port);
-  return 0;
+	if (getsockname(s, (struct sockaddr *) &sa, &dummy) == -1)
+		return -1;
+	byte_copy(ip, 4, (char *) &sa.sin_addr);
+	uint16_unpack_big((char *) &sa.sin_port, port);
+	return 0;
+}
+#endif
+
+void
+getversion_socket_local4_c()
+{
+	static char    *x = "$Id: socket_local.c,v 1.3 2008-07-25 16:50:09+05:30 Cprogrammer Stab mbhangui $";
+	x++;
+	return;
 }
diff -Naur tmp/ucspi-tcp-0.88/socket_opts.c ucspi-tcp-0.88/socket_opts.c
--- tmp/ucspi-tcp-0.88/socket_opts.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/socket_opts.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,10 +1,17 @@
+/*
+ * $Log: socket_opts.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <sys/param.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include "socket.h"
 
-int socket_ipoptionskill(int s)
+int
+socket_ipoptionskill(int s)
 {
-  return setsockopt(s,IPPROTO_IP,1,(char *) 0,0); /* 1 == IP_OPTIONS */
+	return setsockopt(s, IPPROTO_IP, 1, (char *) 0, 0);	/*- 1 == IP_OPTIONS */
 }
diff -Naur tmp/ucspi-tcp-0.88/socket_recv6.c ucspi-tcp-0.88/socket_recv6.c
--- tmp/ucspi-tcp-0.88/socket_recv6.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/socket_recv6.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,59 @@
+/*
+ * $Log: socket_recv6.c,v $
+ * Revision 1.2  2005-06-10 12:18:15+05:30  Cprogrammer
+ * conditional ipv6 compilation
+ *
+ * Revision 1.1  2005-06-10 09:02:06+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include "byte.h"
+#include "socket.h"
+#include "ip6.h"
+
+extern int          noipv6;
+
+int
+socket_recv6(int s, char *buf, unsigned int len, char ip[16], uint16 * port, uint32 * scope_id)
+{
+#ifdef LIBC_HAS_IP6
+	struct sockaddr_in6 sa;
+#else
+	struct sockaddr_in sa;
+#endif
+	unsigned int    dummy = sizeof sa;
+	int             r;
+
+	byte_zero(&sa, dummy);
+	r = recvfrom(s, buf, len, 0, (struct sockaddr *) &sa, &dummy);
+	if (r == -1)
+		return -1;
+
+#ifdef LIBC_HAS_IP6
+	if (noipv6)
+	{
+		struct sockaddr_in *sa4 = (struct sockaddr_in *) &sa;
+		byte_copy(ip, 12, V4mappedprefix);
+		byte_copy(ip + 12, 4, (char *) &sa4->sin_addr);
+		uint16_unpack_big((char *) &sa4->sin_port, port);
+		return r;
+	}
+	byte_copy(ip, 16, (char *) &sa.sin6_addr);
+	uint16_unpack_big((char *) &sa.sin6_port, port);
+	if (scope_id)
+		*scope_id = sa.sin6_scope_id;
+#else
+	byte_copy(ip, 12, (char *) V4mappedprefix);
+	byte_copy(ip + 12, 4, (char *) &sa.sin_addr);
+	uint16_unpack_big((char *) &sa.sin_port, port);
+	if (scope_id)
+		*scope_id = 0;
+#endif
+	return r;
+}
+#endif
diff -Naur tmp/ucspi-tcp-0.88/socket_remote.c ucspi-tcp-0.88/socket_remote.c
--- tmp/ucspi-tcp-0.88/socket_remote.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/socket_remote.c	2008-07-27 18:41:46.000000000 +0530
@@ -1,17 +1,70 @@
+/*
+ * $Log: socket_remote.c,v $
+ * Revision 1.2  2005-06-10 12:18:25+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <sys/param.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include "byte.h"
 #include "socket.h"
+#ifdef IPV6
+#include "ip6.h"
+#endif
 
-int socket_remote4(int s,char ip[4],uint16 *port)
+#ifdef IPV6
+extern int          noipv6;
+
+int
+socket_remote6(int s, char ip[16], uint16 *port, uint32 *scope_id)
+{
+#ifdef LIBC_HAS_IP6
+	struct sockaddr_in6 sa;
+#else
+	struct sockaddr_in sa;
+#endif
+	unsigned int    dummy = sizeof sa;
+
+	if (getpeername(s, (struct sockaddr *) &sa, &dummy) == -1)
+		return -1;
+#ifdef LIBC_HAS_IP6
+	if (sa.sin6_family == AF_INET)
+	{
+		struct sockaddr_in *sa4 = (struct sockaddr_in *) &sa;
+		byte_copy(ip, 12, V4mappedprefix);
+		byte_copy(ip + 12, 4, (char *) &sa4->sin_addr);
+		uint16_unpack_big((char *) &sa4->sin_port, port);
+		return 0;
+	}
+	byte_copy(ip, 16, (char *) &sa.sin6_addr);
+	uint16_unpack_big((char *) &sa.sin6_port, port);
+	if (scope_id)
+		*scope_id = sa.sin6_scope_id;
+#else
+	byte_copy(ip, 12, V4mappedprefix);
+	byte_copy(ip + 12, 4, (char *) &sa.sin_addr);
+	uint16_unpack_big((char *) &sa.sin_port, port);
+	if (scope_id)
+		*scope_id = 0;
+#endif
+	return 0;
+}
+#else
+int
+socket_remote4(int s, char ip[4], uint16 * port)
 {
-  struct sockaddr_in sa;
-  int dummy = sizeof sa;
+	struct sockaddr_in sa;
+	int             dummy = sizeof sa;
 
-  if (getpeername(s,(struct sockaddr *) &sa,&dummy) == -1) return -1;
-  byte_copy(ip,4,(char *) &sa.sin_addr);
-  uint16_unpack_big((char *) &sa.sin_port,port);
-  return 0;
+	if (getpeername(s, (struct sockaddr *) &sa, &dummy) == -1)
+		return -1;
+	byte_copy(ip, 4, (char *) &sa.sin_addr);
+	uint16_unpack_big((char *) &sa.sin_port, port);
+	return 0;
 }
+#endif
diff -Naur tmp/ucspi-tcp-0.88/socket_send6.c ucspi-tcp-0.88/socket_send6.c
--- tmp/ucspi-tcp-0.88/socket_send6.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/socket_send6.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,56 @@
+/*
+ * $Log: socket_send6.c,v $
+ * Revision 1.2  2005-06-10 12:18:47+05:30  Cprogrammer
+ * conditional ipv6 compilation
+ *
+ * Revision 1.1  2005-06-10 09:02:11+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include "byte.h"
+#include "socket.h"
+#include "ip4.h"
+#include "ip6.h"
+#include "error.h"
+
+extern int          noipv6;
+
+int
+socket_send6(int s, char *buf, unsigned int len, char ip[16], uint16 port, uint32 scope_id)
+{
+#ifdef LIBC_HAS_IP6
+	struct sockaddr_in6 sa;
+#else
+	struct sockaddr_in sa;
+#endif
+
+	byte_zero(&sa, sizeof sa);
+#ifdef LIBC_HAS_IP6
+	if (noipv6)
+	{
+		if (ip6_isv4mapped(ip))
+			return socket_send4(s, buf, len, ip + 12, port);
+		if (byte_equal(ip, 16, V6loopback))
+			return socket_send4(s, buf, len, ip4loopback, port);
+		errno = error_proto;
+		return -1;
+	}
+	sa.sin6_family = AF_INET6;
+	uint16_pack_big((char *) &sa.sin6_port, port);
+	byte_copy((char *) &sa.sin6_addr, 16, ip);
+	return sendto(s, buf, len, 0, (struct sockaddr *) &sa, sizeof sa);
+#else
+		if (ip6_isv4mapped(ip))
+			return socket_send4(s, buf, len, ip + 12, port);
+		if (byte_equal(ip, 16, V6loopback))
+			return socket_send4(s, buf, len, ip4loopback, port);
+		errno = error_proto;
+		return -1;
+#endif
+}
+#endif
diff -Naur tmp/ucspi-tcp-0.88/socket_tcp6.c ucspi-tcp-0.88/socket_tcp6.c
--- tmp/ucspi-tcp-0.88/socket_tcp6.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/socket_tcp6.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,59 @@
+/*
+ * $Log: socket_tcp6.c,v $
+ * Revision 1.3  2007-06-10 10:17:00+05:30  Cprogrammer
+ * fixed compilation warning
+ *
+ * Revision 1.2  2005-06-10 12:18:57+05:30  Cprogrammer
+ * conditional ipv6 compilation
+ *
+ * Revision 1.1  2005-06-10 09:02:22+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <errno.h>
+#include <unistd.h>
+#include "ndelay.h"
+#include "socket.h"
+
+#ifdef LIBC_HAS_IP6
+int             noipv6 = 0;
+#else
+int             noipv6 = 1;
+#endif
+
+int
+socket_tcp6(void)
+{
+#ifdef LIBC_HAS_IP6
+	int             s;
+
+	if (noipv6)
+		goto compat;
+	if ((s = socket(PF_INET6, SOCK_STREAM, 0)) == -1)
+	{
+		if (errno == EINVAL || errno == EAFNOSUPPORT)
+		{
+compat:
+			s = socket(AF_INET, SOCK_STREAM, 0);
+			noipv6 = 1;
+			if (s == -1)
+				return -1;
+		} else
+			return -1;
+	}
+	if (ndelay_on(s) == -1)
+	{
+		close(s);
+		return -1;
+	}
+	return s;
+#else
+	return socket_tcp();
+#endif
+}
+#endif
diff -Naur tmp/ucspi-tcp-0.88/socket_tcp.c ucspi-tcp-0.88/socket_tcp.c
--- tmp/ucspi-tcp-0.88/socket_tcp.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/socket_tcp.c	2008-07-27 18:41:46.000000000 +0530
@@ -1,16 +1,33 @@
+/*
+ * $Log: socket_tcp.c,v $
+ * Revision 1.3  2007-06-10 10:17:25+05:30  Cprogrammer
+ * fixed compilation warning
+ *
+ * Revision 1.2  2005-06-10 12:19:07+05:30  Cprogrammer
+ * conditional ipv6 compilation
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
-#include <sys/param.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
+#include <unistd.h>
 #include "ndelay.h"
-#include "socket.h"
 
-int socket_tcp(void)
+int
+socket_tcp(void)
 {
-  int s;
+	int             s;
 
-  s = socket(AF_INET,SOCK_STREAM,0);
-  if (s == -1) return -1;
-  if (ndelay_on(s) == -1) { close(s); return -1; }
-  return s;
+	s = socket(AF_INET, SOCK_STREAM, 0);
+	if (s == -1)
+		return -1;
+	if (ndelay_on(s) == -1)
+	{
+		close(s);
+		return -1;
+	}
+	return s;
 }
diff -Naur tmp/ucspi-tcp-0.88/socket_udp.c ucspi-tcp-0.88/socket_udp.c
--- tmp/ucspi-tcp-0.88/socket_udp.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/socket_udp.c	2008-07-27 18:41:46.000000000 +0530
@@ -1,16 +1,68 @@
+/*
+ * $Log: socket_udp.c,v $
+ * Revision 1.2  2005-06-10 12:19:17+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
-#include <sys/param.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
-#include "ndelay.h"
 #include "socket.h"
+#ifdef IPV6
+#include <errno.h>
+
+#ifndef EAFNOSUPPORT
+#define EAFNOSUPPORT EINVAL
+#endif
+
+extern int          noipv6;
 
-int socket_udp(void)
+int
+socket_udp6(void)
 {
-  int s;
+#ifdef LIBC_HAS_IP6
+	int             s;
 
-  s = socket(AF_INET,SOCK_DGRAM,0);
-  if (s == -1) return -1;
-  if (ndelay_on(s) == -1) { close(s); return -1; }
-  return s;
+	if (noipv6)
+		goto compat;
+	if ((s = socket(PF_INET6, SOCK_DGRAM, 0)) == -1)
+	{
+		if (errno == EINVAL || errno == EAFNOSUPPORT)
+		{
+compat:
+			s = socket(AF_INET, SOCK_DGRAM, 0);
+			noipv6 = 1;
+			if (s == -1)
+				return -1;
+		} else
+			return -1;
+	}
+	return s;
+#else
+	return socket_udp();
+#endif
 }
+#else
+#include "ndelay.h"
+#include <unistd.h>
+
+int
+socket_udp(void)
+{
+	int             s;
+
+	s = socket(AF_INET, SOCK_DGRAM, 0);
+	if (s == -1)
+		return -1;
+	if (ndelay_on(s) == -1)
+	{
+		close(s);
+		return -1;
+	}
+	return s;
+}
+
+#endif
diff -Naur tmp/ucspi-tcp-0.88/socket_v4mappedprefix.c ucspi-tcp-0.88/socket_v4mappedprefix.c
--- tmp/ucspi-tcp-0.88/socket_v4mappedprefix.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/socket_v4mappedprefix.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,12 @@
+/*
+ * $Log: socket_v4mappedprefix.c,v $
+ * Revision 1.2  2005-06-10 12:19:23+05:30  Cprogrammer
+ * conditional ipv6 compilation
+ *
+ * Revision 1.1  2005-06-10 09:04:10+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+unsigned char V4mappedprefix[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };
+#endif
diff -Naur tmp/ucspi-tcp-0.88/socket_v6any.c ucspi-tcp-0.88/socket_v6any.c
--- tmp/ucspi-tcp-0.88/socket_v6any.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/socket_v6any.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,12 @@
+/*
+ * $Log: socket_v6any.c,v $
+ * Revision 1.2  2005-06-10 12:19:26+05:30  Cprogrammer
+ * conditional ipv6 compilation
+ *
+ * Revision 1.1  2005-06-10 08:29:41+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+unsigned char V6any[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+#endif
diff -Naur tmp/ucspi-tcp-0.88/socket_v6loopback.c ucspi-tcp-0.88/socket_v6loopback.c
--- tmp/ucspi-tcp-0.88/socket_v6loopback.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/socket_v6loopback.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,12 @@
+/*
+ * $Log: socket_v6loopback.c,v $
+ * Revision 1.2  2005-06-10 12:19:31+05:30  Cprogrammer
+ * conditional ipv6 compilation
+ *
+ * Revision 1.1  2005-06-10 09:04:05+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifdef IPV6
+const unsigned char V6loopback[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
+#endif
diff -Naur tmp/ucspi-tcp-0.88/stralloc_catb.c ucspi-tcp-0.88/stralloc_catb.c
--- tmp/ucspi-tcp-0.88/stralloc_catb.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/stralloc_catb.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,12 +1,21 @@
+/*
+ * $Log: stralloc_catb.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "stralloc.h"
 #include "byte.h"
 
-int stralloc_catb(stralloc *sa,char *s,unsigned int n)
+int
+stralloc_catb(stralloc * sa, char *s, unsigned int n)
 {
-  if (!sa->s) return stralloc_copyb(sa,s,n);
-  if (!stralloc_readyplus(sa,n + 1)) return 0;
-  byte_copy(sa->s + sa->len,n,s);
-  sa->len += n;
-  sa->s[sa->len] = 'Z'; /* ``offensive programming'' */
-  return 1;
+	if (!sa->s)
+		return stralloc_copyb(sa, s, n);
+	if (!stralloc_readyplus(sa, n + 1))
+		return 0;
+	byte_copy(sa->s + sa->len, n, s);
+	sa->len += n;
+	sa->s[sa->len] = 'Z';		/*- ``offensive programming'' */
+	return 1;
 }
diff -Naur tmp/ucspi-tcp-0.88/stralloc_cat.c ucspi-tcp-0.88/stralloc_cat.c
--- tmp/ucspi-tcp-0.88/stralloc_cat.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/stralloc_cat.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,7 +1,14 @@
+/*
+ * $Log: stralloc_cat.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "byte.h"
 #include "stralloc.h"
 
-int stralloc_cat(stralloc *sato,stralloc *safrom)
+int
+stralloc_cat(stralloc * sato, stralloc * safrom)
 {
-  return stralloc_catb(sato,safrom->s,safrom->len);
+	return stralloc_catb(sato, safrom->s, safrom->len);
 }
diff -Naur tmp/ucspi-tcp-0.88/stralloc_cats.c ucspi-tcp-0.88/stralloc_cats.c
--- tmp/ucspi-tcp-0.88/stralloc_cats.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/stralloc_cats.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,8 +1,15 @@
+/*
+ * $Log: stralloc_cats.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "byte.h"
 #include "str.h"
 #include "stralloc.h"
 
-int stralloc_cats(stralloc *sa,char *s)
+int
+stralloc_cats(stralloc * sa, char *s)
 {
-  return stralloc_catb(sa,s,str_len(s));
+	return stralloc_catb(sa, s, str_len(s));
 }
diff -Naur tmp/ucspi-tcp-0.88/stralloc_copy.c ucspi-tcp-0.88/stralloc_copy.c
--- tmp/ucspi-tcp-0.88/stralloc_copy.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/stralloc_copy.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,7 +1,14 @@
+/*
+ * $Log: stralloc_copy.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "byte.h"
 #include "stralloc.h"
 
-int stralloc_copy(stralloc *sato,stralloc *safrom)
+int
+stralloc_copy(stralloc * sato, stralloc * safrom)
 {
-  return stralloc_copyb(sato,safrom->s,safrom->len);
+	return stralloc_copyb(sato, safrom->s, safrom->len);
 }
diff -Naur tmp/ucspi-tcp-0.88/stralloc_eady.c ucspi-tcp-0.88/stralloc_eady.c
--- tmp/ucspi-tcp-0.88/stralloc_eady.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/stralloc_eady.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,6 +1,12 @@
+/*
+ * $Log: stralloc_eady.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "alloc.h"
 #include "stralloc.h"
 #include "gen_allocdefs.h"
 
-GEN_ALLOC_ready(stralloc,char,s,len,a,i,n,x,30,stralloc_ready)
-GEN_ALLOC_readyplus(stralloc,char,s,len,a,i,n,x,30,stralloc_readyplus)
+GEN_ALLOC_ready(stralloc, char, s, len, a, i, n, x, 30, stralloc_ready)
+GEN_ALLOC_readyplus(stralloc, char, s, len, a, i, n, x, 30, stralloc_readyplus)
diff -Naur tmp/ucspi-tcp-0.88/stralloc.h ucspi-tcp-0.88/stralloc.h
--- tmp/ucspi-tcp-0.88/stralloc.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/stralloc.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,25 +1,33 @@
+/*
+ * $Log: stralloc.h,v $
+ * Revision 1.2  2005-05-13 23:53:33+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef STRALLOC_H
 #define STRALLOC_H
 
 #include "gen_alloc.h"
 
-GEN_ALLOC_typedef(stralloc,char,s,len,a)
-
-extern int stralloc_ready(stralloc *,unsigned int);
-extern int stralloc_readyplus(stralloc *,unsigned int);
-extern int stralloc_copy(stralloc *,stralloc *);
-extern int stralloc_cat(stralloc *,stralloc *);
-extern int stralloc_copys(stralloc *,char *);
-extern int stralloc_cats(stralloc *,char *);
-extern int stralloc_copyb(stralloc *,char *,unsigned int);
-extern int stralloc_catb(stralloc *,char *,unsigned int);
-extern int stralloc_append(stralloc *,char *); /* beware: this takes a pointer to 1 char */
-extern int stralloc_starts(stralloc *,char *);
+GEN_ALLOC_typedef(stralloc, char, s, len, a)
+int             stralloc_ready(stralloc *, unsigned int);
+int             stralloc_readyplus(stralloc *, unsigned int);
+int             stralloc_copy(stralloc *, stralloc *);
+int             stralloc_cat(stralloc *, stralloc *);
+int             stralloc_copys(stralloc *, char *);
+int             stralloc_cats(stralloc *, char *);
+int             stralloc_copyb(stralloc *, char *, unsigned int);
+int             stralloc_catb(stralloc *, char *, unsigned int);
+int             stralloc_append(stralloc *, char *);	/*- beware: this takes a pointer to 1 char */
+int             stralloc_starts(stralloc *, char *);
 
 #define stralloc_0(sa) stralloc_append(sa,"")
 
-extern int stralloc_catulong0(stralloc *,unsigned long,unsigned int);
-extern int stralloc_catlong0(stralloc *,long,unsigned int);
+int             stralloc_catulong0(stralloc *, unsigned long, unsigned int);
+int             stralloc_catlong0(stralloc *, long, unsigned int);
 
 #define stralloc_catlong(sa,l) (stralloc_catlong0((sa),(l),0))
 #define stralloc_catuint0(sa,i,n) (stralloc_catulong0((sa),(i),(n)))
diff -Naur tmp/ucspi-tcp-0.88/stralloc_opyb.c ucspi-tcp-0.88/stralloc_opyb.c
--- tmp/ucspi-tcp-0.88/stralloc_opyb.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/stralloc_opyb.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,11 +1,19 @@
+/*
+ * $Log: stralloc_opyb.c,v $
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "stralloc.h"
 #include "byte.h"
 
-int stralloc_copyb(stralloc *sa,char *s,unsigned int n)
+int
+stralloc_copyb(stralloc * sa, char *s, unsigned int n)
 {
-  if (!stralloc_ready(sa,n + 1)) return 0;
-  byte_copy(sa->s,n,s);
-  sa->len = n;
-  sa->s[n] = 'Z'; /* ``offensive programming'' */
-  return 1;
+	if (!stralloc_ready(sa, n + 1))
+		return 0;
+	byte_copy(sa->s, n, s);
+	sa->len = n;
+	sa->s[n] = 'Z';				/*- ``offensive programming'' */
+	return 1;
 }
diff -Naur tmp/ucspi-tcp-0.88/stralloc_opys.c ucspi-tcp-0.88/stralloc_opys.c
--- tmp/ucspi-tcp-0.88/stralloc_opys.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/stralloc_opys.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,8 +1,15 @@
+/*
+ * $Log: stralloc_opys.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "byte.h"
 #include "str.h"
 #include "stralloc.h"
 
-int stralloc_copys(stralloc *sa,char *s)
+int
+stralloc_copys(stralloc * sa, char *s)
 {
-  return stralloc_copyb(sa,s,str_len(s));
+	return stralloc_copyb(sa, s, str_len(s));
 }
diff -Naur tmp/ucspi-tcp-0.88/stralloc_pend.c ucspi-tcp-0.88/stralloc_pend.c
--- tmp/ucspi-tcp-0.88/stralloc_pend.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/stralloc_pend.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,5 +1,11 @@
+/*
+ * $Log: stralloc_pend.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "alloc.h"
 #include "stralloc.h"
 #include "gen_allocdefs.h"
 
-GEN_ALLOC_append(stralloc,char,s,len,a,i,n,x,30,stralloc_readyplus,stralloc_append)
+GEN_ALLOC_append(stralloc, char, s, len, a, i, n, x, 30, stralloc_readyplus, stralloc_append)
diff -Naur tmp/ucspi-tcp-0.88/str_chr.c ucspi-tcp-0.88/str_chr.c
--- tmp/ucspi-tcp-0.88/str_chr.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/str_chr.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,17 +1,41 @@
+/*
+ * $Log: str_chr.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "str.h"
 
-unsigned int str_chr(register char *s,int c)
+unsigned int
+str_chr(register char *s, int c)
 {
-  register char ch;
-  register char *t;
+	register char   ch;
+	register char  *t;
 
-  ch = c;
-  t = s;
-  for (;;) {
-    if (!*t) break; if (*t == ch) break; ++t;
-    if (!*t) break; if (*t == ch) break; ++t;
-    if (!*t) break; if (*t == ch) break; ++t;
-    if (!*t) break; if (*t == ch) break; ++t;
-  }
-  return t - s;
+	ch = c;
+	t = s;
+	for (;;)
+	{
+		if (!*t)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+		if (!*t)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+		if (!*t)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+		if (!*t)
+			break;
+		if (*t == ch)
+			break;
+		++t;
+	}
+	return t - s;
 }
diff -Naur tmp/ucspi-tcp-0.88/str_diff.c ucspi-tcp-0.88/str_diff.c
--- tmp/ucspi-tcp-0.88/str_diff.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/str_diff.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,15 +1,46 @@
+/*
+ * $Log: str_diff.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "str.h"
 
-int str_diff(register char *s,register char *t)
+int
+str_diff(register char *s, register char *t)
 {
-  register char x;
+	register char   x;
 
-  for (;;) {
-    x = *s; if (x != *t) break; if (!x) break; ++s; ++t;
-    x = *s; if (x != *t) break; if (!x) break; ++s; ++t;
-    x = *s; if (x != *t) break; if (!x) break; ++s; ++t;
-    x = *s; if (x != *t) break; if (!x) break; ++s; ++t;
-  }
-  return ((int)(unsigned int)(unsigned char) x)
-       - ((int)(unsigned int)(unsigned char) *t);
+	for (;;)
+	{
+		x = *s;
+		if (x != *t)
+			break;
+		if (!x)
+			break;
+		++s;
+		++t;
+		x = *s;
+		if (x != *t)
+			break;
+		if (!x)
+			break;
+		++s;
+		++t;
+		x = *s;
+		if (x != *t)
+			break;
+		if (!x)
+			break;
+		++s;
+		++t;
+		x = *s;
+		if (x != *t)
+			break;
+		if (!x)
+			break;
+		++s;
+		++t;
+	}
+	return ((int) (unsigned int) (unsigned char) x) - ((int) (unsigned int) (unsigned char) *t);
 }
diff -Naur tmp/ucspi-tcp-0.88/str_diffn.c ucspi-tcp-0.88/str_diffn.c
--- tmp/ucspi-tcp-0.88/str_diffn.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/str_diffn.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,57 @@
+/*
+ * $Log: str_diffn.c,v $
+ * Revision 1.1  2003-12-27 17:16:07+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include "str.h"
+
+int
+str_diffn(s, t, len)
+	register char  *s;
+	register char  *t;
+	unsigned int    len;
+{
+	register char   x;
+
+	for (;;)
+	{
+		if (!len--)
+			return 0;
+		x = *s;
+		if (x != *t)
+			break;
+		if (!x)
+			break;
+		++s;
+		++t;
+		if (!len--)
+			return 0;
+		x = *s;
+		if (x != *t)
+			break;
+		if (!x)
+			break;
+		++s;
+		++t;
+		if (!len--)
+			return 0;
+		x = *s;
+		if (x != *t)
+			break;
+		if (!x)
+			break;
+		++s;
+		++t;
+		if (!len--)
+			return 0;
+		x = *s;
+		if (x != *t)
+			break;
+		if (!x)
+			break;
+		++s;
+		++t;
+	}
+	return ((int) (unsigned int) (unsigned char) x) - ((int) (unsigned int) (unsigned char) *t);
+}
diff -Naur tmp/ucspi-tcp-0.88/strerr_die.c ucspi-tcp-0.88/strerr_die.c
--- tmp/ucspi-tcp-0.88/strerr_die.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/strerr_die.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,31 +1,49 @@
+/*
+ * $Log: strerr_die.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "buffer.h"
 #include "exit.h"
 #include "strerr.h"
 
-void strerr_warn(char *x1,char *x2,char *x3,char *x4,char *x5,char *x6,struct strerr *se)
+void
+strerr_warn(char *x1, char *x2, char *x3, char *x4, char *x5, char *x6, struct strerr *se)
 {
-  strerr_sysinit();
- 
-  if (x1) buffer_puts(buffer_2,x1);
-  if (x2) buffer_puts(buffer_2,x2);
-  if (x3) buffer_puts(buffer_2,x3);
-  if (x4) buffer_puts(buffer_2,x4);
-  if (x5) buffer_puts(buffer_2,x5);
-  if (x6) buffer_puts(buffer_2,x6);
- 
-  while(se) {
-    if (se->x) buffer_puts(buffer_2,se->x);
-    if (se->y) buffer_puts(buffer_2,se->y);
-    if (se->z) buffer_puts(buffer_2,se->z);
-    se = se->who;
-  }
- 
-  buffer_puts(buffer_2,"\n");
-  buffer_flush(buffer_2);
+	strerr_sysinit();
+
+	if (x1)
+		buffer_puts(buffer_2, x1);
+	if (x2)
+		buffer_puts(buffer_2, x2);
+	if (x3)
+		buffer_puts(buffer_2, x3);
+	if (x4)
+		buffer_puts(buffer_2, x4);
+	if (x5)
+		buffer_puts(buffer_2, x5);
+	if (x6)
+		buffer_puts(buffer_2, x6);
+
+	while (se)
+	{
+		if (se->x)
+			buffer_puts(buffer_2, se->x);
+		if (se->y)
+			buffer_puts(buffer_2, se->y);
+		if (se->z)
+			buffer_puts(buffer_2, se->z);
+		se = se->who;
+	}
+
+	buffer_puts(buffer_2, "\n");
+	buffer_flush(buffer_2);
 }
 
-void strerr_die(int e,char *x1,char *x2,char *x3,char *x4,char *x5,char *x6,struct strerr *se)
+void
+strerr_die(int e, char *x1, char *x2, char *x3, char *x4, char *x5, char *x6, struct strerr *se)
 {
-  strerr_warn(x1,x2,x3,x4,x5,x6,se);
-  _exit(e);
+	strerr_warn(x1, x2, x3, x4, x5, x6, se);
+	_exit(e);
 }
diff -Naur tmp/ucspi-tcp-0.88/strerr.h ucspi-tcp-0.88/strerr.h
--- tmp/ucspi-tcp-0.88/strerr.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/strerr.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,19 +1,29 @@
+/*
+ * $Log: strerr.h,v $
+ * Revision 1.2  2005-05-13 23:53:37+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef STRERR_H
 #define STRERR_H
 
-struct strerr {
-  struct strerr *who;
-  char *x;
-  char *y;
-  char *z;
-} ;
+struct strerr
+{
+	struct strerr  *who;
+	char           *x;
+	char           *y;
+	char           *z;
+};
 
 extern struct strerr strerr_sys;
-extern void strerr_sysinit(void);
+void            strerr_sysinit(void);
 
-extern char *strerr(struct strerr *);
-extern void strerr_warn(char *,char *,char *,char *,char *,char *,struct strerr *);
-extern void strerr_die(int,char *,char *,char *,char *,char *,char *,struct strerr *);
+char           *strerr(struct strerr *);
+void            strerr_warn(char *, char *, char *, char *, char *, char *, struct strerr *);
+void            strerr_die(int, char *, char *, char *, char *, char *, char *, struct strerr *);
 
 #define STRERR(r,se,a) \
 { se.who = 0; se.x = a; se.y = 0; se.z = 0; return r; }
diff -Naur tmp/ucspi-tcp-0.88/strerr_sys.c ucspi-tcp-0.88/strerr_sys.c
--- tmp/ucspi-tcp-0.88/strerr_sys.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/strerr_sys.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,12 +1,19 @@
+/*
+ * $Log: strerr_sys.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "error.h"
 #include "strerr.h"
 
-struct strerr strerr_sys;
+struct strerr   strerr_sys;
 
-void strerr_sysinit(void)
+void
+strerr_sysinit(void)
 {
-  strerr_sys.who = 0;
-  strerr_sys.x = error_str(errno);
-  strerr_sys.y = "";
-  strerr_sys.z = "";
+	strerr_sys.who = 0;
+	strerr_sys.x = error_str(errno);
+	strerr_sys.y = "";
+	strerr_sys.z = "";
 }
diff -Naur tmp/ucspi-tcp-0.88/str.h ucspi-tcp-0.88/str.h
--- tmp/ucspi-tcp-0.88/str.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/str.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,13 +1,22 @@
+/*
+ * $Log: str.h,v $
+ * Revision 1.2  2005-05-13 23:53:41+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef STR_H
 #define STR_H
 
-extern unsigned int str_copy(char *,char *);
-extern int str_diff(char *,char *);
-extern int str_diffn(char *,char *,unsigned int);
-extern unsigned int str_len(char *);
-extern unsigned int str_chr(char *,int);
-extern unsigned int str_rchr(char *,int);
-extern int str_start(char *,char *);
+unsigned int    str_copy(char *, char *);
+int             str_diff(char *, char *);
+int             str_diffn(char *, char *, unsigned int);
+unsigned int    str_len(char *);
+unsigned int    str_chr(char *, int);
+unsigned int    str_rchr(char *, int);
+int             str_start(char *, char *);
 
 #define str_equal(s,t) (!str_diff((s),(t)))
 
diff -Naur tmp/ucspi-tcp-0.88/str_len.c ucspi-tcp-0.88/str_len.c
--- tmp/ucspi-tcp-0.88/str_len.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/str_len.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,14 +1,30 @@
+/*
+ * $Log: str_len.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "str.h"
 
-unsigned int str_len(char *s)
+unsigned int
+str_len(char *s)
 {
-  register char *t;
+	register char  *t;
 
-  t = s;
-  for (;;) {
-    if (!*t) return t - s; ++t;
-    if (!*t) return t - s; ++t;
-    if (!*t) return t - s; ++t;
-    if (!*t) return t - s; ++t;
-  }
+	t = s;
+	for (;;)
+	{
+		if (!*t)
+			return t - s;
+		++t;
+		if (!*t)
+			return t - s;
+		++t;
+		if (!*t)
+			return t - s;
+		++t;
+		if (!*t)
+			return t - s;
+		++t;
+	}
 }
diff -Naur tmp/ucspi-tcp-0.88/str_start.c ucspi-tcp-0.88/str_start.c
--- tmp/ucspi-tcp-0.88/str_start.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/str_start.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,13 +1,37 @@
+/*
+ * $Log: str_start.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "str.h"
 
-int str_start(register char *s,register char *t)
+int
+str_start(register char *s, register char *t)
 {
-  register char x;
+	register char   x;
 
-  for (;;) {
-    x = *t++; if (!x) return 1; if (x != *s++) return 0;
-    x = *t++; if (!x) return 1; if (x != *s++) return 0;
-    x = *t++; if (!x) return 1; if (x != *s++) return 0;
-    x = *t++; if (!x) return 1; if (x != *s++) return 0;
-  }
+	for (;;)
+	{
+		x = *t++;
+		if (!x)
+			return 1;
+		if (x != *s++)
+			return 0;
+		x = *t++;
+		if (!x)
+			return 1;
+		if (x != *s++)
+			return 0;
+		x = *t++;
+		if (!x)
+			return 1;
+		if (x != *s++)
+			return 0;
+		x = *t++;
+		if (!x)
+			return 1;
+		if (x != *s++)
+			return 0;
+	}
 }
diff -Naur tmp/ucspi-tcp-0.88/subgetopt.c ucspi-tcp-0.88/subgetopt.c
--- tmp/ucspi-tcp-0.88/subgetopt.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/subgetopt.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,3 +1,9 @@
+/*
+ * $Log: subgetopt.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #define SUBGETOPTNOSHORT
 #include "subgetopt.h"
 
@@ -8,58 +14,76 @@
 #define optproblem subgetoptproblem
 #define optdone subgetoptdone
 
-int optind = 1;
-int optpos = 0;
-char *optarg = 0;
-int optproblem = 0;
-int optdone = SUBGETOPTDONE;
+int             optind = 1;
+int             optpos = 0;
+char           *optarg = 0;
+int             optproblem = 0;
+int             optdone = SUBGETOPTDONE;
 
-int sgopt(int argc,char **argv,char *opts)
+int
+sgopt(int argc, char **argv, char *opts)
 {
-  int c;
-  char *s;
+	int             c;
+	char           *s;
 
-  optarg = 0;
-  if (!argv || (optind >= argc) || !argv[optind]) return optdone;
-  if (optpos && !argv[optind][optpos]) {
-    ++optind;
-    optpos = 0;
-    if ((optind >= argc) || !argv[optind]) return optdone;
-  }
-  if (!optpos) {
-    if (argv[optind][0] != '-') return optdone;
-    ++optpos;
-    c = argv[optind][1];
-    if ((c == '-') || (c == 0)) {
-      if (c) ++optind;
-      optpos = 0;
-      return optdone;
-    }
-    /* otherwise c is reassigned below */
-  }
-  c = argv[optind][optpos];
-  ++optpos;
-  s = opts;
-  while (*s) {
-    if (c == *s) {
-      if (s[1] == ':') {
-        optarg = argv[optind] + optpos;
-        ++optind;
-        optpos = 0;
-        if (!*optarg) {
-          optarg = argv[optind];
-          if ((optind >= argc) || !optarg) { /* argument past end */
-            optproblem = c;
-            return '?';
-          }
-	  ++optind;
-        }
-      }
-      return c;
-    }
-    ++s;
-    if (*s == ':') ++s;
-  }
-  optproblem = c;
-  return '?';
+	optarg = 0;
+	if (!argv || (optind >= argc) || !argv[optind])
+		return optdone;
+	if (optpos && !argv[optind][optpos])
+	{
+		++optind;
+		optpos = 0;
+		if ((optind >= argc) || !argv[optind])
+			return optdone;
+	}
+	if (!optpos)
+	{
+		if (argv[optind][0] != '-')
+			return optdone;
+		++optpos;
+		c = argv[optind][1];
+		if ((c == '-') || (c == 0))
+		{
+			if (c)
+				++optind;
+			optpos = 0;
+			return optdone;
+		}
+		/*
+		 * otherwise c is reassigned below 
+		 */
+	}
+	c = argv[optind][optpos];
+	++optpos;
+	s = opts;
+	while (*s)
+	{
+		if (c == *s)
+		{
+			if (s[1] == ':')
+			{
+				optarg = argv[optind] + optpos;
+				++optind;
+				optpos = 0;
+				if (!*optarg)
+				{
+					optarg = argv[optind];
+					if ((optind >= argc) || !optarg)
+					{			/*
+								 * argument past end 
+								 */
+						optproblem = c;
+						return '?';
+					}
+					++optind;
+				}
+			}
+			return c;
+		}
+		++s;
+		if (*s == ':')
+			++s;
+	}
+	optproblem = c;
+	return '?';
 }
diff -Naur tmp/ucspi-tcp-0.88/subgetopt.h ucspi-tcp-0.88/subgetopt.h
--- tmp/ucspi-tcp-0.88/subgetopt.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/subgetopt.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,3 +1,12 @@
+/*
+ * $Log: subgetopt.h,v $
+ * Revision 1.2  2005-05-13 23:53:46+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef SUBGETOPT_H
 #define SUBGETOPT_H
 
@@ -13,12 +22,12 @@
 
 #define SUBGETOPTDONE -1
 
-extern int subgetopt(int,char **,char *);
-extern char *subgetoptarg;
-extern int subgetoptind;
-extern int subgetoptpos;
-extern int subgetoptproblem;
-extern char *subgetoptprogname;
-extern int subgetoptdone;
+int             subgetopt(int,char **,char *);
+extern char    *subgetoptarg;
+extern int      subgetoptind;
+extern int      subgetoptpos;
+extern int      subgetoptproblem;
+extern char    *subgetoptprogname;
+extern int      subgetoptdone;
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/taia_add.c ucspi-tcp-0.88/taia_add.c
--- tmp/ucspi-tcp-0.88/taia_add.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/taia_add.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,18 +1,29 @@
+/*
+ * $Log: taia_add.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "taia.h"
 
-/* XXX: breaks tai encapsulation */
+/*
+ * XXX: breaks tai encapsulation 
+ */
 
-void taia_add(struct taia *t,struct taia *u,struct taia *v)
+void
+taia_add(struct taia *t, struct taia *u, struct taia *v)
 {
-  t->sec.x = u->sec.x + v->sec.x;
-  t->nano = u->nano + v->nano;
-  t->atto = u->atto + v->atto;
-  if (t->atto > 999999999UL) {
-    t->atto -= 1000000000UL;
-    ++t->nano;
-  }
-  if (t->nano > 999999999UL) {
-    t->nano -= 1000000000UL;
-    ++t->sec.x;
-  }
+	t->sec.x = u->sec.x + v->sec.x;
+	t->nano = u->nano + v->nano;
+	t->atto = u->atto + v->atto;
+	if (t->atto > 999999999UL)
+	{
+		t->atto -= 1000000000UL;
+		++t->nano;
+	}
+	if (t->nano > 999999999UL)
+	{
+		t->nano -= 1000000000UL;
+		++t->sec.x;
+	}
 }
diff -Naur tmp/ucspi-tcp-0.88/taia_approx.c ucspi-tcp-0.88/taia_approx.c
--- tmp/ucspi-tcp-0.88/taia_approx.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/taia_approx.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,6 +1,13 @@
+/*
+ * $Log: taia_approx.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "taia.h"
 
-double taia_approx(struct taia *t)
+double
+taia_approx(struct taia *t)
 {
-  return tai_approx(&t->sec) + taia_frac(t);
+	return tai_approx(&t->sec) + taia_frac(t);
 }
diff -Naur tmp/ucspi-tcp-0.88/taia_frac.c ucspi-tcp-0.88/taia_frac.c
--- tmp/ucspi-tcp-0.88/taia_frac.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/taia_frac.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,6 +1,13 @@
+/*
+ * $Log: taia_frac.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "taia.h"
 
-double taia_frac(struct taia *t)
+double
+taia_frac(struct taia *t)
 {
-  return (t->atto * 0.000000001 + t->nano) * 0.000000001;
+	return (t->atto * 0.000000001 + t->nano) * 0.000000001;
 }
diff -Naur tmp/ucspi-tcp-0.88/taia.h ucspi-tcp-0.88/taia.h
--- tmp/ucspi-tcp-0.88/taia.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/taia.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,33 +1,40 @@
+/*
+ * $Log: taia.h,v $
+ * Revision 1.2  2005-05-13 23:53:50+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef TAIA_H
 #define TAIA_H
 
 #include "tai.h"
 
-struct taia {
-  struct tai sec;
-  unsigned long nano; /* 0...999999999 */
-  unsigned long atto; /* 0...999999999 */
-} ;
-
-extern void taia_tai(struct taia *,struct tai *);
-
-extern void taia_now(struct taia *);
-
-extern double taia_approx(struct taia *);
-extern double taia_frac(struct taia *);
-
-extern void taia_add(struct taia *,struct taia *,struct taia *);
-extern void taia_sub(struct taia *,struct taia *,struct taia *);
-extern void taia_half(struct taia *,struct taia *);
-extern int taia_less(struct taia *,struct taia *);
+struct taia
+{
+	struct tai      sec;
+	unsigned long   nano;		/*- 0...999999999 */
+	unsigned long   atto;		/*- 0...999999999 */
+};
+
+void            taia_tai(struct taia *, struct tai *);
+void            taia_now(struct taia *);
+double          taia_approx(struct taia *);
+double          taia_frac(struct taia *);
+
+void            taia_add(struct taia *, struct taia *, struct taia *);
+void            taia_sub(struct taia *, struct taia *, struct taia *);
+void            taia_half(struct taia *, struct taia *);
+int             taia_less(struct taia *, struct taia *);
 
 #define TAIA_PACK 16
-extern void taia_pack(char *,struct taia *);
-extern void taia_unpack(char *,struct taia *);
+void            taia_pack(char *, struct taia *);
+void            taia_unpack(char *, struct taia *);
 
 #define TAIA_FMTFRAC 19
-extern unsigned int taia_fmtfrac(char *,struct taia *);
-
-extern void taia_uint(struct taia *,unsigned int);
+unsigned int    taia_fmtfrac(char *, struct taia *);
+void            taia_uint(struct taia *, unsigned int);
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/taia_less.c ucspi-tcp-0.88/taia_less.c
--- tmp/ucspi-tcp-0.88/taia_less.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/taia_less.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,12 +1,23 @@
+/*
+ * $Log: taia_less.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "taia.h"
 
-/* XXX: breaks tai encapsulation */
+/*- XXX: breaks tai encapsulation */
 
-int taia_less(struct taia *t,struct taia *u)
+int
+taia_less(struct taia *t, struct taia *u)
 {
-  if (t->sec.x < u->sec.x) return 1;
-  if (t->sec.x > u->sec.x) return 0;
-  if (t->nano < u->nano) return 1;
-  if (t->nano > u->nano) return 0;
-  return t->atto < u->atto;
+	if (t->sec.x < u->sec.x)
+		return 1;
+	if (t->sec.x > u->sec.x)
+		return 0;
+	if (t->nano < u->nano)
+		return 1;
+	if (t->nano > u->nano)
+		return 0;
+	return t->atto < u->atto;
 }
diff -Naur tmp/ucspi-tcp-0.88/taia_now.c ucspi-tcp-0.88/taia_now.c
--- tmp/ucspi-tcp-0.88/taia_now.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/taia_now.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,12 +1,19 @@
+/*
+ * $Log: taia_now.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <sys/time.h>
 #include "taia.h"
 
-void taia_now(struct taia *t)
+void
+taia_now(struct taia *t)
 {
-  struct timeval now;
-  gettimeofday(&now,(struct timezone *) 0);
-  tai_unix(&t->sec,now.tv_sec);
-  t->nano = 1000 * now.tv_usec + 500;
-  t->atto = 0;
+	struct timeval  now;
+	gettimeofday(&now, (struct timezone *) 0);
+	tai_unix(&t->sec, now.tv_sec);
+	t->nano = 1000 * now.tv_usec + 500;
+	t->atto = 0;
 }
diff -Naur tmp/ucspi-tcp-0.88/taia_pack.c ucspi-tcp-0.88/taia_pack.c
--- tmp/ucspi-tcp-0.88/taia_pack.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/taia_pack.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,20 +1,33 @@
+/*
+ * $Log: taia_pack.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "taia.h"
 
-void taia_pack(char *s,struct taia *t)
+void
+taia_pack(char *s, struct taia *t)
 {
-  unsigned long x;
+	unsigned long   x;
 
-  tai_pack(s,&t->sec);
-  s += 8;
+	tai_pack(s, &t->sec);
+	s += 8;
 
-  x = t->atto;
-  s[7] = x & 255; x >>= 8;
-  s[6] = x & 255; x >>= 8;
-  s[5] = x & 255; x >>= 8;
-  s[4] = x;
-  x = t->nano;
-  s[3] = x & 255; x >>= 8;
-  s[2] = x & 255; x >>= 8;
-  s[1] = x & 255; x >>= 8;
-  s[0] = x;
+	x = t->atto;
+	s[7] = x & 255;
+	x >>= 8;
+	s[6] = x & 255;
+	x >>= 8;
+	s[5] = x & 255;
+	x >>= 8;
+	s[4] = x;
+	x = t->nano;
+	s[3] = x & 255;
+	x >>= 8;
+	s[2] = x & 255;
+	x >>= 8;
+	s[1] = x & 255;
+	x >>= 8;
+	s[0] = x;
 }
diff -Naur tmp/ucspi-tcp-0.88/taia_sub.c ucspi-tcp-0.88/taia_sub.c
--- tmp/ucspi-tcp-0.88/taia_sub.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/taia_sub.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,21 +1,32 @@
+/*
+ * $Log: taia_sub.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "taia.h"
 
-/* XXX: breaks tai encapsulation */
+/*
+ * XXX: breaks tai encapsulation 
+ */
 
-void taia_sub(struct taia *t,struct taia *u,struct taia *v)
+void
+taia_sub(struct taia *t, struct taia *u, struct taia *v)
 {
-  unsigned long unano = u->nano;
-  unsigned long uatto = u->atto;
-  
-  t->sec.x = u->sec.x - v->sec.x;
-  t->nano = unano - v->nano;
-  t->atto = uatto - v->atto;
-  if (t->atto > uatto) {
-    t->atto += 1000000000UL;
-    --t->nano;
-  }
-  if (t->nano > unano) {
-    t->nano += 1000000000UL;
-    --t->sec.x;
-  }
+	unsigned long   unano = u->nano;
+	unsigned long   uatto = u->atto;
+
+	t->sec.x = u->sec.x - v->sec.x;
+	t->nano = unano - v->nano;
+	t->atto = uatto - v->atto;
+	if (t->atto > uatto)
+	{
+		t->atto += 1000000000UL;
+		--t->nano;
+	}
+	if (t->nano > unano)
+	{
+		t->nano += 1000000000UL;
+		--t->sec.x;
+	}
 }
diff -Naur tmp/ucspi-tcp-0.88/taia_uint.c ucspi-tcp-0.88/taia_uint.c
--- tmp/ucspi-tcp-0.88/taia_uint.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/taia_uint.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,10 +1,17 @@
+/*
+ * $Log: taia_uint.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "taia.h"
 
-/* XXX: breaks tai encapsulation */
+/*- XXX: breaks tai encapsulation */
 
-void taia_uint(struct taia *t,unsigned int s)
+void
+taia_uint(struct taia *t, unsigned int s)
 {
-  t->sec.x = s;
-  t->nano = 0;
-  t->atto = 0;
+	t->sec.x = s;
+	t->nano = 0;
+	t->atto = 0;
 }
diff -Naur tmp/ucspi-tcp-0.88/tai.h ucspi-tcp-0.88/tai.h
--- tmp/ucspi-tcp-0.88/tai.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/tai.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,26 +1,36 @@
+/*
+ * $Log: tai.h,v $
+ * Revision 1.2  2005-05-13 23:53:54+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef TAI_H
 #define TAI_H
 
 #include "uint64.h"
 
-struct tai {
-  uint64 x;
-} ;
+struct tai
+{
+	uint64          x;
+};
 
 #define tai_unix(t,u) ((void) ((t)->x = 4611686018427387914ULL + (uint64) (u)))
 
-extern void tai_now(struct tai *);
+void            tai_now(struct tai *);
 
 #define tai_approx(t) ((double) ((t)->x))
 
-extern void tai_add(struct tai *,struct tai *,struct tai *);
-extern void tai_sub(struct tai *,struct tai *,struct tai *);
+void            tai_add(struct tai *, struct tai *, struct tai *);
+void            tai_sub(struct tai *, struct tai *, struct tai *);
 #define tai_less(t,u) ((t)->x < (u)->x)
 
 #define TAI_PACK 8
-extern void tai_pack(char *,struct tai *);
-extern void tai_unpack(char *,struct tai *);
+void            tai_pack(char *, struct tai *);
+void            tai_unpack(char *, struct tai *);
 
-extern void tai_uint(struct tai *,unsigned int);
+void            tai_uint(struct tai *, unsigned int);
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/tai_pack.c ucspi-tcp-0.88/tai_pack.c
--- tmp/ucspi-tcp-0.88/tai_pack.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/tai_pack.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,16 +1,30 @@
+/*
+ * $Log: tai_pack.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "tai.h"
 
-void tai_pack(char *s,struct tai *t)
+void
+tai_pack(char *s, struct tai *t)
 {
-  uint64 x;
+	uint64          x;
 
-  x = t->x;
-  s[7] = x & 255; x >>= 8;
-  s[6] = x & 255; x >>= 8;
-  s[5] = x & 255; x >>= 8;
-  s[4] = x & 255; x >>= 8;
-  s[3] = x & 255; x >>= 8;
-  s[2] = x & 255; x >>= 8;
-  s[1] = x & 255; x >>= 8;
-  s[0] = x;
+	x = t->x;
+	s[7] = x & 255;
+	x >>= 8;
+	s[6] = x & 255;
+	x >>= 8;
+	s[5] = x & 255;
+	x >>= 8;
+	s[4] = x & 255;
+	x >>= 8;
+	s[3] = x & 255;
+	x >>= 8;
+	s[2] = x & 255;
+	x >>= 8;
+	s[1] = x & 255;
+	x >>= 8;
+	s[0] = x;
 }
diff -Naur tmp/ucspi-tcp-0.88/TARGETS ucspi-tcp-0.88/TARGETS
--- tmp/ucspi-tcp-0.88/TARGETS	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/TARGETS	2009-02-10 16:48:23.000000000 +0530
@@ -146,26 +146,58 @@
 fork.h
 mconnect-io.o
 mconnect-io
-addcr.o
-addcr
-delcr.o
-delcr
-fixcrio.o
-fixcrio
 rblsmtpd.o
 commands.o
 rblsmtpd
 rts
 prog
-install.o
+setup.o
 hier.o
 auto-str.o
 auto-str
 auto_home.c
 auto_home.o
-install
+setup
 instcheck.o
 instcheck
 it
 setup
 check
+junk
+control.o
+str_diffn.o
+dns_ip6.o
+dns_ipq6.o
+dns_nd6.o
+dns_sortip6.o
+fmt_xlong.o
+ip6_fmt.o
+ip6_scan.o
+scan_0x.o
+socket_accept6.o
+socket_bind6.o
+socket_conn6.o
+socket_local6.o
+socket_recv6.o
+socket_remote6.o
+socket_send6.o
+socket_tcp6.o
+timeoutconn6.o
+haveip6.h
+remoteinfo6.o
+socket_getifidx.o
+socket_getifname.o
+scan_ip6.o
+scan_xlong.o
+socket_ip4loopback.o
+socket_udp6.o
+socket_v4mappedprefix.o
+socket_v6any.o
+socket_v6loopback.o
+tcpremoteinfo.o
+cert.pem
+lic.lib
+haslic.h
+mysql_config.o
+hasmysql.h
+mysql_config
diff -Naur tmp/ucspi-tcp-0.88/tcpcat.1 ucspi-tcp-0.88/tcpcat.1
--- tmp/ucspi-tcp-0.88/tcpcat.1	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/tcpcat.1	2000-11-16 17:06:19.000000000 +0530
@@ -0,0 +1,34 @@
+.TH tcpcat 1
+.SH NAME
+tcpcat \- prints data from a remote host.
+.SH SYNOPSIS
+.B tcpcat
+.I host
+.I port
+.SH DESCRIPTION
+.B tcpcat
+connects to
+.I port
+on
+.IR host .
+It prints any data it receives. 
+
+.B tcpcat
+can be used to transfer binary data. It does no conversions.
+.SH SEE ALSO
+tcpserver(1),
+tcprules(1),
+tcprulescheck(1),
+argv0(1),
+fixcrio(1),
+recordio(1),
+rblsmtpd(1),
+tcpclient(1),
+who@(1),
+date@(1),
+finger@(1),
+http@(1),
+mconnect(1),
+tcp-environ(5)
+
+http://cr.yp.to/ucspi-tcp.html
diff -Naur tmp/ucspi-tcp-0.88/tcpcat.sh ucspi-tcp-0.88/tcpcat.sh
--- tmp/ucspi-tcp-0.88/tcpcat.sh	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/tcpcat.sh	2008-07-27 18:43:32.000000000 +0530
@@ -1 +1,7 @@
+#
+# $Log: tcpcat.sh,v $
+# Revision 1.1  2003-12-31 19:57:58+05:30  Cprogrammer
+# Initial revision
+#
+#
 exec HOME/bin/tcpclient -RHl0 -- "${1-0}" "${2-17}" sh -c 'exec cat <&6'
diff -Naur tmp/ucspi-tcp-0.88/tcpclient.1 ucspi-tcp-0.88/tcpclient.1
--- tmp/ucspi-tcp-0.88/tcpclient.1	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/tcpclient.1	2000-11-16 17:06:19.000000000 +0530
@@ -0,0 +1,142 @@
+.TH tcpclient 1
+.SH NAME
+tcpclient \- creates an outgoing TCP connection.
+.SH SYNOPSIS
+.B tcpclient
+.I opts
+.I host
+.I port
+.I prog
+.SH DESCRIPTION
+.I opts
+is a series of getopt-style options.
+.I host
+is one argument.
+.I port
+is one argument.
+.I prog
+consists of one or more arguments. 
+
+.B tcpclient
+attempts to connect to a TCP server. If it is successful, it runs
+.IR prog ,
+with descriptor 6 reading from the network and descriptor 7 writing to the
+network. It also sets up several environment variables (see
+.BR tcp-environ (5)
+).
+
+The server's address is given by
+.I host
+and
+.IR port .
+.I port
+may be a name from /etc/services or a number.
+.I host
+may be 0, referring to the local machine, or a dotted-decimal IP address, or
+a host name; it is fed through qualification using dns_ip4_qualify.
+
+If the server has several IP addresses,
+.B tcpclient
+tries each address in turn.
+.SH OPTIONS
+.B General options:
+.TP
+.B \-q
+Quiet. Do not print error messages. 
+.TP
+.B \-Q
+(Default.) Print error messages. 
+.TP
+.B \-v
+Verbose. Print error messages and status messages. 
+.P
+.B Connection options:
+.TP
+.B \-T \fIx\fR+\fIy
+Give up on the connection attempt after
+.I x\fR+\fIy
+seconds. Default: 2+58. When a host has several IP addresses,
+.B tcpclient
+tries to connect to the first IP address, waits
+.I x
+seconds, tries to connect to the second IP address, waits
+.I x
+seconds, etc.; then it retries each address that timed out, waiting
+.I y
+seconds per address. You may omit
+.RI + y
+to skip the second try. Before version 0.88,
+.BR tcpserver (1)
+will use only
+.I x
+(default: 60). 
+.TP
+.B \-i \fIlocalip
+Use
+.I localip
+as the IP address for the local side of the connection; quit if
+.I localip
+is not available. Normally
+.B tcpclient
+lets the operating system choose an address. 
+.TP
+.B \-p \fIlocalport
+Use
+.I localport
+as the TCP port for the local side of the connection; quit if
+.I localport
+is not available. Normally
+.B tcpclient
+lets the operating system choose a port. 
+.TP
+.B \-d
+Delay sending data for a fraction of a second whenever the remote host is
+responding slowly. This is currently the default, but it may not be in the
+future; if you want it, set it explicitly. 
+.TP
+.B \-D
+Never delay sending data; enable TCP_NODELAY. 
+.P
+.B Data-gathering options:
+.TP
+.B \-h
+(Default.) Look up the remote host name in DNS to set the environment variable
+$TCPREMOTEHOST. 
+.TP
+.B \-H
+Do not look up the remote host name in DNS; remove the environment variable
+$TCPREMOTEHOST. 
+.TP
+.B \-l \fIlocalname
+Do not look up the local host name in DNS; use
+.I localname
+for the environment variable $TCPLOCALHOST. A common choice for localname is
+0.
+.TP
+.B \-r
+(Default.) Attempt to obtain $TCPREMOTEINFO from the remote host.
+.TP
+.B \-R
+Do not attempt to obtain $TCPREMOTEINFO from the remote host. 
+.TP
+.B \-t \fIn
+Give up on the $TCPREMOTEINFO connection attempt after
+.I n
+seconds. Default: 26. 
+.SH SEE ALSO
+tcpserver(1),
+tcprules(1),
+tcprulescheck(1),
+argv0(1),
+fixcrio(1),
+recordio(1),
+rblsmtpd(1),
+who@(1),
+date@(1),
+finger@(1),
+http@(1),
+tcpcat(1),
+mconnect(1),
+tcp-environ(5)
+
+http://cr.yp.to/ucspi-tcp.html
diff -Naur tmp/ucspi-tcp-0.88/tcpclient.c ucspi-tcp-0.88/tcpclient.c
--- tmp/ucspi-tcp-0.88/tcpclient.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/tcpclient.c	2008-07-27 18:41:46.000000000 +0530
@@ -1,14 +1,49 @@
+/*
+ * $Log: tcpclient.c,v $
+ * Revision 1.8  2008-07-26 09:45:56+05:30  Cprogrammer
+ * fixed compile error
+ *
+ * Revision 1.7  2008-07-17 23:04:27+05:30  Cprogrammer
+ * define opteof on Darwin
+ *
+ * Revision 1.6  2005-06-11 02:11:54+05:30  Cprogrammer
+ * removed blank lines
+ *
+ * Revision 1.5  2005-06-10 09:13:27+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.4  2004-10-12 00:31:37+05:30  Cprogrammer
+ * renamed remoteinfo.h to tcpremoteinfo.h
+ *
+ * Revision 1.3  2004-09-23 23:12:58+05:30  Cprogrammer
+ * include getopt.h
+ *
+ * Revision 1.2  2003-12-30 00:32:49+05:30  Cprogrammer
+ * added prototype for socket_tcpnodelay()
+ *
+ * Revision 1.1  2003-10-17 21:09:07+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <sys/param.h>
 #include <netdb.h>
 #include "sig.h"
 #include "exit.h"
+#include <getopt.h>
+#ifdef DARWIN
+#define opteof -1
+#else
 #include "sgetopt.h"
+#endif
 #include "uint16.h"
 #include "fmt.h"
 #include "scan.h"
 #include "str.h"
 #include "ip4.h"
+#ifdef IPV6
+#include "ip6.h"
+#endif
 #include "uint16.h"
 #include "socket.h"
 #include "fd.h"
@@ -18,207 +53,353 @@
 #include "strerr.h"
 #include "pathexec.h"
 #include "timeoutconn.h"
-#include "remoteinfo.h"
+#include "tcpremoteinfo.h"
 #include "dns.h"
+#include <unistd.h>
 
 #define FATAL "tcpclient: fatal: "
 #define CONNECT "tcpclient: unable to connect to "
 
-void nomem(void)
+extern int      socket_tcpnodelay(int);
+
+void
+nomem(void)
 {
-  strerr_die2x(111,FATAL,"out of memory");
+	strerr_die2x(111, FATAL, "out of memory");
 }
-void usage(void)
+
+void
+usage(void)
 {
-  strerr_die1x(100,"tcpclient: usage: tcpclient \
-[ -hHrRdDqQv ] \
-[ -i localip ] \
-[ -p localport ] \
-[ -T timeoutconn ] \
-[ -l localname ] \
-[ -t timeoutinfo ] \
-host port program");
+	strerr_die1x(100, "tcpclient: usage: tcpclient"
+#ifdef IPV6
+" [ -46hHrRdDqQv ] "
+#else
+" [ -hHrRdDqQv ]\n"
+#endif
+" [ -i localip ]\n"
+" [ -p localport ]\n"
+" [ -T timeoutconn ]\n"
+" [ -l localname ]\n"
+" [ -t timeoutinfo ]\n"
+" host port program");
 }
 
-int verbosity = 1;
-int flagdelay = 1;
-int flagremoteinfo = 1;
-int flagremotehost = 1;
-unsigned long itimeout = 26;
-unsigned long ctimeout[2] = { 2, 58 };
-
-char iplocal[4] = { 0,0,0,0 };
-uint16 portlocal = 0;
-char *forcelocal = 0;
-
-char ipremote[4];
-uint16 portremote;
-
-char *hostname;
+int             verbosity = 1;
+int             flagdelay = 1;
+int             flagremoteinfo = 1;
+int             flagremotehost = 1;
+unsigned long   itimeout = 26;
+unsigned long   ctimeout[2] = { 2, 58 };
+#ifdef IPV6
+int             forcev6 = 0;
+char            iplocal[16] = {0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0};
+char            ipremote[16];
+char            ipstr[IP6_FMT];
+uint32          netif = 0;
+#else
+char            iplocal[4] = {0, 0, 0, 0};
+char            ipremote[4];
+char            ipstr[IP4_FMT];
+#endif
+uint16          portlocal = 0;
+char           *forcelocal = 0;
+uint16          portremote;
+char           *hostname;
 static stralloc addresses;
 static stralloc moreaddresses;
-
 static stralloc tmp;
 static stralloc fqdn;
-char strnum[FMT_ULONG];
-char ipstr[IP4_FMT];
-
-char seed[128];
+char            strnum[FMT_ULONG];
+char            seed[128];
 
-main(int argc,char **argv)
+int
+main(int argc, char **argv)
 {
-  unsigned long u;
-  int opt;
-  char *x;
-  int j;
-  int s;
-  int cloop;
-
-  dns_random_init(seed);
-
-  close(6);
-  close(7);
-  sig_ignore(sig_pipe);
- 
-  while ((opt = getopt(argc,argv,"dDvqQhHrRi:p:t:T:l:")) != opteof)
-    switch(opt) {
-      case 'd': flagdelay = 1; break;
-      case 'D': flagdelay = 0; break;
-      case 'v': verbosity = 2; break;
-      case 'q': verbosity = 0; break;
-      case 'Q': verbosity = 1; break;
-      case 'l': forcelocal = optarg; break;
-      case 'H': flagremotehost = 0; break;
-      case 'h': flagremotehost = 1; break;
-      case 'R': flagremoteinfo = 0; break;
-      case 'r': flagremoteinfo = 1; break;
-      case 't': scan_ulong(optarg,&itimeout); break;
-      case 'T': j = scan_ulong(optarg,&ctimeout[0]);
-		if (optarg[j] == '+') ++j;
-		scan_ulong(optarg + j,&ctimeout[1]);
-		break;
-      case 'i': if (!ip4_scan(optarg,iplocal)) usage(); break;
-      case 'p': scan_ulong(optarg,&u); portlocal = u; break;
-      default: usage();
-    }
-  argv += optind;
-
-  if (!verbosity)
-    buffer_2->fd = -1;
-
-  hostname = *argv;
-  if (!hostname) usage();
-  if (str_equal(hostname,"")) hostname = "127.0.0.1";
-  if (str_equal(hostname,"0")) hostname = "127.0.0.1";
-
-  x = *++argv;
-  if (!x) usage();
-  if (!x[scan_ulong(x,&u)])
-    portremote = u;
-  else {
-    struct servent *se;
-    se = getservbyname(x,"tcp");
-    if (!se)
-      strerr_die3x(111,FATAL,"unable to figure out port number for ",x);
-    portremote = ntohs(se->s_port);
-    /* i continue to be amazed at the stupidity of the s_port interface */
-  }
-
-  if (!*++argv) usage();
-
-  if (!stralloc_copys(&tmp,hostname)) nomem();
-  if (dns_ip4_qualify(&addresses,&fqdn,&tmp) == -1)
-    strerr_die4sys(111,FATAL,"temporarily unable to figure out IP address for ",hostname,": ");
-  if (addresses.len < 4)
-    strerr_die3x(111,FATAL,"no IP address for ",hostname);
-
-  if (addresses.len == 4) {
-    ctimeout[0] += ctimeout[1];
-    ctimeout[1] = 0;
-  }
-
-  for (cloop = 0;cloop < 2;++cloop) {
-    if (!stralloc_copys(&moreaddresses,"")) nomem();
-    for (j = 0;j + 4 <= addresses.len;j += 4) {
-      s = socket_tcp();
-      if (s == -1)
-        strerr_die2sys(111,FATAL,"unable to create socket: ");
-      if (socket_bind4(s,iplocal,portlocal) == -1)
-        strerr_die2sys(111,FATAL,"unable to bind socket: ");
-      if (timeoutconn(s,addresses.s + j,portremote,ctimeout[cloop]) == 0)
-        goto CONNECTED;
-      close(s);
-      if (!cloop && ctimeout[1] && (errno == error_timeout)) {
-	if (!stralloc_catb(&moreaddresses,addresses.s + j,4)) nomem();
-      }
-      else {
-        strnum[fmt_ulong(strnum,portremote)] = 0;
-        ipstr[ip4_fmt(ipstr,addresses.s + j)] = 0;
-        strerr_warn5(CONNECT,ipstr," port ",strnum,": ",&strerr_sys);
-      }
-    }
-    if (!stralloc_copy(&addresses,&moreaddresses)) nomem();
-  }
-
-  _exit(111);
-
-
-
-  CONNECTED:
-
-  if (!flagdelay)
-    socket_tcpnodelay(s); /* if it fails, bummer */
-
-  if (!pathexec_env("PROTO","TCP")) nomem();
-
-  if (socket_local4(s,iplocal,&portlocal) == -1)
-    strerr_die2sys(111,FATAL,"unable to get local address: ");
-
-  strnum[fmt_ulong(strnum,portlocal)] = 0;
-  if (!pathexec_env("TCPLOCALPORT",strnum)) nomem();
-  ipstr[ip4_fmt(ipstr,iplocal)] = 0;
-  if (!pathexec_env("TCPLOCALIP",ipstr)) nomem();
-
-  x = forcelocal;
-  if (!x)
-    if (dns_name4(&tmp,iplocal) == 0) {
-      if (!stralloc_0(&tmp)) nomem();
-      x = tmp.s;
-    }
-  if (!pathexec_env("TCPLOCALHOST",x)) nomem();
-
-  if (socket_remote4(s,ipremote,&portremote) == -1)
-    strerr_die2sys(111,FATAL,"unable to get remote address: ");
-
-  strnum[fmt_ulong(strnum,portremote)] = 0;
-  if (!pathexec_env("TCPREMOTEPORT",strnum)) nomem();
-  ipstr[ip4_fmt(ipstr,ipremote)] = 0;
-  if (!pathexec_env("TCPREMOTEIP",ipstr)) nomem();
-  if (verbosity >= 2)
-    strerr_warn4("tcpclient: connected to ",ipstr," port ",strnum,0);
-
-  x = 0;
-  if (flagremotehost)
-    if (dns_name4(&tmp,ipremote) == 0) {
-      if (!stralloc_0(&tmp)) nomem();
-      x = tmp.s;
-    }
-  if (!pathexec_env("TCPREMOTEHOST",x)) nomem();
-
-  x = 0;
-  if (flagremoteinfo)
-    if (remoteinfo(&tmp,ipremote,portremote,iplocal,portlocal,itimeout) == 0) {
-      if (!stralloc_0(&tmp)) nomem();
-      x = tmp.s;
-    }
-  if (!pathexec_env("TCPREMOTEINFO",x)) nomem();
-
-  if (fd_move(6,s) == -1)
-    strerr_die2sys(111,FATAL,"unable to set up descriptor 6: ");
-  if (fd_copy(7,6) == -1)
-    strerr_die2sys(111,FATAL,"unable to set up descriptor 7: ");
-  sig_uncatch(sig_pipe);
- 
-  pathexec(argv);
-  strerr_die4sys(111,FATAL,"unable to run ",*argv,": ");
+	unsigned long   u;
+	char           *x;
+#ifdef IPV6
+	int             fakev4 = 0;
+#endif
+	int             opt, j, s, cloop;
+
+	dns_random_init(seed);
+	close(6);
+	close(7);
+	sig_ignore(sig_pipe);
+#ifdef IPV6
+	while ((opt = getopt(argc, argv, "46dDvqQhHrRi:p:t:T:l:I:")) != opteof)
+#else
+	while ((opt = getopt(argc, argv, "dDvqQhHrRi:p:t:T:l:")) != opteof)
+#endif
+	{
+		switch (opt)
+		{
+#ifdef IPV6
+		case '4':
+			noipv6 = 1;
+			break;
+		case '6':
+			forcev6 = 1;
+			break;
+		case 'I':
+			netif = socket_getifidx(optarg);
+			break;
+#endif
+		case 'd':
+			flagdelay = 1;
+			break;
+		case 'D':
+			flagdelay = 0;
+			break;
+		case 'v':
+			verbosity = 2;
+			break;
+		case 'q':
+			verbosity = 0;
+			break;
+		case 'Q':
+			verbosity = 1;
+			break;
+		case 'l':
+			forcelocal = optarg;
+			break;
+		case 'H':
+			flagremotehost = 0;
+			break;
+		case 'h':
+			flagremotehost = 1;
+			break;
+		case 'R':
+			flagremoteinfo = 0;
+			break;
+		case 'r':
+			flagremoteinfo = 1;
+			break;
+		case 't':
+			scan_ulong(optarg, &itimeout);
+			break;
+		case 'T':
+			j = scan_ulong(optarg, &ctimeout[0]);
+			if (optarg[j] == '+')
+				++j;
+			scan_ulong(optarg + j, &ctimeout[1]);
+			break;
+		case 'i':
+#ifdef IPV6
+			if (!ip6_scan(optarg, iplocal))
+#else
+			if (!ip4_scan(optarg, iplocal))
+#endif
+				usage();
+			break;
+		case 'p':
+			scan_ulong(optarg, &u);
+			portlocal = u;
+			break;
+		default:
+			usage();
+		}
+	}
+	argv += optind;
+	if (!verbosity)
+		buffer_2->fd = -1;
+	if (!(hostname = *argv))
+		usage();
+	if (!hostname[0] || str_equal(hostname,"0"))
+#ifdef IPV6
+		hostname = (noipv6 ? "127.0.0.1" : "::1");
+#else
+		hostname = "127.0.0.1";
+#endif
+	if (!(x = *++argv))
+		usage();
+	if (!x[scan_ulong(x, &u)])
+		portremote = u;
+	else
+	{
+		struct servent *se;
+
+		if (!(se = getservbyname(x, "tcp")))
+			strerr_die3x(111, FATAL, "unable to figure out port number for ", x);
+		portremote = ntohs(se->s_port);
+		/*- i continue to be amazed at the stupidity of the s_port interface */
+	}
+	if (!*++argv)
+		usage();
+	if (!stralloc_copys(&tmp, hostname))
+		nomem();
+#ifdef IPV6
+	if (dns_ip6_qualify(&addresses, &fqdn, &tmp) == -1)
+		strerr_die4sys(111, FATAL, "temporarily unable to figure out IP address for ", hostname, ": ");
+	if (addresses.len < 16)
+		strerr_die3x(111, FATAL, "no IP address for ", hostname);
+	if (addresses.len == 16)
+#else
+	if (dns_ip4_qualify(&addresses, &fqdn, &tmp) == -1)
+		strerr_die4sys(111, FATAL, "temporarily unable to figure out IP address for ", hostname, ": ");
+	if (addresses.len < 4)
+		strerr_die3x(111, FATAL, "no IP address for ", hostname);
+	if (addresses.len == 4)
+#endif
+	{
+		ctimeout[0] += ctimeout[1];
+		ctimeout[1] = 0;
+	}
+	for (cloop = 0; cloop < 2; ++cloop)
+	{
+		if (!stralloc_copys(&moreaddresses, ""))
+			nomem();
+#ifdef IPV6
+		for (j = 0; j + 16 <= addresses.len; j += 4)
+#else
+		for (j = 0; j + 4 <= addresses.len; j += 4)
+#endif
+		{
+#ifdef IPV6
+			if ((s = socket_tcp6()) == -1)
+#else
+			if ((s = socket_tcp()) == -1)
+#endif
+				strerr_die2sys(111, FATAL, "unable to create socket: ");
+#ifdef IPV6
+			if (socket_bind6(s, iplocal, portlocal, netif) == -1)
+#else
+			if (socket_bind4(s, iplocal, portlocal) == -1)
+#endif
+				strerr_die2sys(111, FATAL, "unable to bind socket: ");
+#ifdef IPV6
+			if (timeoutconn6(s, addresses.s + j, portremote, ctimeout[cloop], netif) == 0)
+#else
+			if (timeoutconn(s, addresses.s + j, portremote, ctimeout[cloop]) == 0)
+#endif
+				goto CONNECTED;
+			close(s);
+			if (!cloop && ctimeout[1] && (errno == error_timeout))
+			{
+#ifdef IPV6
+				if (!stralloc_catb(&moreaddresses, addresses.s + j, 16))
+#else
+				if (!stralloc_catb(&moreaddresses, addresses.s + j, 4))
+#endif
+					nomem();
+			} else
+			{
+				strnum[fmt_ulong(strnum, portremote)] = 0;
+#ifdef IPV6
+				if (ip6_isv4mapped(addresses.s + j))
+					ipstr[ip4_fmt(ipstr, addresses.s + j + 12)] = 0;
+				else
+					ipstr[ip6_fmt(ipstr, addresses.s + j)] = 0;
+#else
+				ipstr[ip4_fmt(ipstr, addresses.s + j)] = 0;
+#endif
+				strerr_warn5(CONNECT, ipstr, " port ", strnum, ": ", &strerr_sys);
+			}
+		}
+		if (!stralloc_copy(&addresses, &moreaddresses))
+			nomem();
+	}
+	_exit(111);
+
+CONNECTED:
+	if (!flagdelay)
+		socket_tcpnodelay(s);	/*- if it fails, bummer */
+#ifndef IPV6
+	if (!pathexec_env("PROTO", "TCP"))
+		nomem();
+	if (socket_local4(s, iplocal, &portlocal) == -1)
+#else
+	if (socket_local6(s, iplocal, &portlocal, &netif) == -1)
+#endif
+		strerr_die2sys(111, FATAL, "unable to get local address: ");
+#ifdef IPV6
+	if (!forcev6 && (ip6_isv4mapped(iplocal) || byte_equal(iplocal, 16, V6any)))
+		fakev4 = 1;
+	if (!pathexec_env("PROTO", fakev4 ? "TCP" : "TCP6"))
+		nomem();
+#endif
+	strnum[fmt_ulong(strnum, portlocal)] = 0;
+	if (!pathexec_env("TCPLOCALPORT", strnum))
+		nomem();
+#ifdef IPV6
+	if (fakev4)
+		ipstr[ip4_fmt(ipstr, iplocal + 12)] = 0;
+	else
+		ipstr[ip6_fmt(ipstr, iplocal)] = 0;
+#else
+	ipstr[ip4_fmt(ipstr, iplocal)] = 0;
+#endif
+	if (!pathexec_env("TCPLOCALIP", ipstr))
+		nomem();
+#ifdef IPV6
+	if (!(x = forcelocal) && dns_name6(&tmp, iplocal) == 0)
+#else
+	if (!(x = forcelocal) && dns_name4(&tmp, iplocal) == 0)
+#endif
+	{
+		if (!stralloc_0(&tmp))
+			nomem();
+		x = tmp.s;
+	}
+	if (!pathexec_env("TCPLOCALHOST", x))
+		nomem();
+#ifdef IPV6
+	if (socket_remote6(s, ipremote, &portremote, &netif) == -1)
+#else
+	if (socket_remote4(s, ipremote, &portremote) == -1)
+#endif
+		strerr_die2sys(111, FATAL, "unable to get remote address: ");
+	strnum[fmt_ulong(strnum, portremote)] = 0;
+	if (!pathexec_env("TCPREMOTEPORT", strnum))
+		nomem();
+#ifdef IPV6
+	if (fakev4)
+		ipstr[ip4_fmt(ipstr, ipremote + 12)] = 0;
+	else
+		ipstr[ip6_fmt(ipstr, ipremote)] = 0;
+#else
+	ipstr[ip4_fmt(ipstr, ipremote)] = 0;
+#endif
+	if (!pathexec_env("TCPREMOTEIP", ipstr))
+		nomem();
+	if (verbosity >= 2)
+		strerr_warn4("tcpclient: connected to ", ipstr, " port ", strnum, 0);
+	x = 0;
+#ifdef IPV6
+	if (flagremotehost && dns_name6(&tmp, ipremote) == 0)
+#else
+	if (flagremotehost && dns_name4(&tmp, ipremote) == 0)
+#endif
+	{
+		if (!stralloc_0(&tmp))
+			nomem();
+		x = tmp.s;
+	}
+	if (!pathexec_env("TCPREMOTEHOST", x))
+		nomem();
+	x = 0;
+#ifdef IPV6
+	if (flagremoteinfo && remoteinfo6(&tmp, ipremote, portremote, iplocal,
+		portlocal, itimeout, netif) == 0)
+#else
+	if (flagremoteinfo && remoteinfo(&tmp, ipremote, portremote, iplocal,
+		portlocal, itimeout) == 0)
+#endif
+	{
+		if (!stralloc_0(&tmp))
+			nomem();
+		x = tmp.s;
+	}
+	if (!pathexec_env("TCPREMOTEINFO", x))
+		nomem();
+	if (fd_move(6, s) == -1)
+		strerr_die2sys(111, FATAL, "unable to set up descriptor 6: ");
+	if (fd_copy(7, 6) == -1)
+		strerr_die2sys(111, FATAL, "unable to set up descriptor 7: ");
+	sig_uncatch(sig_pipe);
+	pathexec(argv);
+	strerr_die4sys(111, FATAL, "unable to run ", *argv, ": ");
+	/* Not reached */
+	return(0);
 }
diff -Naur tmp/ucspi-tcp-0.88/tcpremoteinfo.c ucspi-tcp-0.88/tcpremoteinfo.c
--- tmp/ucspi-tcp-0.88/tcpremoteinfo.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/tcpremoteinfo.c	2008-07-27 18:41:46.000000000 +0530
@@ -0,0 +1,157 @@
+/*
+ * $Log: tcpremoteinfo.c,v $
+ * Revision 1.3  2008-07-25 16:50:15+05:30  Cprogrammer
+ * fix for darwin
+ *
+ * Revision 1.2  2005-06-10 12:19:39+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:46:55+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#include <unistd.h>
+#include "fmt.h"
+#include "buffer.h"
+#include "socket.h"
+#include "error.h"
+#include "iopause.h"
+#include "timeoutconn.h"
+#include "tcpremoteinfo.h"
+
+static struct taia now;
+static struct taia deadline;
+
+static ssize_t
+mywrite(int fd, char *buf, int len)
+{
+	iopause_fd      x;
+
+	x.fd = fd;
+	x.events = IOPAUSE_WRITE;
+	for (;;)
+	{
+		taia_now(&now);
+		iopause(&x, 1, &deadline, &now);
+		if (x.revents)
+			break;
+		if (taia_less(&deadline, &now))
+		{
+			errno = error_timeout;
+			return -1;
+		}
+	}
+	return write(fd, buf, len);
+}
+
+static ssize_t
+myread(int fd, char *buf, int len)
+{
+	iopause_fd      x;
+
+	x.fd = fd;
+	x.events = IOPAUSE_READ;
+	for (;;)
+	{
+		taia_now(&now);
+		iopause(&x, 1, &deadline, &now);
+		if (x.revents)
+			break;
+		if (taia_less(&deadline, &now))
+		{
+			errno = error_timeout;
+			return -1;
+		}
+	}
+	return read(fd, buf, len);
+}
+
+#ifdef IPV6
+static int
+doit(stralloc * out, int s, char ipremote[16], uint16 portremote, char iplocal[16],
+	uint16 portlocal, unsigned int timeout, uint32 netif)
+#else
+static int
+doit(stralloc *out, int s, char ipremote[4], uint16 portremote, char iplocal[4],
+	uint16 portlocal, unsigned int timeout)
+#endif
+{
+	buffer          b;
+	char            bspace[128];
+	char            strnum[FMT_ULONG];
+	int             numcolons;
+	char            ch;
+
+#ifdef IPV6
+	if (socket_bind6(s, iplocal, 0, netif) == -1)
+#else
+	if (socket_bind4(s, iplocal, 0) == -1)
+#endif
+		return -1;
+#ifdef IPV6
+	if (timeoutconn6(s, ipremote, 113, timeout, netif) == -1)
+#else
+	if (timeoutconn(s, ipremote, 113, timeout) == -1)
+#endif
+		return -1;
+	buffer_init(&b, mywrite, s, bspace, sizeof bspace);
+	buffer_put(&b, strnum, fmt_ulong(strnum, portremote));
+	buffer_put(&b, " , ", 3);
+	buffer_put(&b, strnum, fmt_ulong(strnum, portlocal));
+	buffer_put(&b, "\r\n", 2);
+	if (buffer_flush(&b) == -1)
+		return -1;
+	buffer_init(&b, myread, s, bspace, sizeof bspace);
+	numcolons = 0;
+	for (;;)
+	{
+		if (buffer_get(&b, &ch, 1) != 1)
+			return -1;
+		if ((ch == ' ') || (ch == '\t') || (ch == '\r'))
+			continue;
+		if (ch == '\n')
+			return 0;
+		if (numcolons < 3)
+		{
+			if (ch == ':')
+				++numcolons;
+		} else
+		{
+			if (!stralloc_append(out, &ch))
+				return -1;
+			if (out->len > 256)
+				return 0;
+		}
+	}
+}
+
+#ifdef IPV6
+int
+remoteinfo6(stralloc *out, char ipremote[16], uint16 portremote, char iplocal[16],
+	uint16 portlocal, unsigned int timeout, uint32 netif)
+#else
+int
+remoteinfo(stralloc *out, char ipremote[4], uint16 portremote, char iplocal[4],
+	uint16 portlocal, unsigned int timeout)
+#endif
+{
+	int             s;
+	int             r;
+
+	if (!stralloc_copys(out, ""))
+		return -1;
+	taia_now(&now);
+	taia_uint(&deadline, timeout);
+	taia_add(&deadline, &now, &deadline);
+#ifdef IPV6
+	if ((s = socket_tcp6()) == -1)
+		return -1;
+	r = doit(out, s, ipremote, portremote, iplocal, portlocal, timeout, netif);
+#else
+	if ((s = socket_tcp()) == -1)
+		return -1;
+	r = doit(out, s, ipremote, portremote, iplocal, portlocal, timeout);
+#endif
+	close(s);
+	return r;
+}
diff -Naur tmp/ucspi-tcp-0.88/tcpremoteinfo.h ucspi-tcp-0.88/tcpremoteinfo.h
--- tmp/ucspi-tcp-0.88/tcpremoteinfo.h	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/tcpremoteinfo.h	2008-07-27 18:41:52.000000000 +0530
@@ -0,0 +1,25 @@
+/*
+ * $Log: tcpremoteinfo.h,v $
+ * Revision 1.2  2005-06-10 09:13:36+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+#ifndef REMOTEINFO_H
+#define REMOTEINFO_H
+
+#include "stralloc.h"
+#include "uint16.h"
+#include "haveip6.h"
+#ifdef LIBC_HAS_IP6
+#include "uint32.h"
+#endif
+
+int             remoteinfo(stralloc *, char *, uint16, char *, uint16, unsigned int);
+#ifdef LIBC_HAS_IP6
+int             remoteinfo6(stralloc *, char *, uint16, char *, uint16, unsigned int, uint32);
+#endif
+
+#endif
diff -Naur tmp/ucspi-tcp-0.88/tcprules.1 ucspi-tcp-0.88/tcprules.1
--- tmp/ucspi-tcp-0.88/tcprules.1	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/tcprules.1	2009-08-12 13:44:02.063312183 +0530
@@ -0,0 +1,167 @@
+.TH tcprules 1
+.SH NAME
+tcprules \- compiles rules for
+.BR tcpserver (1).
+.SH SYNOPSIS
+.B tcprules
+.I cdb
+.I tmp
+.SH DESCRIPTION
+.BR tcpserver (1)
+optionally follows rules to decide whether a TCP connection is acceptable. For
+example, the rule 
+.IP
+18.23.0.32:deny
+.P
+prohibits connections from IP address 18.23.0.32. 
+
+.B tcprules
+reads rules from its standard input and writes them into
+.I cdb
+in a binary format suited for quick access by
+.BR tcpserver (1).
+
+.B tcprules
+can be used while
+.BR tcpserver (1)
+is running. It ensures that
+.I cdb
+is updated atomically. It does this by first writing the rules to
+.I tmp
+and then moving
+.I tmp
+on top of
+.IR cdb .
+If
+.I tmp
+already exists, it is destroyed. The directories containing
+.I cdb
+and
+.I tmp
+must be writable to
+.BR tcprules ;
+they must also be on the same filesystem. 
+
+If there is a problem with the input or with
+.IR tmp ,
+.B tcprules
+complains and leaves
+.I cdb
+alone. 
+
+The binary
+.I cdb
+format is portable across machines.
+.SH RULE FORMAT
+A rule is one line. A file containing rules may also contain comments: lines
+beginning with # are ignored. 
+
+Each rule contains an address, a colon, and a list of instructions, with no
+extra spaces. When
+.BR tcpserver (1)
+receives a connection from that address, it follows the instructions.
+.SH ADDRESSES
+.BR tcpserver (1)
+looks for rules with various addresses: 
+.IP 1.
+$TCPREMOTEINFO@$TCPREMOTEIP, if $TCPREMOTEINFO is set; 
+.IP 2.
+$TCPREMOTEINFO@=$TCPREMOTEHOST, if $TCPREMOTEINFO is set and $TCPREMOTEHOST is
+set;
+.IP 3.
+$TCPREMOTEIP; 
+.IP 4.
+=$TCPREMOTEHOST, if $TCPREMOTEHOST is set; 
+.IP 5.
+shorter and shorter prefixes of $TCPREMOTEIP ending with a dot; 
+.IP 6.
+shorter and shorter suffixes of $TCPREMOTEHOST starting with a dot, preceded
+by =, if $TCPREMOTEHOST is set; 
+.IP 7.
+=, if $TCPREMOTEHOST is set; and finally 
+.IP 8.
+the empty string. 
+.P
+.BR tcpserver (1)
+uses the first rule it finds. You should use the
+.B -p
+option to
+.BR tcpserver (1)
+if you rely on $TCPREMOTEHOST here. 
+
+For example, here are some rules: 
+
+     joe@127.0.0.1:first
+     18.23.0.32:second
+     :third
+     127.:fourth
+
+If $TCPREMOTEIP is 10.119.75.38,
+.BR tcpserver (1)
+will follow the third instructions. 
+
+If $TCPREMOTEIP is 18.23.0.32,
+.BR tcpserver (1)
+will follow the second instructions. 
+
+If $TCPREMOTEIP is 127.0.0.1 and $TCPREMOTEINFO is bill,
+.BR tcpserver (1)
+will follow the fourth instructions. 
+
+If $TCPREMOTEIP is 127.0.0.1 and $TCPREMOTEINFO is joe,
+.BR tcpserver (1)
+will follow the first instructions. 
+
+You can use
+.BR tcprulescheck (1)
+to see how tcpserver will interpret rules in
+.IR cdb .
+.SH ADDRESS RANGES
+.B tcprules
+treats 1.2.3.37-53:ins as an abbreviation for the rules 1.2.3.37:ins,
+1.2.3.38:ins, and so on up through 1.2.3.53:ins. Similarly, 10.2-3.:ins is an
+abbreviation for 10.2.:ins and 10.3.:ins.
+.SH INSTRUCTIONS
+The instructions in a rule must begin with either allow or deny. deny tells
+.BR tcpserver (1)
+to drop the connection without running anything. For example, the rule
+.IP
+:deny
+.P
+tells
+.BR tcpserver (1)
+to drop all connections that aren't handled by more specific rules. 
+
+The instructions may continue with some environment variables, in the form
+var="x".
+.BR tcpserver (1)
+adds an environment variable $var with value x. For example,
+.IP
+10.0.:allow,RELAYCLIENT="@fix.me"
+.P
+adds an environment variable $RELAYCLIENT with value @fix.me. The quotes may
+be replaced by any repeated character:
+.IP
+10.0.:allow,RELAYCLIENT=/@fix.me/
+.P
+Any number of variables may be listed:
+.IP
+ 127.0.0.1:allow,RELAYCLIENT="",TCPLOCALHOST="movie.edu"
+ ::1:allow,RELAYCLIENT="",TCPLOCALHOST="movie.edu"
+.SH SEE ALSO
+tcpserver(1),
+tcprulescheck(1),
+argv0(1),
+fixcrio(1),
+recordio(1),
+rblsmtpd(1),
+tcpclient(1),
+who@(1),
+date@(1),
+finger@(1),
+http@(1),
+tcpcat(1),
+mconnect(1),
+tcp-environ(5)
+
+http://cr.yp.to/ucspi-tcp.html
diff -Naur tmp/ucspi-tcp-0.88/tcprules.c ucspi-tcp-0.88/tcprules.c
--- tmp/ucspi-tcp-0.88/tcprules.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/tcprules.c	2009-08-13 14:42:09.745096475 +0530
@@ -1,3 +1,18 @@
+/*
+ * $Log: tcprules.c,v $
+ * Revision 1.4  2009-05-29 15:03:12+05:30  Cprogrammer
+ * added code to unset env variables
+ *
+ * Revision 1.3  2008-07-25 16:50:19+05:30  Cprogrammer
+ * fix for darwin
+ *
+ * Revision 1.2  2005-06-10 09:13:51+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "strerr.h"
 #include "stralloc.h"
 #include "getln.h"
@@ -6,170 +21,239 @@
 #include "fmt.h"
 #include "byte.h"
 #include "cdb_make.h"
+#include "open.h"
+#include "scan.h"
+#include <unistd.h>
 
 #define FATAL "tcprules: fatal: "
 
-unsigned long linenum = 0;
-char *fntemp;
-char *fn;
-
-stralloc line = {0};
-int match = 1;
-
-stralloc address = {0};
-stralloc data = {0};
-stralloc key = {0};
-
+unsigned long   linenum = 0;
+char           *fntemp;
+char           *fn;
+stralloc        line = { 0 };
+stralloc        address = { 0 };
+stralloc        data = { 0 };
+stralloc        key = { 0 };
 struct cdb_make c;
 
-void nomem(void)
+#if defined(linux) || defined(DARWIN)
+extern int      rename(const char *, const char *);
+#endif
+
+void
+nomem(void)
+{
+	strerr_die2x(111, FATAL, "out of memory");
+}
+
+void
+usage(void)
 {
-  strerr_die2x(111,FATAL,"out of memory");
+	strerr_die1x(100, "tcprules: usage: tcprules rules.cdb rules.tmp");
 }
-void usage(void)
+
+void
+die_bad(void)
+{
+	if (!stralloc_0(&line))
+		nomem();
+	strerr_die3x(100, FATAL, "unable to parse this line: ", line.s);
+}
+
+void
+die_write(void)
 {
-  strerr_die1x(100,"tcprules: usage: tcprules rules.cdb rules.tmp");
+	strerr_die4sys(111, FATAL, "unable to write to ", fntemp, ": ");
 }
-void die_bad(void)
-{
-  if (!stralloc_0(&line)) nomem();
-  strerr_die3x(100,FATAL,"unable to parse this line: ",line.s);
-}
-void die_write(void)
-{
-  strerr_die4sys(111,FATAL,"unable to write to ",fntemp,": ");
-}
-
-char strnum[FMT_ULONG];
-stralloc sanum = {0};
-
-void getnum(char *buf,int len,unsigned long *u)
-{
-  if (!stralloc_copyb(&sanum,buf,len)) nomem();
-  if (!stralloc_0(&sanum)) nomem();
-  if (sanum.s[scan_ulong(sanum.s,u)]) die_bad();
-}
-
-void doaddressdata(void)
-{
-  int i;
-  int left;
-  int right;
-  unsigned long bot;
-  unsigned long top;
-
-  if (byte_chr(address.s,address.len,'=') == address.len)
-    if (byte_chr(address.s,address.len,'@') == address.len) {
-      i = byte_chr(address.s,address.len,'-');
-      if (i < address.len) {
-        left = byte_rchr(address.s,i,'.');
-        if (left == i) left = 0; else ++left;
-  
-        ++i;
-        right = i + byte_chr(address.s + i,address.len - i,'.');
-  
-        getnum(address.s + left,i - 1 - left,&bot);
-        getnum(address.s + i,right - i,&top);
-        if (top > 255) top = 255;
-  
-        while (bot <= top) {
-	  if (!stralloc_copyb(&key,address.s,left)) nomem();
-	  if (!stralloc_catb(&key,strnum,fmt_ulong(strnum,bot))) nomem();
-	  if (!stralloc_catb(&key,address.s + right,address.len - right)) nomem();
-          if (cdb_make_add(&c,key.s,key.len,data.s,data.len) == -1) die_write();
-	  ++bot;
-        }
-  
-        return;
-      }
-    }
-
-  if (cdb_make_add(&c,address.s,address.len,data.s,data.len) == -1) die_write();
-}
-
-main(int argc,char **argv)
-{
-  int colon;
-  char *x;
-  int len;
-  int fd;
-  int i;
-  char ch;
-
-  fn = argv[1];
-  if (!fn) usage();
-  fntemp = argv[2];
-  if (!fntemp) usage();
-
-  fd = open_trunc(fntemp);
-  if (fd == -1)
-    strerr_die4sys(111,FATAL,"unable to create ",fntemp,": ");
-  if (cdb_make_start(&c,fd) == -1) die_write();
-
-  while (match) {
-    if (getln(buffer_0,&line,&match,'\n') == -1)
-      strerr_die2sys(111,FATAL,"unable to read input: ");
-
-    x = line.s; len = line.len;
-
-    if (!len) break;
-    if (x[0] == '#') continue;
-    if (x[0] == '\n') continue;
-
-    while (len) {
-      ch = x[len - 1];
-      if (ch != '\n') if (ch != ' ') if (ch != '\t') break;
-      --len;
-    }
-    line.len = len; /* for die_bad() */
-
-    colon = byte_chr(x,len,':');
-    if (colon == len) continue;
-
-    if (!stralloc_copyb(&address,x,colon)) nomem();
-    if (!stralloc_copys(&data,"")) nomem();
-
-    x += colon + 1; len -= colon + 1;
-
-    if ((len >= 4) && byte_equal(x,4,"deny")) {
-      if (!stralloc_catb(&data,"D",2)) nomem();
-      x += 4; len -= 4;
-    }
-    else if ((len >= 5) && byte_equal(x,5,"allow")) {
-      x += 5; len -= 5;
-    }
-    else
-      die_bad();
-
-    while (len)
-      switch(*x) {
-        case ',':
-          i = byte_chr(x,len,'=');
-          if (i == len) die_bad();
-          if (!stralloc_catb(&data,"+",1)) nomem();
-          if (!stralloc_catb(&data,x + 1,i)) nomem();
-          x += i + 1; len -= i + 1;
-          if (!len) die_bad();
-          ch = *x;
-          x += 1; len -= 1;
-          i = byte_chr(x,len,ch);
-          if (i == len) die_bad();
-          if (!stralloc_catb(&data,x,i)) nomem();
-          if (!stralloc_0(&data)) nomem();
-          x += i + 1; len -= i + 1;
-          break;
-        default:
-          die_bad();
-      }
-
-    doaddressdata();
-  }
-
-  if (cdb_make_finish(&c) == -1) die_write();
-  if (fsync(fd) == -1) die_write();
-  if (close(fd) == -1) die_write(); /* NFS stupidity */
-  if (rename(fntemp,fn))
-    strerr_die6sys(111,FATAL,"unable to move ",fntemp," to ",fn,": ");
 
-  _exit(0);
+char            strnum[FMT_ULONG];
+stralloc        sanum = { 0 };
+
+void
+getnum(char *buf, int len, unsigned long *u)
+{
+	if (!stralloc_copyb(&sanum, buf, len))
+		nomem();
+	if (!stralloc_0(&sanum))
+		nomem();
+	if (sanum.s[scan_ulong(sanum.s, u)])
+		die_bad();
+}
+
+void
+doaddressdata(void)
+{
+	int             i;
+	int             left;
+	int             right;
+	unsigned long   bot;
+	unsigned long   top;
+
+	if (byte_chr(address.s, address.len, '=') == address.len)
+	{
+		if (byte_chr(address.s, address.len, '@') == address.len)
+		{
+			i = byte_chr(address.s, address.len, '-');
+			if (i < address.len)
+			{
+				left = byte_rchr(address.s, i, '.');
+				if (left == i)
+					left = 0;
+				else
+					++left;
+				++i;
+				right = i + byte_chr(address.s + i, address.len - i, '.');
+				getnum(address.s + left, i - 1 - left, &bot);
+				getnum(address.s + i, right - i, &top);
+				if (top > 255)
+					top = 255;
+				while (bot <= top)
+				{
+					if (!stralloc_copyb(&key, address.s, left))
+						nomem();
+					if (!stralloc_catb(&key, strnum, fmt_ulong(strnum, bot)))
+						nomem();
+					if (!stralloc_catb(&key, address.s + right, address.len - right))
+						nomem();
+					if (cdb_make_add(&c, key.s, key.len, data.s, data.len) == -1)
+						die_write();
+					++bot;
+				}
+				return;
+			}
+		}
+	}
+	if (cdb_make_add(&c, address.s, address.len, data.s, data.len) == -1)
+		die_write();
+}
+
+int
+main(int argc, char **argv)
+{
+	char           *x;
+	char            ch;
+	int             len, fd, i, e, colon, match = 1;
+
+	if (!(fn = argv[1]))
+		usage();
+	if (!(fntemp = argv[2]))
+		usage();
+	if ((fd = open_trunc(fntemp)) == -1)
+		strerr_die4sys(111, FATAL, "unable to create ", fntemp, ": ");
+	if (cdb_make_start(&c, fd) == -1)
+		die_write();
+	while (match)
+	{
+		if (getln(buffer_0, &line, &match, '\n') == -1)
+			strerr_die2sys(111, FATAL, "unable to read input: ");
+		x = line.s;
+		len = line.len;
+		if (!len)
+			break;
+		if (x[0] == '#')
+			continue;
+		if (x[0] == '\n')
+			continue;
+
+		while (len)
+		{
+			ch = x[len - 1];
+			if (ch != '\n' && ch != ' ' && ch != '\t')
+				break;
+			--len;
+		}
+		line.len = len;			/*- for die_bad() */
+#ifdef IPV6
+		for (colon = 0;;)
+		{
+			int             tmp;
+
+			tmp = byte_chr(x + colon, len - colon, ':');
+			colon += tmp;
+			if (colon == len)
+				continue;
+			if (byte_equal(x + colon + 1, 4, "deny") || byte_equal(x + colon + 1, 5, "allow"))
+				break;
+			++colon;
+		}
+#else
+		colon = byte_chr(x, len, ':');
+		if (colon == len)
+			continue;
+#endif
+		if (!stralloc_copyb(&address, x, colon))
+			nomem();
+		if (!stralloc_copys(&data, ""))
+			nomem();
+		x += colon + 1;
+		len -= colon + 1;
+		if ((len >= 4) && byte_equal(x, 4, "deny"))
+		{
+			if (!stralloc_catb(&data, "D", 2))
+				nomem();
+			x += 4;
+			len -= 4;
+		} else
+		if ((len >= 5) && byte_equal(x, 5, "allow"))
+		{
+			x += 5;
+			len -= 5;
+		} else
+			die_bad();
+		while (len)
+		{
+			switch (*x)
+			{
+			case ',':
+				e = byte_chr(x + 1, len - 1, ',');
+				i = byte_chr(x, len, '=');
+				if (i > e) {
+					if (e < 2 || x[1] != '!')
+						die_bad();
+					if (!stralloc_catb(&data, "-", 1))
+						nomem();
+					if (!stralloc_catb(&data, x + 2, e - 1))
+						nomem();
+					if (!stralloc_0(&data))
+						nomem();
+					x += e + 1;
+					len -= e + 1;
+					break;
+				}
+				if (!stralloc_catb(&data, "+", 1))
+					nomem();
+				if (!stralloc_catb(&data, x + 1, i))
+					nomem();
+				x += i + 1;
+				len -= i + 1;
+				if (!len)
+					die_bad();
+				ch = *x;
+				x += 1;
+				len -= 1;
+				i = byte_chr(x, len, ch);
+				if (i == len)
+					die_bad();
+				if (!stralloc_catb(&data, x, i))
+					nomem();
+				if (!stralloc_0(&data))
+					nomem();
+				x += i + 1;
+				len -= i + 1;
+				break;
+			default:
+				die_bad();
+			}
+		}
+		doaddressdata();
+	}
+	if (cdb_make_finish(&c) == -1)
+		die_write();
+	if (fsync(fd) == -1)
+		die_write();
+	if (close(fd) == -1)
+		die_write();			/*- NFS stupidity */
+	if (rename(fntemp, fn))
+		strerr_die6sys(111, FATAL, "unable to move ", fntemp, " to ", fn, ": ");
+	_exit(0);
 }
diff -Naur tmp/ucspi-tcp-0.88/tcprulescheck.1 ucspi-tcp-0.88/tcprulescheck.1
--- tmp/ucspi-tcp-0.88/tcprulescheck.1	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/tcprulescheck.1	2000-11-16 17:06:19.000000000 +0530
@@ -0,0 +1,33 @@
+.TH tcprulescheck 1
+.SH NAME
+tcprulescheck \- checks tcprules
+.SH SYNOPSIS
+.B tcprulescheck
+.I cdb
+.SH DESCRIPTION
+.B tcprulescheck
+says what
+.BR tcpserver (1)
+will do with a connection from IP address $TCPREMOTEIP with host name
+$TCPREMOTEHOST and remote connection information $TCPREMOTEINFO, following
+the rules compiled into
+.I cdb
+by
+.BR tcprules (1).
+.SH SEE ALSO
+tcpserver(1),
+tcprules(1),
+argv0(1),
+fixcrio(1),
+recordio(1),
+rblsmtpd(1),
+tcpclient(1),
+who@(1),
+date@(1),
+finger@(1),
+http@(1),
+tcpcat(1),
+mconnect(1),
+tcp-environ(5)
+
+http://cr.yp.to/ucspi-tcp.html
diff -Naur tmp/ucspi-tcp-0.88/tcprulescheck.c ucspi-tcp-0.88/tcprulescheck.c
--- tmp/ucspi-tcp-0.88/tcprulescheck.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/tcprulescheck.c	2009-05-29 15:03:01.000000000 +0530
@@ -1,57 +1,82 @@
+/*
+ * $Log: tcprulescheck.c,v $
+ * Revision 1.3  2009-05-29 15:02:57+05:30  Cprogrammer
+ * unset env variables
+ *
+ * Revision 1.2  2003-12-30 00:33:24+05:30  Cprogrammer
+ * added standard header files
+ *
+ * Revision 1.1  2003-10-21 11:18:02+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "byte.h"
 #include "buffer.h"
 #include "strerr.h"
 #include "env.h"
 #include "rules.h"
+#include "open.h"
+#include <unistd.h>
 
-void found(char *data,unsigned int datalen)
+void
+found(char *data, unsigned int datalen)
 {
-  unsigned int next0;
+	unsigned int    next0;
 
-  buffer_puts(buffer_1,"rule ");
-  buffer_put(buffer_1,rules_name.s,rules_name.len);
-  buffer_puts(buffer_1,":\n");
-  while ((next0 = byte_chr(data,datalen,0)) < datalen) {
-    switch(data[0]) {
-      case 'D':
-	buffer_puts(buffer_1,"deny connection\n");
+	buffer_puts(buffer_1, "rule ");
+	buffer_put(buffer_1, rules_name.s, rules_name.len);
+	buffer_puts(buffer_1, ":\n");
+	while ((next0 = byte_chr(data, datalen, 0)) < datalen)
+	{
+		switch (data[0])
+		{
+		case 'D':
+			buffer_puts(buffer_1, "deny connection\n");
+			buffer_flush(buffer_1);
+			_exit(0);
+		case '+':
+			buffer_puts(buffer_1, "set environment variable ");
+			buffer_puts(buffer_1, data + 1);
+			buffer_puts(buffer_1, "\n");
+			break;
+		case '-':
+			buffer_puts(buffer_1, "unset environment variable ");
+			buffer_puts(buffer_1, data + 1);
+			buffer_puts(buffer_1, "\n");
+			break;
+		}
+		++next0;
+		data += next0;
+		datalen -= next0;
+	}
+	buffer_puts(buffer_1, "allow connection\n");
 	buffer_flush(buffer_1);
 	_exit(0);
-      case '+':
-	buffer_puts(buffer_1,"set environment variable ");
-	buffer_puts(buffer_1,data + 1);
-	buffer_puts(buffer_1,"\n");
-	break;
-    }
-    ++next0;
-    data += next0; datalen -= next0;
-  }
-  buffer_puts(buffer_1,"allow connection\n");
-  buffer_flush(buffer_1);
-  _exit(0);
 }
 
-main(int argc,char **argv)
+int
+main(int argc, char **argv)
 {
-  char *fnrules;
-  int fd;
-  char *ip;
-  char *info;
-  char *host;
-
-  fnrules = argv[1];
-  if (!fnrules)
-    strerr_die1x(100,"tcprulescheck: usage: tcprulescheck rules.cdb");
-
-  ip = env_get("TCPREMOTEIP");
-  if (!ip) ip = "0.0.0.0";
-  info = env_get("TCPREMOTEINFO");
-  host = env_get("TCPREMOTEHOST");
-
-  fd = open_read(fnrules);
-  if ((fd == -1) || (rules(found,fd,ip,host,info) == -1))
-    strerr_die3sys(111,"tcprulescheck: fatal: unable to read ",fnrules,": ");
+	char           *fnrules;
+	int             fd;
+	char           *ip;
+	char           *info;
+	char           *host;
+
+	fnrules = argv[1];
+	if (!fnrules)
+		strerr_die1x(100, "tcprulescheck: usage: tcprulescheck rules.cdb");
+
+	ip = env_get("TCPREMOTEIP");
+	if (!ip)
+		ip = "0.0.0.0";
+	info = env_get("TCPREMOTEINFO");
+	host = env_get("TCPREMOTEHOST");
+
+	fd = open_read(fnrules);
+	if ((fd == -1) || (rules(found, fd, ip, host, info) == -1))
+		strerr_die3sys(111, "tcprulescheck: fatal: unable to read ", fnrules, ": ");
 
-  buffer_putsflush(buffer_1,"default:\nallow connection\n");
-  _exit(0);
+	buffer_putsflush(buffer_1, "default:\nallow connection\n");
+	_exit(0);
 }
diff -Naur tmp/ucspi-tcp-0.88/tcpserver.1 ucspi-tcp-0.88/tcpserver.1
--- tmp/ucspi-tcp-0.88/tcpserver.1	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/tcpserver.1	2009-08-10 12:19:54.813357400 +0530
@@ -0,0 +1,297 @@
+.TH tcpserver 1
+.SH NAME
+tcpserver \- accepts incoming TCP connections.
+.SH SYNOPSIS
+.B tcpserver
+[
+.I opts
+]
+.I host
+.I port
+.I prog
+.SH DESCRIPTION
+.I opts
+is a series of getopt-style options.
+.I host
+is one argument.
+.I port
+is one argument.
+.I prog
+consists of one or more arguments. 
+
+.B tcpserver
+waits for connections from TCP clients. For each connection, it runs
+.IR prog ,
+with descriptor 0 reading from the network and descriptor 1 writing to the
+network. It also sets up several environment variables.
+
+The server's address is given by
+.I host
+and
+.IR port .
+.I port
+may be a name from /etc/services or a number; if it is 0,
+.B tcpserver
+will choose a free TCP port.
+.I host
+may be 0, allowing connections to any local IP address; or a dotted-decimal IP
+address, allowing connections only to that address; or a host name, allowing
+connections to the first IP address for that host. Host names are fed through
+qualification using dns_ip4_qualify (dns_ip6_qualify for ipv6).
+
+.B tcpserver
+exits when it receives SIGTERM.
+.SH OPTIONS
+.B General options:
+.TP
+.B \-q
+Quiet. Do not print error messages. 
+.TP
+.B \-Q
+(Default.) Print error messages. 
+.TP
+.B \-v
+Verbose. Print error messages and status messages. 
+.TP
+.B \-V
+Verbose. Print error messages, status messages and IP connection table. 
+.P
+.B Connection options:
+.TP
+.B \-c \fIn
+|
+.B \fIfile
+
+Do not handle more than
+.I n
+simultaneous connections. If there are
+.I n
+simultaneous copies of prog running, defer acceptance of a new connection
+until one copy finishes.
+.I n
+must be a positive integer. Default: 40. In the second form, 
+.I file
+can be a full path to a filename containing an integer specifying
+.IR n .
+This file will be reread when
+.B tcpserver
+receives SIGHUP.
+
+.TP
+.B \-C \fIn
+Do not handle more than
+.I n
+simultaneous connections from a particular host. If there are
+.I n
+simultaneous copies of prog running, defer acceptance of a new connection
+until one copy finishes.
+.I n
+must be a positive integer. Default: 20. This can be also handled by
+having the environment variable MAXPERIP compiled in the
+.I rules
+cdb database. The MAXPERIP environment variables gives
+.B tcpserver
+the ability to have different per host concurrency limit for each and every
+host that is defined in the rules database.
+.TP
+.B \-x \fIcdb
+Follow the rules compiled into
+.I cdb
+by
+.BR tcprules (1).
+These rules may specify setting environment variables or rejecting connections
+from bad sources. You can rerun
+.BR tcprules (1)
+to change the rules while
+.B tcpserver
+is running. 
+.TP
+.B \-X
+With
+.B -x \fIcdb,
+allow connections even if
+.I cdb
+does not exist. Normally
+.B tcpserver
+will drop the connection if
+.I cdb
+does not exist.
+
+.TP
+.B \-m \fIdb.conf
+Follow rules specified in the MySQL table tcprules. This table has 4 columns. The column
+.I iprules
+contains an IP address which can include wildcards. eg. 202.144.*.?, 202.144.10-20.1, etc. The column
+.I decision
+can have the value
+.I 'D'
+to deny connections for matching IP addresses. The column
+.I env
+contains a list of comma separated environment variables. e.g /var/indimail=/tmp,SERVER=galaxy.
+The db.conf file has the following layout
+
+database server ip:database user:database password:database name:table name
+
+with this option,
+.I tcpserver
+will connect to the
+.B MySQL(1)
+server specified by parameters in db.conf file. The connect timeout can be controlled by the environment variable
+.BR MYSQL_TIMEOUT .
+
+.TP
+.B \-B \fIbanner
+Write
+.I banner
+to the network immediately after each connection is made.
+.B tcpserver
+writes
+.I banner
+before looking up $TCPREMOTEHOST, before looking up $TCPREMOTEINFO, and before
+checking
+.IR cdb .
+This feature can be used to reduce latency in protocols where the client waits
+for a greeting from the server. 
+.TP
+.B \-g \fIgid
+Switch group ID to
+.I gid
+after preparing to receive connections.
+.I gid
+must be a positive integer. 
+.TP
+.B \-u \fIuid
+Switch user ID to
+.I uid
+after preparing to receive connections.
+.I uid
+must be a positive integer. 
+.TP
+.B \-U
+Same as
+.B \-g
+$GID
+.B \-u
+$UID. Typically $GID and $UID are set by
+.BR envuidgid (8).
+.TP
+.B \-1
+After preparing to receive connections, print the local port number to
+standard output. 
+.TP
+.B \-4
+Fall back to IPv4 sockets.  This is necessary for terminally broken
+systems like OpenBSD which will not let IPv6 sockets connect to
+V4-mapped IPv6 addresses.  Please note that this also applies to DNS
+lookups, so you will have to use an DNS resolver with an IPv6 address to
+accept IPv6 connections.  Use \fBDNSCACHEIP\fR to set the DNS resolver
+IP dynamically.
+.TP
+.B \-6
+Force IPv6 mode in UCSPI environment variables, even for
+IPv4 connections.  This will set \fB$PROTO\fR to \fBTCP6\fR and put
+IPv4-mapped IPv6 addresses in \fBTCPLOCALIP\fR and \fBTCPREMOTEIP\fR.
+.TP
+.B \-I\fIinterface
+Bind to the network interface
+.I interface
+("eth0" on Linux, for example).  This is only defined and needed for
+IPv6 link-local addresses.
+.TP
+.B \-b \fIn
+Allow a backlog of approximately
+\I n
+TCP SYNs. On some systems,
+\I n
+is silently limited to 5. On systems supporting SYN cookies, the backlog is
+irrelevant. 
+.TP
+.B \-o
+Leave IP options alone. If the client is sending packets along an IP source
+route, send packets back along the same route.
+.TP
+.B \-O
+(Default.) Kill IP options. A client can still use source routing to connect
+and to send data, but packets will be sent back along the default route.
+.TP
+.B \-d
+Delay sending data for a fraction of a second whenever the remote host is
+responding slowly. This is currently the default, but it may not be in the
+future; if you want it, set it explicitly. 
+.TP
+.B \-D
+Never delay sending data; enable TCP_NODELAY. 
+.P
+.B Data-gathering options: 
+.TP
+.B \-h
+(Default.) Look up the remote host name in DNS to set the environment variable
+$TCPREMOTEHOST. 
+.TP
+.B \-H
+Do not look up the remote host name in DNS; remove the environment variable
+$TCPREMOTEHOST. To avoid loops, you must use this option for servers on TCP
+port 53. 
+.TP
+.B \-p
+Paranoid. After looking up the remote host name in DNS, look up the IP
+addresses in DNS for that host name, and remove the environment variable
+$TCPREMOTEHOST if none of the addresses match the client's IP address.
+.TP
+.B \-P
+(Default.) Not paranoid. 
+.TP
+.B \-l \fIlocalname
+Do not look up the local host name in DNS; use
+.I localname
+for the environment variable $TCPLOCALHOST. A common choice for
+.I localname
+is 0. To avoid loops, you must use this option for servers on TCP port 53. 
+.TP
+.B \-r
+(Default.) Attempt to obtain $TCPREMOTEINFO from the remote host. 
+.TP
+.B  \-R
+Do not attempt to obtain $TCPREMOTEINFO from the remote host. To avoid loops,
+you must use this option for servers on TCP ports 53 and 113.
+.TP
+.B \-t \fIn
+Give up on the $TCPREMOTEINFO connection attempt after
+.I n
+seconds. Default: 26.
+.TP
+.B \-s
+Use ssl with servercert.pem certificate.
+.TP
+.B \-n \fIcertfile
+Instead of the default servercert.pem certificate use the specified
+.IR certfile .
+
+.SH ENVIRONMENT
+.TP
+.B SSL_CIPHER
+Specifies the ciphers that should be used in SSL/TLS mode. See
+.I openssl(1)
+for more information.
+.TP
+.B CONTROLDIR
+Sub-directory relative to /var/indimail, having servercert.pem. Default is /var/indimail/control.
+
+.SH SEE ALSO
+tcprules(1),
+tcprulescheck(1),
+argv0(1),
+fixcrio(1),
+recordio(1),
+rblsmtpd(1),
+tcpclient(1),
+who@(1),
+date@(1),
+finger@(1),
+http@(1),
+tcpcat(1),
+mconnect(1),
+openssl(1),
+tcp-environ(5)
+
+http://cr.yp.to/ucspi-tcp.html
diff -Naur tmp/ucspi-tcp-0.88/tcpserver.9 ucspi-tcp-0.88/tcpserver.9
--- tmp/ucspi-tcp-0.88/tcpserver.9	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/tcpserver.9	2009-05-30 22:01:56.000000000 +0530
@@ -0,0 +1,294 @@
+.TH tcpserver 1
+.SH NAME
+tcpserver \- accepts incoming TCP connections.
+.SH SYNOPSIS
+.B tcpserver
+[
+.I opts
+]
+.I host
+.I port
+.I prog
+.SH DESCRIPTION
+.I opts
+is a series of getopt-style options.
+.I host
+is one argument.
+.I port
+is one argument.
+.I prog
+consists of one or more arguments. 
+
+.B tcpserver
+waits for connections from TCP clients. For each connection, it runs
+.IR prog ,
+with descriptor 0 reading from the network and descriptor 1 writing to the
+network. It also sets up several environment variables.
+
+The server's address is given by
+.I host
+and
+.IR port .
+.I port
+may be a name from /etc/services or a number; if it is 0,
+.B tcpserver
+will choose a free TCP port.
+.I host
+may be 0, allowing connections to any local IP address; or a dotted-decimal IP
+address, allowing connections only to that address; or a host name, allowing
+connections to the first IP address for that host. Host names are fed through
+qualification using dns_ip4_qualify (dns_ip6_qualify for ipv6).
+
+.B tcpserver
+exits when it receives SIGTERM.
+.SH OPTIONS
+.B General options:
+.TP
+.B \-q
+Quiet. Do not print error messages. 
+.TP
+.B \-Q
+(Default.) Print error messages. 
+.TP
+.B \-v
+Verbose. Print error messages and status messages. 
+.TP
+.B \-V
+Verbose. Print error messages, status messages and IP connection table. 
+.P
+.B Connection options:
+.TP
+.B \-c \fIn
+|
+.B \fIfile
+
+Do not handle more than
+.I n
+simultaneous connections. If there are
+.I n
+simultaneous copies of prog running, defer acceptance of a new connection
+until one copy finishes.
+.I n
+must be a positive integer. Default: 40. In the second form, 
+.I file
+can be a full path to a filename containing an integer specifying
+.IR n .
+This file will be reread when
+.B tcpserver
+receives SIGHUP.
+
+.TP
+.B \-C \fIn
+Do not handle more than
+.I n
+simultaneous connections from a particular host. If there are
+.I n
+simultaneous copies of prog running, defer acceptance of a new connection
+until one copy finishes.
+.I n
+must be a positive integer. Default: 20. This can be also handled by
+having the environment variable MAXPERIP compiled in the
+.I rules
+cdb database. The MAXPERIP environment variables gives
+.B tcpserver
+the ability to have different per host concurrency limit for each and every
+host that is defined in the rules database.
+.TP
+.B \-x \fIcdb
+Follow the rules compiled into
+.I cdb
+by
+.BR tcprules (1).
+These rules may specify setting environment variables or rejecting connections
+from bad sources. You can rerun
+.BR tcprules (1)
+to change the rules while
+.B tcpserver
+is running. 
+.TP
+.B \-X
+With
+.B -x \fIcdb,
+allow connections even if
+.I cdb
+does not exist. Normally
+.B tcpserver
+will drop the connection if
+.I cdb
+does not exist.
+
+.TP
+.B \-m \fIdb.conf
+Follow rules specified in the MySQL table tcprules. This table has 4 columns. The column
+.I iprules
+contains an IP address which can include wildcards. eg. 202.144.*.?, 202.144.10-20.1, etc. The column
+.I decision
+can have the value
+.I 'D'
+to deny connections for matching IP addresses. The column
+.I env
+contains a list of comma separated environment variables. e.g HOME=/tmp,SERVER=galaxy.
+The db.conf file has the following layout
+
+database server ip:database user:database password:database name:table name
+
+with this option,
+.I tcpserver
+will connect to the
+.B MySQL(1)
+server specified by parameters in db.conf file. The connect timeout can be controlled by the environment variable
+.BR MYSQL_TIMEOUT .
+
+.TP
+.B \-B \fIbanner
+Write
+.I banner
+to the network immediately after each connection is made.
+.B tcpserver
+writes
+.I banner
+before looking up $TCPREMOTEHOST, before looking up $TCPREMOTEINFO, and before
+checking
+.IR cdb .
+This feature can be used to reduce latency in protocols where the client waits
+for a greeting from the server. 
+.TP
+.B \-g \fIgid
+Switch group ID to
+.I gid
+after preparing to receive connections.
+.I gid
+must be a positive integer. 
+.TP
+.B \-u \fIuid
+Switch user ID to
+.I uid
+after preparing to receive connections.
+.I uid
+must be a positive integer. 
+.TP
+.B \-U
+Same as
+.B \-g
+$GID
+.B \-u
+$UID. Typically $GID and $UID are set by
+.BR envuidgid (8).
+.TP
+.B \-1
+After preparing to receive connections, print the local port number to
+standard output. 
+.TP
+.B \-4
+Fall back to IPv4 sockets.  This is necessary for terminally broken
+systems like OpenBSD which will not let IPv6 sockets connect to
+V4-mapped IPv6 addresses.  Please note that this also applies to DNS
+lookups, so you will have to use an DNS resolver with an IPv6 address to
+accept IPv6 connections.  Use \fBDNSCACHEIP\fR to set the DNS resolver
+IP dynamically.
+.TP
+.B \-6
+Force IPv6 mode in UCSPI environment variables, even for
+IPv4 connections.  This will set \fB$PROTO\fR to \fBTCP6\fR and put
+IPv4-mapped IPv6 addresses in \fBTCPLOCALIP\fR and \fBTCPREMOTEIP\fR.
+.TP
+.B \-I\fIinterface
+Bind to the network interface
+.I interface
+("eth0" on Linux, for example).  This is only defined and needed for
+IPv6 link-local addresses.
+.TP
+.B \-b \fIn
+Allow a backlog of approximately
+\I n
+TCP SYNs. On some systems,
+\I n
+is silently limited to 5. On systems supporting SYN cookies, the backlog is
+irrelevant. 
+.TP
+.B \-o
+Leave IP options alone. If the client is sending packets along an IP source
+route, send packets back along the same route.
+.TP
+.B \-O
+(Default.) Kill IP options. A client can still use source routing to connect
+and to send data, but packets will be sent back along the default route.
+.TP
+.B \-d
+Delay sending data for a fraction of a second whenever the remote host is
+responding slowly. This is currently the default, but it may not be in the
+future; if you want it, set it explicitly. 
+.TP
+.B \-D
+Never delay sending data; enable TCP_NODELAY. 
+.P
+.B Data-gathering options: 
+.TP
+.B \-h
+(Default.) Look up the remote host name in DNS to set the environment variable
+$TCPREMOTEHOST. 
+.TP
+.B \-H
+Do not look up the remote host name in DNS; remove the environment variable
+$TCPREMOTEHOST. To avoid loops, you must use this option for servers on TCP
+port 53. 
+.TP
+.B \-p
+Paranoid. After looking up the remote host name in DNS, look up the IP
+addresses in DNS for that host name, and remove the environment variable
+$TCPREMOTEHOST if none of the addresses match the client's IP address.
+.TP
+.B \-P
+(Default.) Not paranoid. 
+.TP
+.B \-l \fIlocalname
+Do not look up the local host name in DNS; use
+.I localname
+for the environment variable $TCPLOCALHOST. A common choice for
+.I localname
+is 0. To avoid loops, you must use this option for servers on TCP port 53. 
+.TP
+.B \-r
+(Default.) Attempt to obtain $TCPREMOTEINFO from the remote host. 
+.TP
+.B  \-R
+Do not attempt to obtain $TCPREMOTEINFO from the remote host. To avoid loops,
+you must use this option for servers on TCP ports 53 and 113.
+.TP
+.B \-t \fIn
+Give up on the $TCPREMOTEINFO connection attempt after
+.I n
+seconds. Default: 26.
+.TP
+.B \-n \fIcertfile
+Instead of the default servercert.pem certificate use the specified
+.IR certfile .
+
+.SH ENVIRONMENT
+.TP
+.B SSL_CIPHER
+Specifies the ciphers that should be used in SSL/TLS mode. See
+.I openssl(1)
+for more information.
+.TP
+.B CONTROLDIR
+Sub-directory relative to HOME, having servercert.pem. Default is HOME/control.
+
+.SH SEE ALSO
+tcprules(1),
+tcprulescheck(1),
+argv0(1),
+fixcrio(1),
+recordio(1),
+rblsmtpd(1),
+tcpclient(1),
+who@(1),
+date@(1),
+finger@(1),
+http@(1),
+tcpcat(1),
+mconnect(1),
+openssl(1),
+tcp-environ(5)
+
+http://cr.yp.to/ucspi-tcp.html
diff -Naur tmp/ucspi-tcp-0.88/tcpserver.c ucspi-tcp-0.88/tcpserver.c
--- tmp/ucspi-tcp-0.88/tcpserver.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/tcpserver.c	2009-08-15 23:38:28.843485564 +0530
@@ -1,426 +1,1743 @@
+/*
+ * $Log: tcpserver.c,v $
+ * Revision 1.42  2009-08-12 09:37:16+05:30  Cprogrammer
+ * corrected display of usage
+ *
+ * Revision 1.41  2009-05-31 09:35:08+05:30  Cprogrammer
+ * use CONTROL dir for certificats
+ * added -s option for default certificate
+ *
+ * Revision 1.40  2009-05-29 15:54:48+05:30  Cprogrammer
+ * unset env variables with - rule
+ * set SSL_CIPHER
+ * use ssl if -n option is provided
+ *
+ * Revision 1.39  2009-05-26 12:23:31+05:30  Cprogrammer
+ * added setting of environment variable TCPPARANOID
+ *
+ * Revision 1.38  2009-05-05 14:58:10+05:30  Cprogrammer
+ * close mysql connections
+ *
+ * Revision 1.37  2008-07-30 12:12:31+05:30  Cprogrammer
+ * configure mysql automatically
+ *
+ * Revision 1.36  2008-07-29 23:01:48+05:30  Cprogrammer
+ * mysql code made compile time configurable
+ *
+ * Revision 1.35  2008-07-25 16:50:23+05:30  Cprogrammer
+ * fix for darwin
+ *
+ * Revision 1.34  2008-07-17 23:05:12+05:30  Cprogrammer
+ * removed readwrite.h
+ *
+ * Revision 1.33  2008-06-30 16:11:14+05:30  Cprogrammer
+ * removed license code
+ *
+ * Revision 1.32  2008-06-30 09:39:45+05:30  Cprogrammer
+ * removed compilation warning
+ *
+ * Revision 1.31  2008-06-12 14:31:04+05:30  Cprogrammer
+ * added mysql patch by Levent Serinol.
+ *
+ * Revision 1.30  2007-06-10 10:18:03+05:30  Cprogrammer
+ * fixed ipv6 issue
+ * added compile time license option
+ *
+ * Revision 1.29  2005-06-11 02:11:35+05:30  Cprogrammer
+ * added IPV6 and SSL support
+ *
+ * Revision 1.28  2004-10-12 00:31:47+05:30  Cprogrammer
+ * renamed remoteinfo.h to tcpremoteinfo.h
+ *
+ * Revision 1.27  2004-09-30 23:23:26+05:30  Cprogrammer
+ * BUG - Fixed segmentation fault when concurrency was increased and sighup
+ * was given
+ *
+ * Revision 1.26  2004-09-29 10:56:28+05:30  Cprogrammer
+ * made maxperip code to work
+ *
+ * Revision 1.25  2004-09-24 10:05:03+05:30  Cprogrammer
+ * added configurable max per ip limit
+ *
+ * Revision 1.24  2004-05-12 09:00:49+05:30  Cprogrammer
+ * change in checklicense()
+ * corrected compilation warning for fedora core
+ *
+ * Revision 1.23  2003-12-31 20:06:13+05:30  Cprogrammer
+ * print receipt of sighup on stderr
+ *
+ * Revision 1.22  2003-12-30 00:33:45+05:30  Cprogrammer
+ * made concurrency configurable.
+ *
+ * Revision 1.21  2003-12-25 23:45:33+05:30  Cprogrammer
+ * BUG - wrongly used remoteip instead of remoteipstr
+ * print IPs only if verbosity >= 2
+ *
+ * Revision 1.20  2003-10-17 21:08:31+05:30  Cprogrammer
+ * added tcpserver: tag in print_ip()
+ *
+ * Revision 1.19  2003-10-11 09:17:17+05:30  Cprogrammer
+ * print per host concurrency in log
+ *
+ * Revision 1.18  2003-09-23 15:50:15+05:30  Cprogrammer
+ * added license code
+ * numchildren did not get decremented when PerHostLimit was reached
+ *
+ * Revision 1.17  2002-08-19 19:58:02+05:30  Cprogrammer
+ * removed mysql code
+ *
+ * Revision 1.16  2002-08-18 13:56:06+05:30  Cprogrammer
+ * shifted snprintf for better efficiency
+ *
+ * Revision 1.15  2002-04-10 10:47:50+05:30  Cprogrammer
+ * fifo path was wrong
+ *
+ * Revision 1.14  2002-04-09 13:53:31+05:30  Cprogrammer
+ * *** empty log message ***
+ *
+ * Revision 1.13  2002-04-08 04:46:45+05:30  Cprogrammer
+ * *** empty log message ***
+ *
+ */
+#include <fcntl.h>
+#include <netdb.h>
+#include <unistd.h>
 #include <sys/types.h>
 #include <sys/param.h>
-#include <netdb.h>
-#include "uint16.h"
+#include <sys/ipc.h>
+#ifdef TLS
+#include <openssl/ssl.h>
+#endif
 #include "str.h"
 #include "byte.h"
 #include "fmt.h"
 #include "scan.h"
+#include "uint16.h"
 #include "ip4.h"
+#ifdef IPV6
+#include "ip6.h"
+#include "uint32.h"
+#endif
 #include "fd.h"
 #include "exit.h"
 #include "env.h"
 #include "prot.h"
 #include "open.h"
 #include "wait.h"
-#include "readwrite.h"
 #include "stralloc.h"
 #include "alloc.h"
 #include "buffer.h"
 #include "error.h"
 #include "strerr.h"
+#include <getopt.h>
+#ifdef DARWIN
+#define opteof -1
+#else
 #include "sgetopt.h"
+#endif
 #include "pathexec.h"
 #include "socket.h"
 #include "ndelay.h"
-#include "remoteinfo.h"
+#include "tcpremoteinfo.h"
 #include "rules.h"
 #include "sig.h"
 #include "dns.h"
-
-int verbosity = 1;
-int flagkillopts = 1;
-int flagdelay = 1;
-char *banner = "";
-int flagremoteinfo = 1;
-int flagremotehost = 1;
-int flagparanoid = 0;
-unsigned long timeout = 26;
+#include "hasmysql.h"
+#include "control.h"
+#include "auto_home.h"
+
+#ifndef	lint
+static char     sccsid[] = "$Id: tcpserver.c,v 1.42 2009-08-12 09:37:16+05:30 Cprogrammer Stab mbhangui $";
+#endif
+
+#ifdef IPV6
+int             forcev6 = 0;
+uint32          netif = 0;
+#endif
+int             verbosity = 1;
+int             flagkillopts = 1;
+int             flagdelay = 1;
+char           *banner = "";
+int             flagremoteinfo = 1;
+int             flagremotehost = 1;
+int             flagparanoid = 0;
+int             verbose;
+unsigned long   timeout = 26, maxperip = 20;
+#ifdef TLS
+int             flagssl = 0;
+struct stralloc certfile = {0};
+#endif
 
 static stralloc tcpremoteinfo;
-
-uint16 localport;
-char localportstr[FMT_ULONG];
-char localip[4];
-char localipstr[IP4_FMT];
+uint16          localport;
+char            localportstr[FMT_ULONG];
+#ifdef IPV6
+char            localip[16];
+char            localipstr[IP6_FMT];
+char            remoteip[16];
+char            remoteipstr[IP6_FMT];
+#else
+char            localip[4];
+char            localipstr[IP4_FMT];
+char            remoteip[4];
+char            remoteipstr[IP4_FMT];
+#endif
 static stralloc localhostsa;
-char *localhost = 0;
-
-uint16 remoteport;
-char remoteportstr[FMT_ULONG];
-char remoteip[4];
-char remoteipstr[IP4_FMT];
+char           *localhost = 0;
+uint16          remoteport;
+char            remoteportstr[FMT_ULONG];
 static stralloc remotehostsa;
-char *remotehost = 0;
+char           *remotehost = 0;
 
-char strnum[FMT_ULONG];
-char strnum2[FMT_ULONG];
+char            strnum[FMT_ULONG];
+char            strnum2[FMT_ULONG];
 
 static stralloc tmp;
 static stralloc fqdn;
 static stralloc addresses;
 
-char bspace[16];
-buffer b;
+int             flag1 = 0;
+char            bspace[16];
+buffer          b;
+static stralloc limitFile;
+
+unsigned long   limit = 40;
+unsigned long   alloc_count = 0;
+unsigned long   PerHostLimit = 20;
+unsigned long   numchildren = 0;
+unsigned long   backlog = 20;
+unsigned long   uid = 0;
+unsigned long   gid = 0;
 
+struct iptable
+{
+	char            ipaddr[16];
+	pid_t           pid;
+};
+typedef struct iptable IPTABLE;
+IPTABLE      **IpTable;
+
+void            add_ip(pid_t);
+void            print_ip();
+unsigned long   check_ip();
+void            remove_ip(pid_t);
+int             socket_ipoptionskill(int);
+int             socket_tcpnodelay(int);
+#ifdef TLS
+void            translate(SSL*, int, int, unsigned int);
+#endif
+
+/*---------------------------- child */
+
+#define DROP  "tcpserver: warning: dropping connection, "
+
+int             flagdeny = 0;
+int             flagallownorules = 0;
+char           *fnrules = 0;
 
+void
+drop_nomem(void)
+{
+	strerr_die2sys(111, DROP, "out of memory");
+}
 
-/* ---------------------------- child */
+void
+cats(char *s)
+{
+	if (!stralloc_cats(&tmp, s))
+		drop_nomem();
+}
 
-#define DROP "tcpserver: warning: dropping connection, "
+void
+append(char *ch)
+{
+	if (!stralloc_append(&tmp, ch))
+		drop_nomem();
+}
 
-int flagdeny = 0;
-int flagallownorules = 0;
-char *fnrules = 0;
-
-void drop_nomem(void)
-{
-  strerr_die2sys(111,DROP,"out of memory");
-}
-void cats(char *s)
-{
-  if (!stralloc_cats(&tmp,s)) drop_nomem();
-}
-void append(char *ch)
-{
-  if (!stralloc_append(&tmp,ch)) drop_nomem();
-}
-void safecats(char *s)
-{
-  char ch;
-  int i;
-
-  for (i = 0;i < 100;++i) {
-    ch = s[i];
-    if (!ch) return;
-    if (ch < 33) ch = '?';
-    if (ch > 126) ch = '?';
-    if (ch == '%') ch = '?'; /* logger stupidity */
-    if (ch == ':') ch = '?';
-    append(&ch);
-  }
-  cats("...");
-}
-void env(char *s,char *t)
-{
-  if (!pathexec_env(s,t)) drop_nomem();
-}
-void drop_rules(void)
-{
-  strerr_die4sys(111,DROP,"unable to read ",fnrules,": ");
-}
-
-void found(char *data,unsigned int datalen)
-{
-  unsigned int next0;
-  unsigned int split;
-
-  while ((next0 = byte_chr(data,datalen,0)) < datalen) {
-    switch(data[0]) {
-      case 'D':
-	flagdeny = 1;
-	break;
-      case '+':
-	split = str_chr(data + 1,'=');
-	if (data[1 + split] == '=') {
-	  data[1 + split] = 0;
-	  env(data + 1,data + 1 + split + 1);
-	}
-	break;
-    }
-    ++next0;
-    data += next0; datalen -= next0;
-  }
-}
-
-void doit(int t)
-{
-  int j;
-
-  remoteipstr[ip4_fmt(remoteipstr,remoteip)] = 0;
-
-  if (verbosity >= 2) {
-    strnum[fmt_ulong(strnum,getpid())] = 0;
-    strerr_warn4("tcpserver: pid ",strnum," from ",remoteipstr,0);
-  }
-
-  if (flagkillopts)
-    socket_ipoptionskill(t);
-  if (!flagdelay)
-    socket_tcpnodelay(t);
-
-  if (*banner) {
-    buffer_init(&b,write,t,bspace,sizeof bspace);
-    if (buffer_putsflush(&b,banner) == -1)
-      strerr_die2sys(111,DROP,"unable to print banner: ");
-  }
-
-  if (socket_local4(t,localip,&localport) == -1)
-    strerr_die2sys(111,DROP,"unable to get local address: ");
-
-  localipstr[ip4_fmt(localipstr,localip)] = 0;
-  remoteportstr[fmt_ulong(remoteportstr,remoteport)] = 0;
-
-  if (!localhost)
-    if (dns_name4(&localhostsa,localip) == 0)
-      if (localhostsa.len) {
-	if (!stralloc_0(&localhostsa)) drop_nomem();
-	localhost = localhostsa.s;
-      }
-  env("PROTO","TCP");
-  env("TCPLOCALIP",localipstr);
-  env("TCPLOCALPORT",localportstr);
-  env("TCPLOCALHOST",localhost);
-
-  if (flagremotehost)
-    if (dns_name4(&remotehostsa,remoteip) == 0)
-      if (remotehostsa.len) {
-	if (flagparanoid)
-	  if (dns_ip4(&tmp,&remotehostsa) == 0)
-	    for (j = 0;j + 4 <= tmp.len;j += 4)
-	      if (byte_equal(remoteip,4,tmp.s + j)) {
-		flagparanoid = 0;
-		break;
-	      }
-	if (!flagparanoid) {
-	  if (!stralloc_0(&remotehostsa)) drop_nomem();
-	  remotehost = remotehostsa.s;
-	}
-      }
-  env("TCPREMOTEIP",remoteipstr);
-  env("TCPREMOTEPORT",remoteportstr);
-  env("TCPREMOTEHOST",remotehost);
-
-  if (flagremoteinfo) {
-    if (remoteinfo(&tcpremoteinfo,remoteip,remoteport,localip,localport,timeout) == -1)
-      flagremoteinfo = 0;
-    if (!stralloc_0(&tcpremoteinfo)) drop_nomem();
-  }
-  env("TCPREMOTEINFO",flagremoteinfo ? tcpremoteinfo.s : 0);
-
-  if (fnrules) {
-    int fdrules;
-    fdrules = open_read(fnrules);
-    if (fdrules == -1) {
-      if (errno != error_noent) drop_rules();
-      if (!flagallownorules) drop_rules();
-    }
-    else {
-      if (rules(found,fdrules,remoteipstr,remotehost,flagremoteinfo ? tcpremoteinfo.s : 0) == -1) drop_rules();
-      close(fdrules);
-    }
-  }
-
-  if (verbosity >= 2) {
-    strnum[fmt_ulong(strnum,getpid())] = 0;
-    if (!stralloc_copys(&tmp,"tcpserver: ")) drop_nomem();
-    safecats(flagdeny ? "deny" : "ok");
-    cats(" "); safecats(strnum);
-    cats(" "); if (localhost) safecats(localhost);
-    cats(":"); safecats(localipstr);
-    cats(":"); safecats(localportstr);
-    cats(" "); if (remotehost) safecats(remotehost);
-    cats(":"); safecats(remoteipstr);
-    cats(":"); if (flagremoteinfo) safecats(tcpremoteinfo.s);
-    cats(":"); safecats(remoteportstr);
-    cats("\n");
-    buffer_putflush(buffer_2,tmp.s,tmp.len);
-  }
+void
+safecats(char *s)
+{
+	char            ch;
+	int             i;
 
-  if (flagdeny) _exit(100);
+	for (i = 0; i < 100; ++i)
+	{
+		if (!(ch = s[i]))
+			return;
+		if (ch < 33)
+			ch = '?';
+		if (ch > 126)
+			ch = '?';
+		if (ch == '%')
+			ch = '?'; /*- logger stupidity */
+#ifndef IPV6
+		if (ch == ':')
+			ch = '?';
+#endif
+		append(&ch);
+	}
+	cats("..."); /*- Line longer than 100 bytes */
 }
 
+void
+env(char *s, char *t)
+{
+	if (str_equal(s, "MAXPERIP"))
+		scan_ulong(t, &maxperip);
+	if (!pathexec_env(s, t))
+		drop_nomem();
+}
+
+void
+drop_rules(void)
+{
+	strerr_die4sys(111, DROP, "unable to read ", fnrules, ": ");
+}
+
+void
+found(char *data, unsigned int datalen)
+{
+	unsigned int    next0;
+	unsigned int    split;
+
+	while ((next0 = byte_chr(data, datalen, 0)) < datalen)
+	{
+		switch (data[0])
+		{
+		case 'D':
+			flagdeny = 1;
+			break;
+		case '+':
+			split = str_chr(data + 1, '=');
+			if (data[1 + split] == '=')
+			{
+				data[1 + split] = 0;
+				env(data + 1, data + 1 + split + 1);
+			}
+			break;
+		case '-':
+			env(data + 1, (char *)0);
+			break;
+		}
+		++next0;
+		data += next0;
+		datalen -= next0;
+	}
+}
 
+void
+doit(int t)
+{
+	int             j;
+#ifdef IPV6
+	int             fakev4 = 0;
+	uint32          scope_id;
+#endif
+
+#ifdef IPV6
+	if (!forcev6 && ip6_isv4mapped(remoteip))
+		fakev4 = 1;
+	if (fakev4)
+		remoteipstr[ip4_fmt(remoteipstr, remoteip + 12)] = 0;
+	else
+		remoteipstr[ip6_fmt(remoteipstr, remoteip)] = 0;
+#else
+	remoteipstr[ip4_fmt(remoteipstr, remoteip)] = 0;
+#endif
+	if (verbosity >= 2)
+	{
+		strnum[fmt_ulong(strnum, getpid())] = 0;
+		strerr_warn4("tcpserver: pid ", strnum, " from ", remoteipstr, 0);
+	}
+	if (flagkillopts)
+		socket_ipoptionskill(t);
+	if (!flagdelay)
+		socket_tcpnodelay(t);
+	if (*banner)
+	{
+		buffer_init(&b, write, t, bspace, sizeof bspace);
+		if (buffer_putsflush(&b, banner) == -1)
+			strerr_die2sys(111, DROP, "unable to print banner: ");
+	}
+#ifdef IPV6
+	if (socket_local6(t, localip, &localport, &scope_id) == -1)
+#else
+	if (socket_local4(t, localip, &localport) == -1)
+#endif
+		strerr_die2sys(111, DROP, "unable to get local address: ");
+#ifdef IPV6
+	if (fakev4)
+		localipstr[ip4_fmt(localipstr, localip + 12)] = 0;
+	else
+		localipstr[ip6_fmt(localipstr, localip)] = 0;
+#else
+	localipstr[ip4_fmt(localipstr, localip)] = 0;
+#endif
+	remoteportstr[fmt_ulong(remoteportstr, remoteport)] = 0;
+#ifdef IPV6
+	if (!localhost && !dns_name6(&localhostsa, localip))
+#else
+	if (!localhost && !dns_name4(&localhostsa, localip))
+#endif
+	{
+		if (localhostsa.len)
+		{
+			if (!stralloc_0(&localhostsa))
+				drop_nomem();
+			localhost = localhostsa.s;
+		}
+	}
+#ifdef IPV6
+	env("PROTO", fakev4 ? "TCP" : "TCP6");
+#else
+	env("PROTO", "TCP");
+#endif
+	env("TCPLOCALIP", localipstr);
+	env("TCPLOCALPORT", localportstr);
+	env("TCPLOCALHOST", localhost);
+#ifdef IPV6
+	localipstr[ip6_fmt(localipstr, localip)] = 0;
+	env("TCP6LOCALIP", localipstr);
+	env("TCP6LOCALPORT", localportstr);
+	env("TCP6LOCALHOST", localhost);
+	if (!fakev4 && scope_id)
+		env("TCP6INTERFACE", (char *) socket_getifname(scope_id));
+	if (flagremotehost && !dns_name6(&remotehostsa, remoteip))
+#else
+	if (flagremotehost && !dns_name4(&remotehostsa, remoteip))
+#endif
+	{
+		if (remotehostsa.len)
+		{
+#ifdef IPV6
+			if (flagparanoid && !dns_ip6(&tmp, &remotehostsa))
+#else
+			if (flagparanoid && !dns_ip4(&tmp, &remotehostsa))
+#endif
+			{
+#ifdef IPV6
+				for (j = 0; j + 16 <= tmp.len; j += 16)
+#else
+				for (j = 0; j + 4 <= tmp.len; j += 4)
+#endif
+				{
+#ifdef IPV6
+					if (byte_equal(remoteip, 16, tmp.s + j))
+#else
+					if (byte_equal(remoteip, 4, tmp.s + j))
+#endif
+					{
+						flagparanoid = 0;
+						break;
+					}
+				}
+			}
+			if (!flagparanoid)
+			{
+				if (!stralloc_0(&remotehostsa))
+					drop_nomem();
+				remotehost = remotehostsa.s;
+			} else
+				env("TCPPARANOID", remotehostsa.s);
+		}
+	}
+	env("TCPREMOTEIP", remoteipstr);
+	env("TCPREMOTEPORT", remoteportstr);
+	env("TCPREMOTEHOST", remotehost);
+#ifdef IPV6
+	remoteipstr[ip6_fmt(remoteipstr, remoteip)] = 0;
+	env("TCP6REMOTEIP", remoteipstr);
+	env("TCP6REMOTEPORT", remoteportstr);
+	env("TCP6REMOTEHOST", remotehost);
+#endif
+	if (flagremoteinfo)
+	{
+#ifdef IPV6
+		if (remoteinfo6(&tcpremoteinfo, remoteip, remoteport, localip, localport, timeout, netif) == -1)
+#else
+		if (remoteinfo(&tcpremoteinfo, remoteip, remoteport, localip, localport, timeout) == -1)
+#endif
+			flagremoteinfo = 0;
+		if (!stralloc_0(&tcpremoteinfo))
+			drop_nomem();
+	}
+	env("TCPREMOTEINFO", flagremoteinfo ? tcpremoteinfo.s : 0);
+#ifdef IPV6
+	env("TCP6REMOTEINFO", flagremoteinfo ? tcpremoteinfo.s : 0);
+#endif
+	if (fnrules)
+	{
+		int             fdrules;
+
+		if ((fdrules = open_read(fnrules)) == -1)
+		{
+			if (errno != error_noent)
+				drop_rules();
+			if (!flagallownorules)
+				drop_rules();
+		} else
+		{
+			char           *temp;
+#ifdef IPV6
+			if (fakev4)
+				temp = remoteipstr + 7;
+			else
+				temp = remoteipstr;
+#else
+			temp = remoteipstr;
+#endif
+			if (rules(found, fdrules, temp, remotehost, flagremoteinfo ? tcpremoteinfo.s : 0) == -1)
+				drop_rules();
+			close(fdrules);
+		}
+	}
+	if (verbosity >= 2)
+	{
+		strnum[fmt_ulong(strnum, getpid())] = 0;
+		if (!stralloc_copys(&tmp, "tcpserver: "))
+			drop_nomem();
+		safecats(flagdeny ? "deny" : "ok");
+		cats(" ");
+		safecats(strnum);
+		cats(" ");
+		if (localhost)
+			safecats(localhost);
+		cats("[");
+		safecats(localipstr);
+		cats("]");
+		safecats(localportstr);
+		cats(" ");
+		if (remotehost)
+			safecats(remotehost);
+		cats("[");
+		safecats(remoteipstr);
+		cats("]");
+		if (flagremoteinfo)
+			safecats(tcpremoteinfo.s);
+		cats(":");
+		safecats(remoteportstr);
+		cats("\n");
+		buffer_putflush(buffer_2, tmp.s, tmp.len);
+	}
+	if (flagdeny)
+		_exit(100);
+}
 
-/* ---------------------------- parent */
+/*
+ * ---------------------------- parent 
+ */
 
 #define FATAL "tcpserver: fatal: "
 
-void usage(void)
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+static char    *
+my_strchr(char *str, char ch)
+{
+	int             i;
+
+	i = str_chr(str, ch);
+	if (!str[i])
+		return ((char *) 0);
+	return (str + i);
+}
+
+int
+matchinet(char *ip, char *token)
+{
+	char            field1[8];
+	char            field2[8];
+	unsigned long   lnum, hnum, tmp;
+	int             idx1, idx2, match;
+	char           *ptr, *ptr1, *ptr2, *cptr;
+	struct in_addr  inp;
+	struct hostent *hp;
+
+	/*- Exact match / match all */
+	if (!str_diff(token, ip))
+		return (1);
+	/*
+	 * If our token is a valid internet address then we don't need to
+	 * check any further
+	 */
+	if (inet_aton(token, &inp))
+		return (0);
+	else
+	for (match = idx1 = 0, ptr1 = token, ptr2 = ip; idx1 < 4 && match == idx1; idx1++)
+	{
+		/*- IP Address in control file */
+		for (cptr = field1; *ptr1 && *ptr1 != '.'; *cptr++ = *ptr1++);
+		*cptr = 0;
+		ptr1++;
+
+		/*
+		 * IP Address of client 
+		 */
+		for (cptr = field2; *ptr2 && *ptr2 != '.'; *cptr++ = *ptr2++);
+		*cptr = 0;
+		ptr2++;
+		/*-
+		 * Network address wildcard match (i.e. "192.86.28.*")
+		 */
+		if (!str_diff(field1, "*"))
+		{
+			match++;
+			continue;
+		}
+		/*
+		 * Network address wildcard match (i.e.
+		 * "192.86.2?.12?")
+		 */
+		for (; (ptr = my_strchr(field1, '?'));)
+		{
+			lnum = ptr - field1;
+			*ptr = field2[lnum];
+		}
+		if (!str_diff(field1, field2))
+		{
+			match++;
+			continue;
+		}
+		/*
+		 * Range match (i.e. "190-193.86.22.11") 
+		 */
+		if ((ptr = my_strchr(field1, '-')))
+		{
+			*ptr = 0;
+			ptr++;
+			scan_ulong(field1, &lnum);
+			if (!*ptr)
+				hnum = 256;
+			else
+				scan_ulong(ptr, &hnum);
+			scan_ulong(field2, &tmp);
+			for (idx2 = lnum; idx2 <= hnum; idx2++)
+			{
+				if (idx2 == tmp)
+				{
+					match++;
+					break;
+				}
+			}
+			if (idx2 <= hnum && idx2 == tmp)
+				continue;
+		}
+	} /*- for (match = idx1 = 0, ptr1 = token, ptr2 = ip; idx1 < 4 && match == idx1; idx1++) */
+	if (match == 4)
+		return (1);
+	/*
+	 * If our token is a host name then translate it and compare internet
+	 * addresses
+	 */
+	if (!(hp = gethostbyname(token)))
+		return (0);
+	if (!str_diff(ip, inet_ntoa(*((struct in_addr *) hp->h_addr_list[0]))))
+		return (1);
+	return (0);
+}
+#if defined(MYSQL_CONFIG) && defined(HAS_MYSQL)
+#include <mysql.h>
+#include <mysqld_error.h>
+
+struct stralloc dbserver = {0};
+struct stralloc dbuser = {0};
+struct stralloc dbpass = {0};
+struct stralloc dbname = {0};
+struct stralloc dbtable = {0};
+MYSQL          *conn = (MYSQL *) 0;
+
+void
+create_table(MYSQL *conn)
+{
+	static stralloc sql = { 0 };
+
+	if (!stralloc_copys(&sql, "create table "))
+		drop_nomem();
+	if (!stralloc_cats(&sql, dbtable.s))
+		drop_nomem();
+	if (!stralloc_cats(&sql, " (port int(5) NOT NULL, timestamp timestamp not null, \
+				iprule char(16) not null, \
+				decision char(1) not null, env varchar(255), primary key (port))"))
+		drop_nomem();
+	if (!stralloc_0(&sql))
+		drop_nomem();
+	if (mysql_query(conn, sql.s))
+	{
+		sql.len--;
+		if (!stralloc_cats(&sql, ": "))
+		{
+			mysql_close(conn);
+			drop_nomem();
+		}
+		if (!stralloc_cats(&sql, (char *) mysql_error(conn)))
+		{
+			mysql_close(conn);
+			drop_nomem();
+		}
+		mysql_close(conn);
+		if (!stralloc_0(&sql))
+			drop_nomem();
+		strerr_die2x(111, DROP, sql.s);
+	}
+	return;
+}
+
+void
+connect_db(char *dbfile)
+{
+	char           *x = 0, *mysql_timeout;
+	int             fd, i = 0;
+	unsigned int    next, xlen;
+	struct stat     st;
+	static MYSQL    mysql;
+
+	if (!(mysql_timeout = env_get("MYSQL_TIMEOUT")))
+		mysql_timeout = "30";
+	if ((fd = open_read(dbfile)) == -1)
+		strerr_die4sys(111, FATAL, "unable to read ", dbfile, ": ");
+	if (fstat(fd, &st) == -1)
+	{
+		close(fd);
+		strerr_die4sys(111, FATAL, "unable to fstat ", dbfile, ": ");
+	}
+	if (st.st_size <= 0xffffffff)
+	{
+		x = mmap(0, st.st_size, PROT_READ, MAP_SHARED, fd, 0);
+		xlen = st.st_size;
+		while ((next = byte_chr(x, xlen, ':')) < xlen)
+		{
+			switch (i)
+			{
+			case 0:
+				if (!stralloc_copyb(&dbserver, x, next))
+				{
+					munmap(x, st.st_size);
+					close(fd);
+					drop_nomem();
+				}
+				if (!stralloc_0(&dbserver))
+				{
+					munmap(x, st.st_size);
+					close(fd);
+					drop_nomem();
+				}
+				break;
+			case 1:
+				if (!stralloc_copyb(&dbuser, x, next))
+				{
+					munmap(x, st.st_size);
+					close(fd);
+					drop_nomem();
+				}
+				if (!stralloc_0(&dbuser))
+				{
+					munmap(x, st.st_size);
+					close(fd);
+					drop_nomem();
+				}
+				break;
+			case 2:
+				if (!stralloc_copyb(&dbpass, x, next))
+				{
+					munmap(x, st.st_size);
+					close(fd);
+					drop_nomem();
+				}
+				if (!stralloc_0(&dbpass))
+				{
+					munmap(x, st.st_size);
+					close(fd);
+					drop_nomem();
+				}
+				break;
+			case 3:
+				if (!stralloc_copyb(&dbname, x, next))
+				{
+					munmap(x, st.st_size);
+					close(fd);
+					drop_nomem();
+				}
+				if (!stralloc_0(&dbname))
+				{
+					munmap(x, st.st_size);
+					close(fd);
+					drop_nomem();
+				}
+				break;
+			case 4:
+				if (!stralloc_copyb(&dbtable, x, next))
+				{
+					munmap(x, st.st_size);
+					close(fd);
+					drop_nomem();
+				}
+				if (!stralloc_0(&dbtable))
+				{
+					munmap(x, st.st_size);
+					close(fd);
+					drop_nomem();
+				}
+				break;
+			}
+			i++;
+			++next;
+			x += next;
+			xlen -= next;
+		}
+		if (i < 4)
+		{
+			munmap(x, st.st_size);
+			close(fd);
+			strerr_die2x(111, FATAL, "Invalid db.conf");
+		}
+		if (i == 4)
+		{
+			if (!*x || *x == '\n')
+			{
+				munmap(x, st.st_size);
+				close(fd);
+				strerr_die2x(111, FATAL, "Invalid db.conf");
+			}
+			if (!stralloc_copys(&dbtable, x))
+			{
+				munmap(x, st.st_size);
+				close(fd);
+				drop_nomem();
+			}
+			if (*(dbtable.s + dbtable.len -1) == '\n')
+				*(dbtable.s + dbtable.len -1) = 0;
+			else
+			if (!stralloc_0(&dbtable))
+			{
+				munmap(x, st.st_size);
+				close(fd);
+				drop_nomem();
+			}
+		}
+	} else
+	{
+		close(fd);
+		strerr_die2x(111, FATAL, "File too large");
+	}
+	munmap(x, st.st_size);
+	close(fd);
+	mysql_init(&mysql);
+	mysql_options(&mysql, MYSQL_OPT_CONNECT_TIMEOUT, mysql_timeout);
+	if (!mysql_real_connect(&mysql, dbserver.s, dbuser.s, dbpass.s, dbname.s, 0, NULL, 0))
+		strerr_die3x(111, FATAL, "Unable to connect to MySQL Server: ", (char *) mysql_error(&mysql));
+	conn = &mysql;
+	return;
+}
+
+void
+check_db(MYSQL *conn)
+{
+
+	MYSQL_RES      *res;
+	MYSQL_ROW       row;
+	static stralloc sql = { 0 };
+
+	if (!stralloc_copys(&sql, "select decision, iprule, env from "))
+	{
+		mysql_close(conn);
+		drop_nomem();
+	}
+	if (!stralloc_cats(&sql, dbtable.s))
+	{
+		mysql_close(conn);
+		drop_nomem();
+	}
+	if (!stralloc_cats(&sql, " where port = "))
+	{
+		mysql_close(conn);
+		drop_nomem();
+	}
+	if (!stralloc_cats(&sql, localportstr))
+	{
+		mysql_close(conn);
+		drop_nomem();
+	}
+	if (!stralloc_0(&sql))
+	{
+		mysql_close(conn);
+		drop_nomem();
+	}
+	if (mysql_query(conn, sql.s))
+	{
+		if (mysql_errno(conn) == ER_NO_SUCH_TABLE)
+		{
+			create_table(conn);
+			if (!mysql_query(conn, sql.s))
+				goto done;
+		}
+		sql.len--;
+		if (!stralloc_cats(&sql, ": "))
+		{
+			mysql_close(conn);
+			drop_nomem();
+		}
+		if (!stralloc_cats(&sql, (char *) mysql_error(conn)))
+		{
+			mysql_close(conn);
+			drop_nomem();
+		}
+		mysql_close(conn);
+		if (!stralloc_0(&sql))
+			drop_nomem();
+		strerr_die2x(111, DROP, sql.s);
+	}
+done:
+	if (!(res = mysql_store_result(conn)))
+	{
+		sql.len--;
+		if (!stralloc_cats(&sql, "mysql_store_result: "))
+		{
+			mysql_close(conn);
+			drop_nomem();
+		}
+		if (!stralloc_cats(&sql, (char *) mysql_error(conn)))
+		{
+			mysql_close(conn);
+			drop_nomem();
+		}
+		mysql_close(conn);
+		if (!stralloc_0(&sql))
+			drop_nomem();
+		strerr_die2x(111, DROP, sql.s);
+	}
+	for (;(row = mysql_fetch_row(res));)
+	{
+		if (!str_diff(row[1], "*") || matchinet(remoteipstr, row[1]))
+		{
+			if (*row[0] == 'D')
+			{
+				strerr_warn4("tcpserver: MySQL: Port ", localportstr, ": IPrule ", row[1], 0);
+				flagdeny = 1;
+				mysql_free_result(res);
+				return;
+			}
+			if (row[2])
+			{
+				char           *ptr1, *ptr2, *ptr3, *ptr4;
+				unsigned int    split;
+
+				for (ptr2 = ptr1 = row[2];*ptr1;ptr1++)
+				{
+					if (*ptr1 == ',')
+					{
+						/*
+			 			* Allow ',' in environment variable if escaped
+			 			* by '\' character
+			 			*/
+						if (ptr1 != row[2] && *(ptr1 - 1) == '\\')
+						{
+							/*- for (ptr3 = ptr1 - 1; *ptr3; *ptr3++ = *(ptr3 + 1)); -*/
+							for (ptr3 = ptr1 - 1, ptr4 = ptr1; *ptr3; *ptr3++ = *ptr4++);
+							continue;
+						}
+						*ptr1 = 0;
+						split = str_chr(ptr2, '=');
+						if (ptr2[split] == '=')
+						{
+							ptr2[split] = 0;
+							env(ptr2, ptr2 + split + 1);
+						}
+						ptr2 = ptr1 + 1;
+					}
+				} /*- for */
+				split = str_chr(ptr2, '=');
+				if (ptr2[split] == '=')
+				{
+					ptr2[split] = 0;
+					env(ptr2, ptr2 + split + 1);
+				}
+			} /*- if (row[2]) */
+		}
+	}
+	mysql_free_result(res);
+}
+#endif /*- #ifdef MYSQL_CONFIG */
+
+void
+usage(void)
+{
+	strerr_warn1(
+"tcpserver: usage: tcpserver\n"
+#ifdef IPV6
+"[ -461UXpPhHrRoOdDqQv ]\n"
+#else
+"[ -1UXpPhHrRoOdDqQv ]\n"
+#endif
+"[ -c Maxlimit | -a concurrency_file]\n"
+"[ -C PerHostlimit ]\n"
+"[ -x rules.cdb ]\n"
+"[ -B banner ]\n"
+"[ -g gid ]\n"
+"[ -u uid ]\n"
+"[ -b backlog ]\n"
+"[ -l localname ]\n"
+"[ -t timeout ]\n"
+#if defined(MYSQL_CONFIG) && defined(HAS_MYSQL)
+"[ -m db.conf ]\n"
+#endif
+#ifdef TLS
+"[ -s ]\n"
+"[ -n certfile ]\n"
+#endif
+#ifdef IPV6
+"[ -I interface ]\n"
+#endif
+"host port program", 0);
+	_exit(100);
+}
+
+void
+printstatus(void)
+{
+	if (verbosity < 2)
+		return;
+	strnum[fmt_ulong(strnum, numchildren)] = 0;
+	strnum2[fmt_ulong(strnum2, limit)] = 0;
+	strerr_warn4("tcpserver: status: ", strnum, "/", strnum2, 0);
+}
+
+void
+init_ip()
+{
+	int             i;
+	IPTABLE       **iptable;
+
+	if (!IpTable)
+	{
+		if (!(IpTable = (IPTABLE **) alloc(limit * sizeof(IPTABLE *))))
+			drop_nomem();
+		alloc_count = limit;
+		for (i = 0, iptable = IpTable;i < limit;i++, iptable++)
+		{
+			if (!(*iptable = (IPTABLE *) alloc(sizeof(IPTABLE))))
+			{
+				drop_nomem();
+				return;
+			}
+			(*iptable)->ipaddr[0] = 0;
+			(*iptable)->pid = -1;
+		}
+	}
+	return;
+}
+
+void
+add_ip(pid)
+	pid_t           pid;
+{
+	int             i;
+#ifdef IPV6
+	int             fakev4 = 0;
+#endif
+	IPTABLE       **iptable;
+
+	if (!IpTable)
+		init_ip();
+#ifdef IPV6
+	if (!forcev6 && ip6_isv4mapped(remoteip))
+		fakev4 = 1;
+	if (fakev4)
+		remoteipstr[ip4_fmt(remoteipstr, remoteip + 12)] = 0;
+	else
+		remoteipstr[ip6_fmt(remoteipstr, remoteip)] = 0;
+#else
+	remoteipstr[ip4_fmt(remoteipstr, remoteip)] = 0;
+#endif
+	for (i = 0, iptable = IpTable; i < limit; iptable++, i++)
+	{
+		if ((*iptable)->pid == -1)
+		{
+			(*iptable)->pid = pid;
+#ifdef IPV6
+			byte_copy((*iptable)->ipaddr, 16, remoteip);
+#else
+			byte_copy((*iptable)->ipaddr, 16, remoteipstr);
+			(*iptable)->ipaddr[15] = 0;
+#endif
+			break;
+		}
+	}
+	if (i == limit)
+		strerr_die2sys(111, DROP, "no ip slots: ");
+}
+
+unsigned long
+check_ip()
+{
+	int             i, count;
+	IPTABLE       **iptable;
+
+	if (!(numchildren && numchildren <= limit))
+		return (limit);
+	if (!IpTable)
+		init_ip();
+#ifndef IPV6
+	remoteipstr[ip4_fmt(remoteipstr, remoteip)] = 0;
+#endif
+	for (count = i = 0, iptable = IpTable; i < limit; iptable++, i++)
+	{
+		if ((*iptable)->pid == -1)
+			continue;
+#ifdef IPV6
+		if (byte_equal(remoteip, 16, (*iptable)->ipaddr))
+#else
+		if (!str_diffn((*iptable)->ipaddr, remoteipstr, 16))
+#endif
+			count++;
+	}
+	return (count);
+}
+
+void
+remove_ip(pid)
+	pid_t           pid;
+{
+	int             i;
+	IPTABLE       **iptable;
+
+	if (!IpTable)
+		init_ip();
+	for (i = 0, iptable = IpTable; i < limit; iptable++, i++)
+	{
+		if ((*iptable)->pid == pid)
+		{
+			(*iptable)->pid = -1;
+			break;
+		}
+	}
+}
+
+void
+print_ip()
+{
+	int             i;
+#ifdef IPV6
+	int             fakev4 = 0;
+#endif
+	IPTABLE       **iptable;
+	char            slotstr[FMT_ULONG], pid_str[FMT_ULONG];
+
+	if (verbosity < 2)
+		return;
+	if (!IpTable)
+		init_ip();
+	for (i = 0, iptable = IpTable; i < limit; iptable++, i++)
+	{
+		if ((*iptable)->pid != -1)
+		{
+			slotstr[fmt_ulong(slotstr, i)] = 0;
+			pid_str[fmt_ulong(pid_str, (*iptable)->pid)] = 0;
+#ifdef IPV6
+			if (!forcev6 && ip6_isv4mapped((*iptable)->ipaddr))
+				fakev4 = 1;
+			if (fakev4)
+				remoteipstr[ip4_fmt(remoteipstr, (*iptable)->ipaddr + 12)] = 0;
+			else
+				remoteipstr[ip6_fmt(remoteipstr, (*iptable)->ipaddr)] = 0;
+#else
+			remoteipstr[ip4_fmt(remoteipstr, (*iptable)->ipaddr)] = 0;
+#endif
+			strerr_warn6("tcpserver: ", slotstr, ": IP ", remoteipstr, ": PID ", pid_str, 0);
+		}
+	}
+	return;
+}
+
+void
+sigterm()
+{
+	_exit(0);
+}
+
+void
+sighangup()
+{
+	int             i, tmpLimit;
+	IPTABLE       **iptable1, **iptable2, **tmpTable;
+
+	if (!IpTable)
+		init_ip();
+	tmpLimit = limit;
+	if (control_readint(&tmpLimit, limitFile.s) == -1)
+		strerr_die4sys(111, FATAL, "unable to read ", limitFile.s, ": ");
+	if (tmpLimit > alloc_count)
+	{
+		if (!(tmpTable = (IPTABLE **) alloc(tmpLimit * sizeof(IPTABLE *))))
+			drop_nomem();
+		for (i = 0, iptable1 = tmpTable, iptable2 = IpTable;i < tmpLimit;i++, iptable1++)
+		{
+			if (i < alloc_count)
+			{
+				*iptable1 = *iptable2++;
+				continue;
+			}
+			if (!(*iptable1 = (IPTABLE *) alloc(sizeof(IPTABLE))))
+			{
+				drop_nomem();
+				return;
+			}
+			(*iptable1)->ipaddr[0] = 0;
+			(*iptable1)->pid = -1;
+		}
+		alloc_free(IpTable);
+		IpTable = tmpTable;
+		alloc_count = tmpLimit;
+	}
+	limit = tmpLimit;
+	strnum[fmt_ulong(strnum, numchildren)] = 0;
+	strnum2[fmt_ulong(strnum2, limit)] = 0;
+	strerr_warn4("tcpserver: sighup: ", strnum, "/", strnum2, 0);
+}
+
+void
+sigchld()
+{
+	int             wstat;
+	int             pid;
+
+	while ((pid = wait_nohang(&wstat)) > 0)
+	{
+		if (verbosity >= 2)
+		{
+			strnum[fmt_ulong(strnum, pid)] = 0;
+			strnum2[fmt_ulong(strnum2, wstat)] = 0;
+			strerr_warn4("tcpserver: end ", strnum, " status ", strnum2, 0);
+		}
+		if (numchildren)
+		{
+			--numchildren;
+			remove_ip(pid);
+		}
+		printstatus();
+	}
+}
+
+int
+main(int argc, char **argv)
+{
+	char           *x, *hostname;
+#if defined(MYSQL_CONFIG) && defined(HAS_MYSQL)
+	char           *dbfile = 0;
+#endif
+	struct servent *se;
+	unsigned long   port, ipcount = -1;
+	int             s, t, pid, opt, tmpLimit;
+#ifdef IPV6
+	int             fakev4 = 0;
+#endif
+#ifdef TLS
+	BIO            *sbio;
+	SSL            *ssl;
+	SSL_CTX        *ctx;
+	char           *controldir;
+	int             pi2c[2], pi4c[2];
+#endif
+	struct stralloc options = {0};
+  
+	if ((x = env_get("MAXPERIP"))) /*- '-C' option overrides this */
+		scan_ulong(x, &PerHostLimit);
+	if (!stralloc_copys(&options, "dDvqQhHrR1UXx:m:t:u:g:l:b:B:c:C:pPoO"))
+		strerr_die2x(111, FATAL, "out of memory");
+#ifdef IPV6
+	if (!stralloc_cats(&options, "46I:"))
+		strerr_die2x(111, FATAL, "out of memory");
+#endif
+#ifdef TLS
+	if (!stralloc_cats(&options, "sn:"))
+		strerr_die2x(111, FATAL, "out of memory");
+#endif
+	if (!stralloc_0(&options))
+		strerr_die2x(111, FATAL, "out of memory");
+#ifdef TLS
+	ctx = NULL;
+	if (!(controldir = env_get("CONTROLDIR")))
+		controldir = "control";
+	if (!stralloc_copys(&certfile, auto_home))
+		strerr_die2x(111, FATAL, "out of memory");
+	else
+	if (!stralloc_cats(&certfile, "/"))
+		strerr_die2x(111, FATAL, "out of memory");
+	else
+	if (!stralloc_cats(&certfile, controldir))
+		strerr_die2x(111, FATAL, "out of memory");
+	else
+	if (!stralloc_cats(&certfile, "/servercert.pem"))
+		strerr_die2x(111, FATAL, "out of memory");
+	else
+	if (!stralloc_0(&certfile) )
+		strerr_die2x(111, FATAL, "out of memory");
+#endif
+	while ((opt = getopt(argc, argv, options.s)) != opteof)
+		switch (opt)
+		{
+		case 'c':
+			for (x = optarg;*x;x++)
+			{
+				if (*x == '/' || *x == '.' || *x < '0' || *x > '9')
+					break;
+			}
+			if (*x)
+			{
+				if (!stralloc_copys(&limitFile, optarg))
+					strerr_die2x(111, FATAL, "out of memory");
+				if (!stralloc_0(&limitFile))
+					strerr_die2x(111, FATAL, "out of memory");
+				tmpLimit = limit;
+				if (control_readint(&tmpLimit, limitFile.s) == -1)
+					strerr_die4sys(111, FATAL, "unable to read ", limitFile.s, ": ");
+				limit = tmpLimit;
+			} else
+				scan_ulong(optarg, &limit);
+			break;
+		case 'C':
+			scan_ulong(optarg, &PerHostLimit);
+			break;
+		case 'b':
+			scan_ulong(optarg, &backlog);
+			break;
+		case 'X':
+			flagallownorules = 1;
+			break;
+		case 'x':
+			fnrules = optarg;
+			break;
+#if defined(MYSQL_CONFIG) && defined(HAS_MYSQL)
+		case 'm':
+			dbfile = optarg;
+#endif
+			break;
+		case 'B':
+			banner = optarg;
+			break;
+		case 'd':
+			flagdelay = 1;
+			break;
+		case 'D':
+			flagdelay = 0;
+			break;
+		case 'v':
+			verbosity = 2;
+			break;
+		case 'q':
+			verbosity = 0;
+			break;
+		case 'Q':
+			verbosity = 1;
+			break;
+		case 'P':
+			flagparanoid = 0;
+			break;
+		case 'p':
+			flagparanoid = 1;
+			break;
+		case 'O':
+			flagkillopts = 1;
+			break;
+		case 'o':
+			flagkillopts = 0;
+			break;
+		case 'H':
+			flagremotehost = 0;
+			break;
+		case 'h':
+			flagremotehost = 1;
+			break;
+		case 'R':
+			flagremoteinfo = 0;
+			break;
+		case 'r':
+			flagremoteinfo = 1;
+			break;
+		case 't':
+			scan_ulong(optarg, &timeout);
+			break;
+		case 'U':
+			x = env_get("UID");
+			if (x)
+				scan_ulong(x, &uid);
+			x = env_get("GID");
+			if (x)
+				scan_ulong(x, &gid);
+			break;
+		case 'u':
+			scan_ulong(optarg, &uid);
+			break;
+		case 'g':
+			scan_ulong(optarg, &gid);
+			break;
+		case '1':
+			flag1 = 1;
+			break;
+		case 'l':
+			localhost = optarg;
+			break;
+		case 's':
+			flagssl = 1;
+			break;
+#ifdef TLS
+		case 'n':
+			flagssl = 1;
+			if (!stralloc_copys(&certfile, optarg) || !stralloc_0(&certfile))
+				strerr_die2x(111,FATAL,"out of memory");
+			break;
+#endif
+#ifdef IPV6
+		case '4':
+			noipv6 = 1;
+			break;
+		case '6':
+			forcev6 = 1;
+			break;
+		case 'I':
+			netif = socket_getifidx(optarg);
+			break;
+#endif
+		default:
+			usage();
+		}
+	argc -= optind;
+	argv += optind;
+	if (!verbosity)
+		buffer_2->fd = -1;
+	if (!(hostname = *argv++))
+		usage();
+	if (str_equal(hostname, ""))
+		hostname = "0";
+	if (!(x = *argv++))
+		usage();
+	if (!x[scan_ulong(x, &port)])
+		localport = port;
+	else
+	{
+		if (!(se = getservbyname(x, "tcp")))
+			strerr_die3x(111, FATAL, "unable to figure out port number for ", x);
+#ifdef IPV6
+		uint16_unpack_big((char*) &se->s_port, &localport);
+#else
+		localport = ntohs(se->s_port);
+#endif
+	}
+	if (!*argv)
+		usage();
+#if defined(MYSQL_CONFIG) && defined(HAS_MYSQL)
+	if (dbfile)
+		connect_db(dbfile);
+#endif
+	sig_block(sig_child);
+	sig_catch(sig_child, sigchld);
+	sig_catch(sig_term, sigterm);
+	sig_catch(sig_hangup, sighangup);
+	sig_ignore(sig_pipe);
+	if (str_equal(hostname, "0"))
+		byte_zero(localip, sizeof(localip));
+	else
+	{
+		if (!stralloc_copys(&tmp, hostname))
+			strerr_die2x(111, FATAL, "out of memory");
+#ifdef IPV6
+		if (dns_ip6_qualify(&addresses, &fqdn, &tmp) == -1)
+#else
+		if (dns_ip4_qualify(&addresses, &fqdn, &tmp) == -1)
+#endif
+			strerr_die4sys(111, FATAL, "temporarily unable to figure out IP address for ", hostname, ": ");
+#ifdef IPV6
+		if (addresses.len < 16)
+#else
+		if (addresses.len < 4)
+#endif
+			strerr_die3x(111, FATAL, "no IP address for ", hostname);
+#ifdef IPV6
+		byte_copy(localip, 16, addresses.s);
+		if (ip6_isv4mapped(localip))
+			noipv6 = 1;
+#else
+		byte_copy(localip, 4, addresses.s);
+#endif
+	}
+#ifdef TLS
+	if (flagssl == 1)
+	{
+    	/* setup SSL context (load key and cert into ctx) */
+		SSL_library_init();
+		if (!(ctx = SSL_CTX_new(SSLv23_server_method())))
+			strerr_die2x(111, FATAL, "unable to create SSL context");
+		/* set prefered ciphers */
+		if (env_get("SSL_CIPHER") && !SSL_CTX_set_cipher_list(ctx, env_get("SSL_CIPHER")))
+			strerr_die2x(111,FATAL,"unable to set cipher list");
+		if (SSL_CTX_use_RSAPrivateKey_file(ctx, certfile.s, SSL_FILETYPE_PEM) != 1)
+			strerr_die2x(111, FATAL, "unable to load RSA private key");
+		if (SSL_CTX_use_certificate_file(ctx, certfile.s, SSL_FILETYPE_PEM) != 1)
+			strerr_die2x(111, FATAL, "unable to load certificate");
+	}
+#endif
+#ifdef IPV6
+	if ((s = socket_tcp6()) == -1)
+#else
+	if ((s = socket_tcp()) == -1)
+#endif
+		strerr_die2sys(111, FATAL, "unable to create socket: ");
+#ifdef IPV6
+	if (socket_bind6_reuse(s, localip, localport, netif) == -1)
+#else
+	if (socket_bind4_reuse(s, localip, localport) == -1)
+#endif
+		strerr_die2sys(111, FATAL, "unable to bind: ");
+#ifdef IPV6
+	if (socket_local6(s, localip, &localport, &netif) == -1)
+#else
+	if (socket_local4(s, localip, &localport) == -1)
+#endif
+		strerr_die2sys(111, FATAL, "unable to get local address: ");
+	if (socket_listen(s, backlog) == -1)
+		strerr_die2sys(111, FATAL, "unable to listen: ");
+	ndelay_off(s);
+	if (gid && prot_gid(gid) == -1)
+		strerr_die2sys(111, FATAL, "unable to set gid: ");
+	if (uid && prot_uid(uid) == -1)
+		strerr_die2sys(111, FATAL, "unable to set uid: ");
+	localportstr[fmt_ulong(localportstr, localport)] = 0;
+	if (flag1)
+	{
+		buffer_init(&b, write, 1, bspace, sizeof bspace);
+		buffer_puts(&b, localportstr);
+		buffer_puts(&b, "\n");
+		buffer_flush(&b);
+	}
+	close(0);
+	close(1);
+	printstatus();
+	for (;;)
+	{
+		while (numchildren >= limit)
+			sig_pause();
+		sig_unblock(sig_child);
+#ifdef IPV6
+		t = socket_accept6(s, remoteip, &remoteport, &netif);
+#else
+		t = socket_accept4(s, remoteip, &remoteport);
+#endif
+		sig_block(sig_child);
+		if (t == -1)
+			continue;
+		++numchildren;
+		printstatus();
+#ifdef IPV6
+		if (!forcev6 && ip6_isv4mapped(remoteip))
+			fakev4 = 1;
+		if (fakev4)
+			remoteipstr[ip4_fmt(remoteipstr, remoteip + 12)] = 0;
+		else
+			remoteipstr[ip6_fmt(remoteipstr, remoteip)] = 0;
+#else
+		remoteipstr[ip4_fmt(remoteipstr, remoteip)] = 0;
+#endif
+		if (PerHostLimit < limit && (ipcount = check_ip()) >= PerHostLimit)
+		{
+			strnum2[fmt_ulong(strnum2, ipcount)] = 0;
+			strerr_warn4("tcpserver: end ", remoteipstr, " perIPlimit ", strnum2, 0);
+			--numchildren;
+			errno = error_acces;
+			close(t);
+			continue;
+		}
+		switch (pid = fork())
+		{
+		case 0:
+			close(s);
+#if defined(MYSQL_CONFIG) && defined(HAS_MYSQL)
+			if (conn)
+				check_db(conn);
+#endif
+			doit(t); /*- MAXPERIP can only be checked after this */
+			if ((fd_move(0, t) == -1) || (fd_copy(1, 0) == -1))
+				strerr_die2sys(111, DROP, "unable to set up descriptors: ");
+			sig_uncatch(sig_child);
+			sig_unblock(sig_child);
+			sig_uncatch(sig_term);
+			sig_uncatch(sig_pipe);
+			if (maxperip)
+			{
+				if (ipcount == -1)
+					ipcount = check_ip();
+				if (ipcount >= maxperip)
+				{
+					strnum2[fmt_ulong(strnum2, ipcount)] = 0;
+					close(t);
+					errno = error_acces;
+					strerr_die6sys(111, DROP, "no ip slots for ", remoteipstr, ", perIPlimit ", strnum2, ", : ");
+				}
+			}
+#ifdef TLS
+			if (flagssl == 1)
+			{
+				if (pipe(pi2c) != 0)
+					strerr_die2sys(111, DROP, "unable to create pipe: ");
+				if (pipe(pi4c) != 0)
+					strerr_die2sys(111, DROP, "unable to create pipe: ");
+				switch (fork())
+				{
+				case 0:
+					close(0);
+					close(1);
+					close(pi2c[1]);
+					close(pi4c[0]);
+					if ((fd_move(0, pi2c[0]) == -1) || (fd_move(1, pi4c[1]) == -1))
+						strerr_die2sys(111, DROP, "unable to set up descriptors: ");
+					/*
+					 * signals are allready set in the parent 
+					 */
+					pathexec(argv);
+					strerr_die4sys(111, DROP, "unable to run ", *argv, ": ");
+				case -1:
+					strerr_die2sys(111, DROP, "unable to fork: ");
+				default:
+					ssl = SSL_new(ctx);
+					if (!ssl)
+						strerr_die2x(111, DROP, "unable to set up SSL session");
+					sbio = BIO_new_socket(0, BIO_NOCLOSE);
+					if (!sbio)
+						strerr_die2x(111, DROP, "unable to set up BIO socket");
+					SSL_set_bio(ssl, sbio, sbio);
+					close(pi2c[0]);
+					close(pi4c[1]);
+					translate(ssl, pi2c[1], pi4c[0], 3600);
+					_exit(0);
+				}
+			}
+#endif
+			pathexec(argv);
+			strerr_die4sys(111, DROP, "unable to run ", *argv, ": ");
+		case -1:
+			strerr_warn2(DROP, "unable to fork: ", &strerr_sys);
+			--numchildren;
+			printstatus();
+		default:
+			add_ip(pid);
+			if (verbosity >= 2)
+				print_ip();
+		}
+		close(t);
+	}
+}
+
+#ifdef TLS
+static int
+allwrite(int fd, char *buf, int len)
+{
+	int             w;
+
+	while (len)
+	{
+		if ((w = write(fd, buf, len)) == -1)
+		{
+			if (errno == error_intr)
+				continue;
+			return -1;	/*- note that some data may have been written */
+		}
+		if (w == 0);	/*- luser's fault */
+		buf += w;
+		len -= w;
+	}
+	return 0;
+}
+
+static int
+allwritessl(SSL * ssl, char *buf, int len)
+{
+	int             w;
+
+	while (len)
+	{
+		if ((w = SSL_write(ssl, buf, len)) == -1)
+		{
+			if (errno == error_intr)
+				continue;
+			return -1;	/*- note that some data may have been written */
+		}
+		if (w == 0);	/*- luser's fault */
+		buf += w;
+		len -= w;
+	}
+	return 0;
+}
+
+char            tbuf[2048];
+void
+translate(SSL * ssl, int clearout, int clearin, unsigned int iotimeout)
+{
+	struct taia     now;
+	struct taia     deadline;
+	iopause_fd      iop[2];
+	int             flagexitasap;
+	int             iopl;
+	int             sslout, sslin;
+	int             n, r;
+
+	if ((sslin = SSL_get_fd(ssl)) == -1 || (sslout = SSL_get_fd(ssl)) == -1)
+		strerr_die2x(111, DROP, "unable to set up SSL connection");
+	flagexitasap = 0;
+	if (SSL_accept(ssl) <= 0)
+		strerr_die2x(111, DROP, "unable to accept SSL connection");
+	while (!flagexitasap)
+	{
+		taia_now(&now);
+		taia_uint(&deadline, iotimeout);
+		taia_add(&deadline, &now, &deadline);
+
+		/*- fill iopause struct */
+		iopl = 2;
+		iop[0].fd = sslin;
+		iop[0].events = IOPAUSE_READ;
+		iop[1].fd = clearin;
+		iop[1].events = IOPAUSE_READ;
+
+		/*- do iopause read */
+		iopause(iop, iopl, &deadline, &now);
+		if (iop[0].revents)
+		{
+			/*- data on sslin */
+			n = SSL_read(ssl, tbuf, sizeof(tbuf));
+			if (n < 0)
+				strerr_die2sys(111, DROP, "unable to read from network: ");
+			if (n == 0)
+				flagexitasap = 1;
+			r = allwrite(clearout, tbuf, n);
+			if (r < 0)
+				strerr_die2sys(111, DROP, "unable to write to client: ");
+		}
+		if (iop[1].revents)
+		{
+			/*- data on clearin */
+			n = read(clearin, tbuf, sizeof(tbuf));
+			if (n < 0)
+				strerr_die2sys(111, DROP, "unable to read from client: ");
+			if (n == 0)
+				flagexitasap = 1;
+			r = allwritessl(ssl, tbuf, n);
+			if (r < 0)
+				strerr_die2sys(111, DROP, "unable to write to network: ");
+		}
+		if (!iop[0].revents && !iop[1].revents)
+			strerr_die2x(0, DROP, "timeout reached without input");
+	}
+}
+#endif
+
+void
+getversion_tcpserver_c()
 {
-  strerr_warn1("\
-tcpserver: usage: tcpserver \
-[ -1UXpPhHrRoOdDqQv ] \
-[ -c limit ] \
-[ -x rules.cdb ] \
-[ -B banner ] \
-[ -g gid ] \
-[ -u uid ] \
-[ -b backlog ] \
-[ -l localname ] \
-[ -t timeout ] \
-host port program",0);
-  _exit(100);
-}
-
-unsigned long limit = 40;
-unsigned long numchildren = 0;
-
-int flag1 = 0;
-unsigned long backlog = 20;
-unsigned long uid = 0;
-unsigned long gid = 0;
-
-void printstatus(void)
-{
-  if (verbosity < 2) return;
-  strnum[fmt_ulong(strnum,numchildren)] = 0;
-  strnum2[fmt_ulong(strnum2,limit)] = 0;
-  strerr_warn4("tcpserver: status: ",strnum,"/",strnum2,0);
-}
-
-void sigterm()
-{
-  _exit(0);
-}
-
-void sigchld()
-{
-  int wstat;
-  int pid;
- 
-  while ((pid = wait_nohang(&wstat)) > 0) {
-    if (verbosity >= 2) {
-      strnum[fmt_ulong(strnum,pid)] = 0;
-      strnum2[fmt_ulong(strnum2,wstat)] = 0;
-      strerr_warn4("tcpserver: end ",strnum," status ",strnum2,0);
-    }
-    if (numchildren) --numchildren; printstatus();
-  }
-}
-
-main(int argc,char **argv)
-{
-  char *hostname;
-  char *portname;
-  int opt;
-  struct servent *se;
-  char *x;
-  unsigned long u;
-  int s;
-  int t;
- 
-  while ((opt = getopt(argc,argv,"dDvqQhHrR1UXx:t:u:g:l:b:B:c:pPoO")) != opteof)
-    switch(opt) {
-      case 'b': scan_ulong(optarg,&backlog); break;
-      case 'c': scan_ulong(optarg,&limit); break;
-      case 'X': flagallownorules = 1; break;
-      case 'x': fnrules = optarg; break;
-      case 'B': banner = optarg; break;
-      case 'd': flagdelay = 1; break;
-      case 'D': flagdelay = 0; break;
-      case 'v': verbosity = 2; break;
-      case 'q': verbosity = 0; break;
-      case 'Q': verbosity = 1; break;
-      case 'P': flagparanoid = 0; break;
-      case 'p': flagparanoid = 1; break;
-      case 'O': flagkillopts = 1; break;
-      case 'o': flagkillopts = 0; break;
-      case 'H': flagremotehost = 0; break;
-      case 'h': flagremotehost = 1; break;
-      case 'R': flagremoteinfo = 0; break;
-      case 'r': flagremoteinfo = 1; break;
-      case 't': scan_ulong(optarg,&timeout); break;
-      case 'U': x = env_get("UID"); if (x) scan_ulong(x,&uid);
-		x = env_get("GID"); if (x) scan_ulong(x,&gid); break;
-      case 'u': scan_ulong(optarg,&uid); break;
-      case 'g': scan_ulong(optarg,&gid); break;
-      case '1': flag1 = 1; break;
-      case 'l': localhost = optarg; break;
-      default: usage();
-    }
-  argc -= optind;
-  argv += optind;
-
-  if (!verbosity)
-    buffer_2->fd = -1;
- 
-  hostname = *argv++;
-  if (!hostname) usage();
-  if (str_equal(hostname,"")) hostname = "0.0.0.0";
-  if (str_equal(hostname,"0")) hostname = "0.0.0.0";
-
-  x = *argv++;
-  if (!x) usage();
-  if (!x[scan_ulong(x,&u)])
-    localport = u;
-  else {
-    se = getservbyname(x,"tcp");
-    if (!se)
-      strerr_die3x(111,FATAL,"unable to figure out port number for ",x);
-    localport = ntohs(se->s_port);
-  }
-
-  if (!*argv) usage();
- 
-  sig_block(sig_child);
-  sig_catch(sig_child,sigchld);
-  sig_catch(sig_term,sigterm);
-  sig_ignore(sig_pipe);
- 
-  if (!stralloc_copys(&tmp,hostname))
-    strerr_die2x(111,FATAL,"out of memory");
-  if (dns_ip4_qualify(&addresses,&fqdn,&tmp) == -1)
-    strerr_die4sys(111,FATAL,"temporarily unable to figure out IP address for ",hostname,": ");
-  if (addresses.len < 4)
-    strerr_die3x(111,FATAL,"no IP address for ",hostname);
-  byte_copy(localip,4,addresses.s);
-
-  s = socket_tcp();
-  if (s == -1)
-    strerr_die2sys(111,FATAL,"unable to create socket: ");
-  if (socket_bind4_reuse(s,localip,localport) == -1)
-    strerr_die2sys(111,FATAL,"unable to bind: ");
-  if (socket_local4(s,localip,&localport) == -1)
-    strerr_die2sys(111,FATAL,"unable to get local address: ");
-  if (socket_listen(s,backlog) == -1)
-    strerr_die2sys(111,FATAL,"unable to listen: ");
-  ndelay_off(s);
-
-  if (gid) if (prot_gid(gid) == -1)
-    strerr_die2sys(111,FATAL,"unable to set gid: ");
-  if (uid) if (prot_uid(uid) == -1)
-    strerr_die2sys(111,FATAL,"unable to set uid: ");
-
- 
-  localportstr[fmt_ulong(localportstr,localport)] = 0;
-  if (flag1) {
-    buffer_init(&b,write,1,bspace,sizeof bspace);
-    buffer_puts(&b,localportstr);
-    buffer_puts(&b,"\n");
-    buffer_flush(&b);
-  }
- 
-  close(0);
-  close(1);
-  printstatus();
- 
-  for (;;) {
-    while (numchildren >= limit) sig_pause();
-
-    sig_unblock(sig_child);
-    t = socket_accept4(s,remoteip,&remoteport);
-    sig_block(sig_child);
-
-    if (t == -1) continue;
-    ++numchildren; printstatus();
- 
-    switch(fork()) {
-      case 0:
-        close(s);
-        doit(t);
-        if ((fd_move(0,t) == -1) || (fd_copy(1,0) == -1))
-	  strerr_die2sys(111,DROP,"unable to set up descriptors: ");
-        sig_uncatch(sig_child);
-        sig_unblock(sig_child);
-        sig_uncatch(sig_term);
-        sig_uncatch(sig_pipe);
-        pathexec(argv);
-	strerr_die4sys(111,DROP,"unable to run ",*argv,": ");
-      case -1:
-        strerr_warn2(DROP,"unable to fork: ",&strerr_sys);
-        --numchildren; printstatus();
-    }
-    close(t);
-  }
+	write(1, sccsid, 0);
 }
diff -Naur tmp/ucspi-tcp-0.88/timeoutconn.c ucspi-tcp-0.88/timeoutconn.c
--- tmp/ucspi-tcp-0.88/timeoutconn.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/timeoutconn.c	2008-07-27 18:41:46.000000000 +0530
@@ -1,34 +1,59 @@
+/*
+ * $Log: timeoutconn.c,v $
+ * Revision 1.2  2005-06-10 12:19:59+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "ndelay.h"
 #include "socket.h"
 #include "iopause.h"
 #include "error.h"
 #include "timeoutconn.h"
 
-int timeoutconn(int s,char ip[4],uint16 port,unsigned int timeout)
+int
+#ifdef IPV6
+timeoutconn6(int s, char ip[16], uint16 port, unsigned int timeout, uint32 netif)
+#else
+timeoutconn(int s, char ip[4], uint16 port, unsigned int timeout)
+#endif
 {
-  struct taia now;
-  struct taia deadline;
-  iopause_fd x;
+	struct taia     now;
+	struct taia     deadline;
+	iopause_fd      x;
 
-  if (socket_connect4(s,ip,port) == -1) {
-    if ((errno != error_wouldblock) && (errno != error_inprogress)) return -1;
-    x.fd = s;
-    x.events = IOPAUSE_WRITE;
-    taia_now(&now);
-    taia_uint(&deadline,timeout);
-    taia_add(&deadline,&now,&deadline);
-    for (;;) {
-      taia_now(&now);
-      iopause(&x,1,&deadline,&now);
-      if (x.revents) break;
-      if (taia_less(&deadline,&now)) {
-	errno = error_timeout; /* note that connect attempt is continuing */
-	return -1;
-      }
-    }
-    if (!socket_connected(s)) return -1;
-  }
+#ifdef IPV6
+	if (socket_connect6(s, ip, port, netif) == -1)
+#else
+	if (socket_connect4(s, ip, port) == -1)
+#endif
+	{
+		if ((errno != error_wouldblock) && (errno != error_inprogress))
+			return -1;
+		x.fd = s;
+		x.events = IOPAUSE_WRITE;
+		taia_now(&now);
+		taia_uint(&deadline, timeout);
+		taia_add(&deadline, &now, &deadline);
+		for (;;)
+		{
+			taia_now(&now);
+			iopause(&x, 1, &deadline, &now);
+			if (x.revents)
+				break;
+			if (taia_less(&deadline, &now))
+			{
+				errno = error_timeout;	/*- note that connect attempt is continuing */
+				return -1;
+			}
+		}
+		if (!socket_connected(s))
+			return -1;
+	}
 
-  if (ndelay_off(s) == -1) return -1;
-  return 0;
+	if (ndelay_off(s) == -1)
+		return -1;
+	return 0;
 }
diff -Naur tmp/ucspi-tcp-0.88/timeoutconn.h ucspi-tcp-0.88/timeoutconn.h
--- tmp/ucspi-tcp-0.88/timeoutconn.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/timeoutconn.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,8 +1,27 @@
+/*
+ * $Log: timeoutconn.h,v $
+ * Revision 1.3  2005-06-10 09:14:04+05:30  Cprogrammer
+ * added ipv6 support
+ *
+ * Revision 1.2  2005-05-13 23:53:58+05:30  Cprogrammer
+ * code indentationm
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef TIMEOUTCONN_H
 #define TIMEOUTCONN_H
 
 #include "uint16.h"
+#include "haveip6.h"
+#ifdef LIBC_HAS_IP6
+#include "uint32.h"
+#endif
 
-extern int timeoutconn(int,char *,uint16,unsigned int);
+int             timeoutconn(int, char *, uint16, unsigned int);
+#ifdef LIBC_HAS_IP6
+int             timeoutconn6(int, char *, uint16, unsigned int, uint32);
+#endif
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/trycpp.c ucspi-tcp-0.88/trycpp.c
--- tmp/ucspi-tcp-0.88/trycpp.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/trycpp.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,7 +1,16 @@
+/*
+ * $Log: trycpp.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+int
 main()
 {
 #ifdef NeXT
-  printf("nextstep\n"); exit(0);
+	printf("nextstep\n");
+	exit(0);
 #endif
-  printf("unknown\n"); exit(0);
+	printf("unknown\n");
+	exit(0);
 }
diff -Naur tmp/ucspi-tcp-0.88/tryip6.c ucspi-tcp-0.88/tryip6.c
--- tmp/ucspi-tcp-0.88/tryip6.c	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/tryip6.c	2005-06-10 12:00:02.000000000 +0530
@@ -0,0 +1,15 @@
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+int
+main()
+{
+#ifdef IPV6
+	struct sockaddr_in6 sa;
+	sa.sin6_family = PF_INET6;
+	return 0;
+#else
+	return 1;
+#endif
+}
diff -Naur tmp/ucspi-tcp-0.88/trylsock.c ucspi-tcp-0.88/trylsock.c
--- tmp/ucspi-tcp-0.88/trylsock.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/trylsock.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,4 +1,11 @@
+/*
+ * $Log: trylsock.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+int
 main()
 {
-  ;
+	;
 }
diff -Naur tmp/ucspi-tcp-0.88/trypoll.c ucspi-tcp-0.88/trypoll.c
--- tmp/ucspi-tcp-0.88/trypoll.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/trypoll.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,18 +1,26 @@
+/*
+ * $Log: trypoll.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <fcntl.h>
 #include <poll.h>
 
 main()
 {
-  struct pollfd x;
+	struct pollfd   x;
 
-  x.fd = open("trypoll.c",O_RDONLY);
-  if (x.fd == -1) _exit(111);
-  x.events = POLLIN;
-  if (poll(&x,1,10) == -1) _exit(1);
-  if (x.revents != POLLIN) _exit(1);
+	x.fd = open("trypoll.c", O_RDONLY);
+	if (x.fd == -1)
+		_exit(111);
+	x.events = POLLIN;
+	if (poll(&x, 1, 10) == -1)
+		_exit(1);
+	if (x.revents != POLLIN)
+		_exit(1);
 
-  /* XXX: try to detect and avoid poll() imitation libraries */
-
-  _exit(0);
+	/*- XXX: try to detect and avoid poll() imitation libraries */
+	_exit(0);
 }
diff -Naur tmp/ucspi-tcp-0.88/trysgact.c ucspi-tcp-0.88/trysgact.c
--- tmp/ucspi-tcp-0.88/trysgact.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/trysgact.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,10 +1,16 @@
+/*
+ * $Log: trysgact.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <signal.h>
 
 main()
 {
-  struct sigaction sa;
-  sa.sa_handler = 0;
-  sa.sa_flags = 0;
-  sigemptyset(&sa.sa_mask);
-  sigaction(0,&sa,(struct sigaction *) 0);
+	struct sigaction sa;
+	sa.sa_handler = 0;
+	sa.sa_flags = 0;
+	sigemptyset(&sa.sa_mask);
+	sigaction(0, &sa, (struct sigaction *) 0);
 }
diff -Naur tmp/ucspi-tcp-0.88/trysgprm.c ucspi-tcp-0.88/trysgprm.c
--- tmp/ucspi-tcp-0.88/trysgprm.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/trysgprm.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,10 +1,16 @@
+/*
+ * $Log: trysgprm.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <signal.h>
 
 main()
 {
-  sigset_t ss;
- 
-  sigemptyset(&ss);
-  sigaddset(&ss,SIGCHLD);
-  sigprocmask(SIG_SETMASK,&ss,(sigset_t *) 0);
+	sigset_t        ss;
+
+	sigemptyset(&ss);
+	sigaddset(&ss, SIGCHLD);
+	sigprocmask(SIG_SETMASK, &ss, (sigset_t *) 0);
 }
diff -Naur tmp/ucspi-tcp-0.88/tryshsgr.c ucspi-tcp-0.88/tryshsgr.c
--- tmp/ucspi-tcp-0.88/tryshsgr.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/tryshsgr.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,14 +1,27 @@
+/*
+ * $Log: tryshsgr.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+int
 main()
 {
-  short x[4];
- 
-  x[0] = x[1] = 1;
-  if (getgroups(1,x) == 0) if (setgroups(1,x) == -1) _exit(1);
- 
-  if (getgroups(1,x) == -1) _exit(1);
-  if (x[1] != 1) _exit(1);
-  x[1] = 2;
-  if (getgroups(1,x) == -1) _exit(1);
-  if (x[1] != 2) _exit(1);
-  _exit(0);
+	short           x[4];
+
+	x[0] = x[1] = 1;
+	if (getgroups(1, x) == 0)
+		if (setgroups(1, x) == -1)
+			_exit(1);
+
+	if (getgroups(1, x) == -1)
+		_exit(1);
+	if (x[1] != 1)
+		_exit(1);
+	x[1] = 2;
+	if (getgroups(1, x) == -1)
+		_exit(1);
+	if (x[1] != 2)
+		_exit(1);
+	_exit(0);
 }
diff -Naur tmp/ucspi-tcp-0.88/trysysel.c ucspi-tcp-0.88/trysysel.c
--- tmp/ucspi-tcp-0.88/trysysel.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/trysysel.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,8 +1,15 @@
+/*
+ * $Log: trysysel.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <sys/time.h>
-#include <sys/select.h> /* SVR4 silliness */
+#include <sys/select.h>			/*- SVR4 silliness */
 
-void foo()
+void
+foo()
 {
-  ;
+	;
 }
diff -Naur tmp/ucspi-tcp-0.88/tryulong32.c ucspi-tcp-0.88/tryulong32.c
--- tmp/ucspi-tcp-0.88/tryulong32.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/tryulong32.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,11 +1,47 @@
+/*
+ * $Log: tryulong32.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+int
 main()
 {
-  unsigned long u;
-  u = 1;
-  u += u; u += u; u += u; u += u; u += u; u += u; u += u; u += u;
-  u += u; u += u; u += u; u += u; u += u; u += u; u += u; u += u;
-  u += u; u += u; u += u; u += u; u += u; u += u; u += u; u += u;
-  u += u; u += u; u += u; u += u; u += u; u += u; u += u; u += u;
-  if (!u) _exit(0);
-  _exit(1);
+	unsigned long   u;
+	u = 1;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	if (!u)
+		_exit(0);
+	_exit(1);
 }
diff -Naur tmp/ucspi-tcp-0.88/tryulong64.c ucspi-tcp-0.88/tryulong64.c
--- tmp/ucspi-tcp-0.88/tryulong64.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/tryulong64.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,11 +1,47 @@
+/*
+ * $Log: tryulong64.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
+int
 main()
 {
-  unsigned long u;
-  u = 1;
-  u += u; u += u; u += u; u += u; u += u; u += u; u += u; u += u;
-  u += u; u += u; u += u; u += u; u += u; u += u; u += u; u += u;
-  u += u; u += u; u += u; u += u; u += u; u += u; u += u; u += u;
-  u += u; u += u; u += u; u += u; u += u; u += u; u += u; u += u;
-  if (!u) _exit(1);
-  _exit(0);
+	unsigned long   u;
+	u = 1;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	u += u;
+	if (!u)
+		_exit(1);
+	_exit(0);
 }
diff -Naur tmp/ucspi-tcp-0.88/tryvfork.c ucspi-tcp-0.88/tryvfork.c
--- tmp/ucspi-tcp-0.88/tryvfork.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/tryvfork.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,4 +0,0 @@
-main()
-{
-  vfork();
-}
diff -Naur tmp/ucspi-tcp-0.88/trywaitp.c ucspi-tcp-0.88/trywaitp.c
--- tmp/ucspi-tcp-0.88/trywaitp.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/trywaitp.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,7 +1,14 @@
+/*
+ * $Log: trywaitp.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <sys/wait.h>
 
+void
 main()
 {
-  waitpid(0,0,0);
+	waitpid(0, 0, 0);
 }
diff -Naur tmp/ucspi-tcp-0.88/ucspi-tcp-0.88.spec ucspi-tcp-0.88/ucspi-tcp-0.88.spec
--- tmp/ucspi-tcp-0.88/ucspi-tcp-0.88.spec	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/ucspi-tcp-0.88.spec	2008-06-12 15:09:32.000000000 +0530
@@ -0,0 +1,49 @@
+%define _topdir /hom/local/src/indimail/redhat
+%define		prefix	/var
+Summary: ucspi-tcp
+Name: ucspi-tcp
+Version: 0.88
+Release: 1
+URL: http://mail.indi.com
+Source0: %{name}-%{version}.tar.gz
+Copyright: Artistic License
+Group: System Applications
+#Buildrequires:	indimail
+BuildRoot: %{_tmppath}/%{name}-root
+AutoReqProv: No
+Prereq:		/bin/sh
+
+%description
+ucspi-tcp provides easy-to-use command line tools for building TCP client-server applications.
+
+It replaces several programs
+inetd, a root-only TCP server supplied by all UNIX vendors
+xinetd, a replacement for inetd
+the mconnect client supplied as part of SunOS
+the socket program
+faucet and hose, part of netpipes package
+the netcat program, which also supports UDP
+
+%prep
+%setup -q
+%build
+mkdir -p $RPM_BUILD_ROOT%{prefix}/qmail
+home_path=$RPM_BUILD_ROOT%{prefix}/qmail
+ucspitcp_home=`head -1 conf-home`
+if [ ! " $ucspitcp_home" = " $home_path" ] ; then
+	(
+		echo $home_path
+		tail +2 conf-home
+	) > conf.home.$$
+	mv conf-home conf-home.orig
+	mv conf.home.$$ conf-home
+fi
+make
+%install
+make setup
+if [ -f conf-home.orig ] ; then
+	mv conf-home.orig conf-home
+fi
+%files
+%defattr(-,root,root)
+%{prefix}/qmail/bin/*
diff -Naur tmp/ucspi-tcp-0.88/uint16.h ucspi-tcp-0.88/uint16.h
--- tmp/ucspi-tcp-0.88/uint16.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/uint16.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,11 +1,20 @@
+/*
+ * $Log: uint16.h,v $
+ * Revision 1.2  2005-05-13 23:54:03+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef UINT16_H
 #define UINT16_H
 
 typedef unsigned short uint16;
 
-extern void uint16_pack(char *,uint16);
-extern void uint16_pack_big(char *,uint16);
-extern void uint16_unpack(char *,uint16 *);
-extern void uint16_unpack_big(char *,uint16 *);
+void            uint16_pack(char *, uint16);
+void            uint16_pack_big(char *, uint16);
+void            uint16_unpack(char *, uint16 *);
+void            uint16_unpack_big(char *, uint16 *);
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/uint16_pack.c ucspi-tcp-0.88/uint16_pack.c
--- tmp/ucspi-tcp-0.88/uint16_pack.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/uint16_pack.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,13 +1,21 @@
+/*
+ * $Log: uint16_pack.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "uint16.h"
 
-void uint16_pack(char s[2],uint16 u)
+void
+uint16_pack(char s[2], uint16 u)
 {
-  s[0] = u & 255;
-  s[1] = u >> 8;
+	s[0] = u & 255;
+	s[1] = u >> 8;
 }
 
-void uint16_pack_big(char s[2],uint16 u)
+void
+uint16_pack_big(char s[2], uint16 u)
 {
-  s[1] = u & 255;
-  s[0] = u >> 8;
+	s[1] = u & 255;
+	s[0] = u >> 8;
 }
diff -Naur tmp/ucspi-tcp-0.88/uint16_unpack.c ucspi-tcp-0.88/uint16_unpack.c
--- tmp/ucspi-tcp-0.88/uint16_unpack.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/uint16_unpack.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,23 +1,31 @@
+/*
+ * $Log: uint16_unpack.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "uint16.h"
 
-void uint16_unpack(char s[2],uint16 *u)
+void
+uint16_unpack(char s[2], uint16 * u)
 {
-  uint16 result;
+	uint16          result;
 
-  result = (unsigned char) s[1];
-  result <<= 8;
-  result += (unsigned char) s[0];
+	result = (unsigned char) s[1];
+	result <<= 8;
+	result += (unsigned char) s[0];
 
-  *u = result;
+	*u = result;
 }
 
-void uint16_unpack_big(char s[2],uint16 *u)
+void
+uint16_unpack_big(char s[2], uint16 * u)
 {
-  uint16 result;
+	uint16          result;
 
-  result = (unsigned char) s[0];
-  result <<= 8;
-  result += (unsigned char) s[1];
+	result = (unsigned char) s[0];
+	result <<= 8;
+	result += (unsigned char) s[1];
 
-  *u = result;
+	*u = result;
 }
diff -Naur tmp/ucspi-tcp-0.88/uint32_pack.c ucspi-tcp-0.88/uint32_pack.c
--- tmp/ucspi-tcp-0.88/uint32_pack.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/uint32_pack.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,21 +1,29 @@
+/*
+ * $Log: uint32_pack.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "uint32.h"
 
-void uint32_pack(char s[4],uint32 u)
+void
+uint32_pack(char s[4], uint32 u)
 {
-  s[0] = u & 255;
-  u >>= 8;
-  s[1] = u & 255;
-  u >>= 8;
-  s[2] = u & 255;
-  s[3] = u >> 8;
+	s[0] = u & 255;
+	u >>= 8;
+	s[1] = u & 255;
+	u >>= 8;
+	s[2] = u & 255;
+	s[3] = u >> 8;
 }
 
-void uint32_pack_big(char s[4],uint32 u)
+void
+uint32_pack_big(char s[4], uint32 u)
 {
-  s[3] = u & 255;
-  u >>= 8;
-  s[2] = u & 255;
-  u >>= 8;
-  s[1] = u & 255;
-  s[0] = u >> 8;
+	s[3] = u & 255;
+	u >>= 8;
+	s[2] = u & 255;
+	u >>= 8;
+	s[1] = u & 255;
+	s[0] = u >> 8;
 }
diff -Naur tmp/ucspi-tcp-0.88/uint32_unpack.c ucspi-tcp-0.88/uint32_unpack.c
--- tmp/ucspi-tcp-0.88/uint32_unpack.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/uint32_unpack.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,31 +1,39 @@
+/*
+ * $Log: uint32_unpack.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include "uint32.h"
 
-void uint32_unpack(char s[4],uint32 *u)
+void
+uint32_unpack(char s[4], uint32 * u)
 {
-  uint32 result;
+	uint32          result;
 
-  result = (unsigned char) s[3];
-  result <<= 8;
-  result += (unsigned char) s[2];
-  result <<= 8;
-  result += (unsigned char) s[1];
-  result <<= 8;
-  result += (unsigned char) s[0];
+	result = (unsigned char) s[3];
+	result <<= 8;
+	result += (unsigned char) s[2];
+	result <<= 8;
+	result += (unsigned char) s[1];
+	result <<= 8;
+	result += (unsigned char) s[0];
 
-  *u = result;
+	*u = result;
 }
 
-void uint32_unpack_big(char s[4],uint32 *u)
+void
+uint32_unpack_big(char s[4], uint32 * u)
 {
-  uint32 result;
+	uint32          result;
 
-  result = (unsigned char) s[0];
-  result <<= 8;
-  result += (unsigned char) s[1];
-  result <<= 8;
-  result += (unsigned char) s[2];
-  result <<= 8;
-  result += (unsigned char) s[3];
+	result = (unsigned char) s[0];
+	result <<= 8;
+	result += (unsigned char) s[1];
+	result <<= 8;
+	result += (unsigned char) s[2];
+	result <<= 8;
+	result += (unsigned char) s[3];
 
-  *u = result;
+	*u = result;
 }
diff -Naur tmp/ucspi-tcp-0.88/wait.h ucspi-tcp-0.88/wait.h
--- tmp/ucspi-tcp-0.88/wait.h	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/wait.h	2008-07-27 18:41:52.000000000 +0530
@@ -1,10 +1,19 @@
+/*
+ * $Log: wait.h,v $
+ * Revision 1.2  2005-05-13 23:54:08+05:30  Cprogrammer
+ * code indentation
+ *
+ * Revision 1.1  2003-12-31 19:57:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #ifndef WAIT_H
 #define WAIT_H
 
-extern int wait_pid();
-extern int wait_nohang();
-extern int wait_stop();
-extern int wait_stopnohang();
+int             wait_pid();
+int             wait_nohang();
+int             wait_stop();
+int             wait_stopnohang();
 
 #define wait_crashed(w) ((w) & 127)
 #define wait_exitcode(w) ((w) >> 8)
diff -Naur tmp/ucspi-tcp-0.88/wait_nohang.c ucspi-tcp-0.88/wait_nohang.c
--- tmp/ucspi-tcp-0.88/wait_nohang.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/wait_nohang.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,12 +1,20 @@
+/*
+ * $Log: wait_nohang.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <sys/wait.h>
 #include "haswaitp.h"
 
-int wait_nohang(wstat) int *wstat;
+int
+wait_nohang(wstat)
+	int            *wstat;
 {
 #ifdef HASWAITPID
-  return waitpid(-1,wstat,WNOHANG);
+	return waitpid(-1, wstat, WNOHANG);
 #else
-  return wait3(wstat,WNOHANG,(struct rusage *) 0);
+	return wait3(wstat, WNOHANG, (struct rusage *) 0);
 #endif
 }
diff -Naur tmp/ucspi-tcp-0.88/wait_pid.c ucspi-tcp-0.88/wait_pid.c
--- tmp/ucspi-tcp-0.88/wait_pid.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/wait_pid.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,3 +1,9 @@
+/*
+ * $Log: wait_pid.c,v $
+ * Revision 1.1  2003-12-31 19:47:31+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <sys/types.h>
 #include <sys/wait.h>
 #include "error.h"
@@ -5,35 +11,56 @@
 
 #ifdef HASWAITPID
 
-int wait_pid(wstat,pid) int *wstat; int pid;
+int
+wait_pid(wstat, pid)
+	int            *wstat;
+	int             pid;
 {
-  int r;
+	int             r;
 
-  do
-    r = waitpid(pid,wstat,0);
-  while ((r == -1) && (errno == error_intr));
-  return r;
+	do
+		r = waitpid(pid, wstat, 0);
+	while ((r == -1) && (errno == error_intr));
+	return r;
 }
 
 #else
 
-/* XXX untested */
-/* XXX breaks down with more than two children */
-static int oldpid = 0;
-static int oldwstat; /* defined if(oldpid) */
-
-int wait_pid(wstat,pid) int *wstat; int pid;
+/*
+ * XXX untested 
+ */
+/*
+ * XXX breaks down with more than two children 
+ */
+static int      oldpid = 0;
+static int      oldwstat;		/*- defined if(oldpid) */
+
+int
+wait_pid(wstat, pid)
+	int            *wstat;
+	int             pid;
 {
-  int r;
-
-  if (pid == oldpid) { *wstat = oldwstat; oldpid = 0; return pid; }
+	int             r;
 
-  do {
-    r = wait(wstat);
-    if ((r != pid) && (r != -1)) { oldwstat = *wstat; oldpid = r; continue; }
-  }
-  while ((r == -1) && (errno == error_intr));
-  return r;
+	if (pid == oldpid)
+	{
+		*wstat = oldwstat;
+		oldpid = 0;
+		return pid;
+	}
+
+	do
+	{
+		r = wait(wstat);
+		if ((r != pid) && (r != -1))
+		{
+			oldwstat = *wstat;
+			oldpid = r;
+			continue;
+		}
+	}
+	while ((r == -1) && (errno == error_intr));
+	return r;
 }
 
 #endif
diff -Naur tmp/ucspi-tcp-0.88/warn-auto.sh ucspi-tcp-0.88/warn-auto.sh
--- tmp/ucspi-tcp-0.88/warn-auto.sh	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/warn-auto.sh	2003-12-31 19:55:17.000000000 +0530
@@ -1,2 +1,3 @@
 #!/bin/sh
 # WARNING: This file was auto-generated. Do not edit!
+#
diff -Naur tmp/ucspi-tcp-0.88/who@.1 ucspi-tcp-0.88/who@.1
--- tmp/ucspi-tcp-0.88/who@.1	1970-01-01 05:30:00.000000000 +0530
+++ ucspi-tcp-0.88/who@.1	2000-11-16 17:06:19.000000000 +0530
@@ -0,0 +1,44 @@
+.TH who@ 1
+.SH NAME
+who@ \- prints the list of active users on a remote host.
+.SH SYNOPSIS
+.B who@
+[
+.I host
+]
+.SH DESCRIPTION
+.B who@
+connects to TCP port 11 (Systat) on
+.I host
+and prints any data it receives. It removes CR (\\015) and converts unprintable
+characters to a visible format. 
+
+If
+.I host
+is not supplied,
+.B who@
+connects to the local host. 
+
+Some computers respond to port 11 with a list of active users. For example,
+they may be running 
+.IP
+tcpserver -RHl0 0 11 who
+.P
+using tcpserver.
+.SH SEE ALSO
+tcpserver(1),
+tcprules(1),
+tcprulescheck(1),
+argv0(1),
+fixcrio(1),
+recordio(1),
+rblsmtpd(1),
+tcpclient(1),
+date@(1),
+finger@(1),
+http@(1),
+tcpcat(1),
+mconnect(1),
+tcp-environ(5)
+
+http://cr.yp.to/ucspi-tcp.html
diff -Naur tmp/ucspi-tcp-0.88/who@.sh ucspi-tcp-0.88/who@.sh
--- tmp/ucspi-tcp-0.88/who@.sh	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/who@.sh	2008-07-27 18:43:34.000000000 +0530
@@ -1 +1,7 @@
+#
+# $Log: who@.sh,v $
+# Revision 1.1  2003-12-31 19:57:58+05:30  Cprogrammer
+# Initial revision
+#
+#
 HOME/bin/tcpclient -RHl0 -- "${1-0}" 11 sh -c 'exec HOME/bin/delcr <&6' | cat -v
diff -Naur tmp/ucspi-tcp-0.88/x86cpuid.c ucspi-tcp-0.88/x86cpuid.c
--- tmp/ucspi-tcp-0.88/x86cpuid.c	2000-03-18 20:48:42.000000000 +0530
+++ ucspi-tcp-0.88/x86cpuid.c	2008-07-27 18:39:32.000000000 +0530
@@ -1,38 +1,50 @@
+/*
+ * $Log: x86cpuid.c,v $
+ * Revision 1.1  2003-12-31 19:46:33+05:30  Cprogrammer
+ * Initial revision
+ *
+ */
 #include <signal.h>
 
-void nope()
+void
+nope()
 {
-  exit(1);
+	exit(1);
 }
 
 main()
 {
-  unsigned long x[4];
-  unsigned long y[4];
-  int i;
-  int j;
-  char c;
-
-  signal(SIGILL,nope);
-
-  x[0] = 0;
-  x[1] = 0;
-  x[2] = 0;
-  x[3] = 0;
-
-  asm volatile(".byte 15;.byte 162" : "=a"(x[0]),"=b"(x[1]),"=c"(x[3]),"=d"(x[2]) : "0"(0) );
-  if (!x[0]) return 0;
-  asm volatile(".byte 15;.byte 162" : "=a"(y[0]),"=b"(y[1]),"=c"(y[2]),"=d"(y[3]) : "0"(1) );
-
-  for (i = 1;i < 4;++i)
-    for (j = 0;j < 4;++j) {
-      c = x[i] >> (8 * j);
-      if (c < 32) c = 32;
-      if (c > 126) c = 126;
-      putchar(c);
-    }
+	unsigned long   x[4];
+	unsigned long   y[4];
+	int             i;
+	int             j;
+	char            c;
+
+	signal(SIGILL, nope);
+
+	x[0] = 0;
+	x[1] = 0;
+	x[2] = 0;
+	x[3] = 0;
+
+	asm volatile    (".byte 15;.byte 162":"=a" (x[0]), "=b"(x[1]), "=c"(x[3]), "=d"(x[2]):"0"(0));
+	if (!x[0])
+		return 0;
+	asm volatile    (".byte 15;.byte 162":"=a" (y[0]), "=b"(y[1]), "=c"(y[2]), "=d"(y[3]):"0"(1));
+
+	for (i = 1; i < 4; ++i)
+	{
+		for (j = 0; j < 4; ++j)
+		{
+			c = x[i] >> (8 * j);
+			if (c < 32)
+				c = 32;
+			if (c > 126)
+				c = 126;
+			putchar(c);
+		}
+	}
+	printf("-%08x-%08x\n", y[0], y[3]);
 
-  printf("-%08x-%08x\n",y[0],y[3]);
-
-  return 0;
+	return 0;
 }
