#!/usr/bin/perl -T
#
# File: qmail-scanner-queue.pl
# Version: 0.96
#
# Author: Jason L. Haar <jhaar@users.sourceforge.net>
# 
# This file was auto-generated by:
#
# ./configure 
# 
# Description: This is a replacement/add-on for Qmail 1.0.3's qmail-queue.
# It can call several virus scanners on every SMTP-received Email message
# checking for viruses, only allowing the message to continue if it is
# virus-free.
#
#
#   Copyright (C) 1999,2000 the people mentioned above
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 1, or (at your option)
#   any later version. See <URL:http://www.gnu.org/copyleft/gpl.html>
#   for a copy.
# 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   The software is provided as is. Please bear in mind that we have 
#   done this in my spare time. While it is as accurate as we could 
#   make it there is a reasonable chance that there are mistakes 
#   somewhere in here. If you email me and tell me about them, I will 
#   be happy to fix them but I can't take responsibility for your system. 
#   Basically use this at your own risk. 
#
#####################################################################

#####################################################################
##
## Required Packages
##
## Qmail-1.03
## Perl 5.005_03+
## Maildrop-0.73
## Bruce Guenter's QMAILQUEUE patch <URL:http://www.qmail.org/qmailqueue-patch>
## Perl module Time::HiRes and DB_File
##
##
## So-far tested Virus scanners:
##     Trend's Virus scanner for Linux
##     MacAfee's (NAI's) virus scanner for Linux
##     Sophos's virus scanner for Linux
##     H+BEDV's antivir scanner for Linux
##     F-Secure's fsav scanner for Linux
## 
#####################################################################

#####################################################################
##
## Site-specific config
##
#####################################################################

$VERSION="0.96";

#Mail header to add to each scanned message to report stuff in...
#Default is to not generate them ($descriptive_hdrs = 0) - as  that
#info is also in the Received: headers...
$descriptive_hdrs=0;
$V_HEADER="X-Qmail-Scanner";

#From: line  information used when making reports
$V_FROM='postmaster@indi.com';
$V_FROMNAME='System Anti-Virus Administrator';

# Address carbon-copied on any virus reports
$VIRUS_CC='root@phoenix2.maa.indi.net';

#Array of virus scanners used must point to subroutines
@scanner_array=("uvscan_scanner");

#Addresses that should be alerted of any quarantined Email
$NOTIFY_ADDRS='sender';


# The full path to qmail programs we'll need.
$qmailinject = '/var/qmail/bin/qmail-inject';
$qmailqueue  = '/var/qmail/bin/qmail-multi';

# What directory to use for storing temporary files.
$scandir = '/queue/qmailscan';

#What maildir folder to store working files in
$wmaildir='working';

#What maildir folder to store failed messages in (for cronjob scan)
$fmaildir='failed';

#What maildir folder to store quarantine in
$vmaildir='quarantine';


#What maildir folder to archive received Email in instead of deleting
$archiveit='0';
$archivedir='archives';

#Name of file in $scandir where debugging output goes
$debuglog="qmail-queue.log";

#Name of file where virus reports go (for long-term storage)
$viruslog="quarantine.log";

#Generate nice random filename
$hostname='phoenix2.maa.indi.net'; #could get via call I suppose...

#If you trust the virus scanners handling of mbox format itself
#you may want to let it have a go at the "raw" message, and original
#zip files if present
$redundant_scanning=0;

#If you want to log via file/syslog information of all Email
# that passes through your system (from/to/subj/size/attachments)
$log_details="0";

#Full path to file in which virus versioning info is kept
$versionfile="$scandir/qmail-scanner-queue-version.txt";

#DB file (without extension) where bad filenames are kept.
# You edit $db_filename.txt, and "qmail-scanner-queue.pl -g" generates $db_filename.db
$db_filename="$scandir/quarantine-attachments";

#Full paths to binaries used within this script follow - small performance
#improvement :-)


$mimeunpacker_binary='/usr/local/bin/reformime ';
$unzip_binary='/usr/bin/unzip';
$tnef_binary='';
$rm_binary='/usr/bin/rm';
$find_binary='/usr/bin/find';
$grep_binary='/usr/bin/grep';
$uudecode_binary='/usr/bin/uudecode';
$uudecode_pipe='-p';

$uvscan_binary='/var/qmail/bin/uvscan';
$sweep_binary='';
$iscan_binary='';
$hbedv_binary='';
$avp_binary='';
$fsecure_binary='';
$inocucmd_binary='';
$ENV{'PATH'}='/bin:/usr/bin';
$MAX_FILE_LENGTH=100;

#Finally, are you sure your virus scanners can unpack zip files? 
#McAfee's doesn't!
$scanners_unzip_broken=1;

#Descriptive string to use in generated Email
$destring="Virus";

#####################################################################
## 
## End of site-specific settings
##
#####################################################################




#Get current timestamp for logs
($sec,$min,$hour,$mday,$mon,$year) = localtime(time);
$nowdate = sprintf "%02d/%02d/%02d %02d:%02d:%02d", $mday, $mon+1, $year+1900, $hour, $min, $sec;

#Want debugging? Enable this and read $scandir/qmail-queue.log
$DEBUG=0;

@uufile_list = ();

#Want microsec times for debugging
use Time::HiRes qw( usleep ualarm gettimeofday tv_interval );
use POSIX;
use Getopt::Std;
getopts('vhgrz');

$start_time = [gettimeofday];

if ( $opt_h) {
  ($prog=$0)=~s/^.*\///g;
  print "

$prog

    -h - This help
    -v - show details about this install. 
         Please include in any bug reports.
    -z - gather virus scanner/DAT versions 
         and cleanup old temp files
    -g - generate perlscanner database
    -r - read from perlscanner database\n";
  exit;
}


if ( $opt_g || $opt_r) {
  &generate_quarantine_db;
    exit 0;
}

if ( $opt_v ) {
  &show_version;
  exit 0;
}

chdir($scandir);
umask(0007);
$virus_found=0;


#Nice unique filename
$file_id = "$hostname" . time . $$;


#For security reasons, tighten the follow vars...
$ENV{'SHELL'} = '/bin/sh' if exists $ENV{SHELL};
$ENV{'TMP'} = $ENV{'TMPDIR'} = "$scandir/$file_id";
#$ENV{'QMAILSroot'} = $ENV{'QMAILSHOST'} = '';
delete @ENV{qw(IFS CDPATH ENV BASH_ENV QMAILMFTFILE QMAILINJECT)};



if ($mimeunpacker_binary =~ /reformime/) {
  $mimeunpacker_binary .= " -x$scandir/$file_id/";
}

if ($DEBUG ) {
  open(LOG,">>$scandir/$debuglog");
  select(LOG);$|=1;
  &debug("+++ starting debugging for process $$");
}

&debug("setting UID to EUID so subprocesses can access files generated by this script");
$< = $>;            # set real to effective uid

&debug("program name is $0");
if ($opt_z) {
  &scan_queue;
  exit 0;
}


&scanner_info;

&working_copy;
&debug("subj=$headers{'subject'}");

&deconstruct_msg;


#Now unset env var QMAILQUEUE so any further Email's sent don't
#go through the virus scanner
&debug("unsetting QMAILQUEUE env var");
delete $ENV{'QMAILQUEUE'};



if ($virus_found) {
  &email_virus_report;
} else {
  &qmail_requeue($env_returnpath,$env_recips,"$scandir/$wmaildir/new/$file_id"); 
}

if ($log_details) {
  &log_msg("perlscanner",$virus_found,$elapsed_time,$returnpath,$recips,$headers{'subject'},$headers{'message-id'},$msg_size,$headers{'date'},$file_desc);
}
&cleanup;
&debug("all finished");
exit 0;

############################################################################
# Error handling
############################################################################

# Fail with the given message and a permanent failure code.
sub bounce { 
  warn @_, "\n"; 
  close(LOG);
  exit 100;
}

# Fail with the given message and a temporary failure code.
sub tempfail { 
  warn "$V_HEADER-$VERSION: ",@_, "\n"; 
  &debug("tempfail: $V_HEADER-$VERSION: ",@_);
  close(LOG);
  &cleanup;
  exit 111;
}

#Fail with the given message and a perm failure code.
sub permfail {
  warn "$V_HEADER-$VERSION: ",@_, "\n";
  &debug("permfail: $V_HEADER-$VERSION: ",@_);
  close(LOG);
  exit 31;
}

sub debug {
  print LOG "$nowdate:$$: ",@_,"\n" if ($DEBUG);
}

sub working_copy {
  
  select(STDIN); $|=1;
  select(STDOUT); $|=1;
  
  &debug("w_c: mkdir $scandir/$file_id");
  mkdir("$scandir/$file_id",0700);
  chdir("$scandir/$file_id/");

  &debug("w_c: dump incoming msg into $scandir/$wmaildir/tmp/$file_id");
  open(TMPFILE,">$scandir/$wmaildir/tmp/$file_id")||&tempfail("cannot write to $scandir/$wmaildir/tmp/$file_id - $!");
  
  $still_headers=1;
  while(<STDIN>) {
    if ($still_headers) {
      
      #Put headers into array
      if (/^([^\s]+):(.*)$/) {
	$hdr=$1;
	$value=$2;
	$value=~s/^ //;
	$num_of_headers++;
	#Don't let this array grow without bounds...
	$headers{tolower($hdr)}=$value if ($num_of_headers < 140);
      }
      if (/^Return-path:/i || ( $descriptive_hdrs && /^$V_HEADER/) ) {
        #skip it - let qmail re-create R-P from envelope header...
        next;
      }
      $still_headers=0 if (/^\n$/);
    }
    &check_and_grab_uuencoding;
    print TMPFILE ;
  }
  close(TMPFILE)||&tempfail("cannot close $scandir/$wmaildir/tmp/$file_id - $!");
  &debug("w_c: rename new msg from $scandir/$wmaildir/tmp/$file_id to $scandir/$wmaildir/new/$file_id");
  rename("$scandir/$wmaildir/tmp/$file_id","$scandir/$wmaildir/new/$file_id")||&tempfail("cannot rename $scandir/$wmaildir/tmp/$file_id into $scandir/$wmaildir/new/$file_id - $!");
  ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$msg_size,$atime,$mtime,$ctime,$blksize,$blocks) = stat("$scandir/$wmaildir/new/$file_id");
  if (!$headers{'date'}) {
    $day[0]='Sun';$day[1]='Mon';$day[2]='Tue';$day[3]='Wed';$day[4]='Thu';$day[5]='Fri';$day[6]='Sat';
    $mon[0]='Jan';$mon[1]='Feb';$mon[2]='Mar';$mon[3]='Apr';$mon[4]='May';$mon[5]='Jun';$mon[6]='Jul';$mon[7]='Aug';$mon[8]='Sep';$mon[9]='Oct';$mon[10]='Nov';$mon[11]='Dec';
    ($tm_sec,$tm_min,$tm_hour,$tm_mday,$tm_mon,$tm_year,$tm_wday,$tm_yday,$tm_isdst)=localtime;
    $tm_year += 1900;
    $headers{'date'}=$day[$tm_wday].", $tm_mday ".$mon[$tm_mon]." $tm_year $tm_hour:$tm_min:$tm_sec";
  }
  #  close(STDIN)||&tempfail("cannot close fd 0 - $!");
  
  open(SOUT,"<&STDOUT")||&tempfail("cannot dup fd 0 - $!");
  while (<SOUT>) {
    ($env_returnpath,$env_recips) = split(/\0/,$_,2);
    if ( ($returnpath=$env_returnpath)=~s/^F(.*)$// ) {
      $returnpath=$1;
      ($recips=$env_recips)=~ s/^T//;
      $recips=~ s/\0T/\,/g;
      $recips=~ /^(.*)\0+$/;
      $recips=$1;
      $recips=~ s/\0+$//g;
    }
    #only meant to be one line!
    last;
  }
  close(SOUT)||&tempfail("cannot close fd 1 - $!");
  if ( $env_returnpath eq "" && $env_recips eq "" ) {
    #At the very least this is supposed to be $env_returnpath='F' - so
    #qmail-smtpd must be officially dropping the incoming message for
    #some (valid) reason.
    &debug("w_c: STDOUT undefined - qmail-smtpd must be rejecting Email - exit");
    &cleanup;
    exit;
  }
  &debug("w_c: return-path is $returnpath, recips is $recips");
}

sub deconstruct_msg {
  local($start_decon_time)=[gettimeofday];
  local($save_filename)='';

  &debug("d_m: $mimeunpacker_binary <$scandir/$wmaildir/new/$file_id");
  open(MIME,"$mimeunpacker_binary  <$scandir/$wmaildir/new/$file_id|")||&tempfail("cannot call mimeunpacker - $!");
  close(MIME)||&tempfail("cannot close mimeunpacker - $!");
  $unpacker='';
  
  opendir(DIR,"$scandir/$file_id/")||&tempfail("cannot open dir $scandir/$file_id/ - $!"); 
  #mimeunpacker drops any directory names - so only files exist in $file_id
  @allfiles = grep(!/^\.+$/, readdir(DIR));
  closedir(DIR);
  
  #If you have the tnef app, you'll be able to scan broken M$ attachments
  
  if ( $tnef_binary ) {
    &debug("d_m: Checking all attachments to see if they're MS-TNEF");
    foreach $save_filename (@allfiles) {
      #Clean up $save_filename so as to keep taint happy
      if ($save_filename =~ /^([a-z0-9\.\-\_\+\=\;\:\,\@\~]+)$/i) {
	$new_filename=$1;
      }
      if ($save_filename ne $new_filename) {
	&tempfail("illegal filenames found in attachment - probably a hacker...");
      } else {
	$save_filename=$new_filename;
      }
      #Who cares if it is or isn't tnef, just scan it!
      $MAYBETNEF=`$tnef_binary -d $scandir/$file_id/ -f $scandir/$file_id/$save_filename 2>&1`;
    }
  }

  #If you're happy with your scanners zip file handling, you can 
  #skip this whole section. McAfee's doesn't support zip for starters!
  
  if ($scanners_unzip_broken) {
    &debug("d_m: Manually unpack any zip files as some virus scanners don't do zip under Unix!");
    foreach $save_filename (@allfiles) {
      #Clean up $save_filename so as to keep taint happy
      $save_filename =~ /^([a-z0-9\.\-\_\+\=\;\:\,\@\~]+)$/i;
      $new_filename=$1;
      if ($save_filename ne $new_filename) {
	&tempfail("illegal filenames found in attachment - probably a hacker...");
      } else {
	$save_filename=$new_filename;
      }
      if ( $save_filename =~ /\.(zip|exe)$/i) {
	&unzip_file($save_filename);
      }
    }
  }
  chdir("$scandir/$file_id/");
  #Run perlscan_scanner
  &perlscan_scanner;
  
  #Virus? No point in running the rest then
  return if ($virus_found);

  #Delete original zip'ped attachment as there's no point 
  #in the other scanners double-scanning it - unless $redundant scanning
  #is set....
  if (!$redundant_scanning) {
    unlink("$scandir/$file_id/$save_filename");
    $extra_file='';
  } else {
    $extra_file="$scandir/$wmaildir/new/$file_id";
  }
  &debug("d_m: recursively scan the directory $scandir/$file_id/");
  &scanloop;
  &debug("d_m: Total of $virus_found viruses found");
  chdir("$scandir");
  local($decon_time)=tv_interval ($start_decon_time, [gettimeofday]);
  &debug("d_m: unpacking MIME message took $decon_time seconds");
}


sub perlscan_scanner {
  #This is most efficient if called from within deconstruct_msg

  local($start_perlscan_time)=[gettimeofday];
  local($lfile);
  &debug("p_s: starting scan of directory \"$scandir/$file_id\"...");
  
  use DB_File;
  
  
  tie (%array, 'DB_File', "$db_filename.db", O_RDONLY, 0600) || &tempfail("cannot open  $db_filename - $!");

  #First off, check out headers against DB...

  foreach $var (sort keys(%array)) {
    ($type,$desc)=split(/\t/,$array{$var},2);
    &debug("p_s:  '$var' = '$type' = '$desc'");
    if ($type !~ /^[0-9]+$/) {
      &debug("p_s:  type is a header!");
      $type =~ s/^Virus-//g;
      &debug("p_s:  checking for viruses containing $type: $var");
      if ($headers{tolower($type)} =~ /^$var$/) {
	$virus_found++;
	$virus_description="$desc";
	$description .= "\n---perlscanner results ---\n$destring '$virus_description' found in file $scandir/$file_id/$file";
	&debug("p_s: there be a virus! ($virus_description)");
      }
    } else {
      &debug("p_s: type is a size!");
    }
  }

  opendir(DIR,"$scandir/$file_id/")||&tempfail("cannot open dir $scandir/$file_id/ - $!"); 
  @allfiles = grep(!/^\.+$/, readdir(DIR));
  closedir(DIR);

  #append any ORIGINAL uuencoded filenames to this directory array
  #so that perlscanner can match on uuencoded filenames
  foreach $file (@allfiles,@uufile_list) {
    #skip files that reformime generates.
    #This will potentially allow baddies to smuggle files through
    #by using filenames like this... Nothing can be done about that:-(
    #Reformime generates filenames of the form:
    # attachmentsX.dat and 967067231.24320-X.host.name (where X is a number)
    if ($file =~ /^attachment[0-9]+\.dat$|^[0-9]+\.[0-9]+\-[0-9]+\.|^$file_id/) {
      &debug("p_s: skipping auto-generated file $file");
      $ps_skipfile=1;
    } else {
      &debug("p_s: checking $file against perlscanner database...");
      $ps_skipfile=0;
    }

    # Grab extension for wildcard matches
    if ($file=~/(^.*)(\.[^\.]+)$/) {
      $extension=tolower($2);
    } else {
      $extension="";
    }
    $lfile = tolower($file);
    &debug("p_s: file $file is lowercased to $lfile and has extension $extension");
    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat("$file");
    if ($size) {
      #Sanity check so that the virtual attachments don't get double-counted
      $file_desc .= "$file:$size\t";
    }
    &debug("p_s: compare $lfile against perlscanner database") if (!$ps_skipfile);
    if ( ($array{$lfile} || $array{$extension}) && !$ps_skipfile ) {
      if ($array{$lfile}) {
	($fsize,$virus_description) = split(/\t/,$array{$lfile},2);
      } else {
	$destring="Illegal attachment type";
	($fsize,$virus_description) = split(/\t/,$array{$extension},2);
      }
      $attachment_list.="$file:$size,";
      if ($size eq $fsize || $fsize =~ /^(\-|\*|any|0)$/i ) {
	&debug("p_s: Quarantine $file! ($virus_description)");
	$virus_found++;
	$description .= "\n---perlscanner results ---\n$destring '$virus_description' found in file $scandir/$file_id/$file";
	$section=$apptype=$save_filename=$filename="";
#	return;
      }
    }
  }
  untie %array;
  chdir("$scandir/");
  local($stop_perlscan_time)=[gettimeofday];
  $perlscan_time = tv_interval ($start_perlscan_time, $stop_perlscan_time);
  &debug("p_s:  finished scan of dir \"$scandir/$file_id\" in $perlscan_time secs");
}


sub scanloop {
  &debug("scanloop: starting scan of directory \"$scandir/$file_id\"...");
  foreach $scanner (@scanner_array) {
    #Any scanner errors caused by broken zip files/etc will be ignored
    # - not sure how that should be handled...
    &{$scanner};
    if ($virus_found) {
      #If one virus scanner finds a virus - why run the rest over it?
      last;
    }
  }
  &debug("scanloop: finished scan of \"$scandir/$file_id\"...");
}

sub qmail_requeue {
  local($sender,$env_recips,$msg)=@_;
  local($temp,$still_headers);

  &debug("q_r: fork off child into $qmailqueue...");

  ($recips=$env_recips)=~ s/^T//;
  $recips=~ s/\0T/\,/g;
  $recips=~ /^(.*)\0+$/;
  $recips=$1;
  $recips=~ s/\0+$//g;
  
  # Create a pipe through which to send the envelope addresses.
  pipe (EOUT, EIN) or &tempfail("Unable to create a pipe. - $!");
  select(EOUT);$|=1;
  select(EIN);$|=1;
  # Fork qmail-queue.  The qmail-queue child will then open fd 0 as
  # $message and fd 1 as the reading end of the envelope pipe and exec
  # qmail-queue.  The parent will read in the addresses and pass them 
  # through the pipe and then check the exit status.

  $elapsed_time = tv_interval ($start_time, [gettimeofday]);
  local $SIG{PIPE} = 'IGNORE';
  my $pid = fork;

  if (not defined $pid) {
    &tempfail ("Unable to fork. (#4.3.0) - $!");
  } elsif ($pid == 0) {
    # In child.  Mutilate our file handles.
    close EIN; 
    
    open(STDIN,"<$msg")|| &tempfail ("Unable to reopen fd 0. (#4.3.0) - $!");

    open (STDOUT, "<&EOUT") ||  &tempfail ("Unable to reopen fd 1. (#4.3.0) - $!");
    select(STDIN);$|=1;
#    select(STDOUT);$|=1;
#    exec $qmailqueue;
    open(QMQ,"|$qmailqueue")||&tempfail("Unable to fork $qmailqueue (#4.3.0) - $!");
    $still_headers=1;
    ($sec,$min,$hour,$mday,$mon,$year) = gmtime(time);
    $elapsed_time = tv_interval ($start_time, [gettimeofday]);
    $findate = POSIX::strftime( "%d %b ",$sec,$min,$hour,$mday,$mon,$year);
    $findate .= sprintf "%02d %02d:%02d:%02d -0000", $year+1900, $hour, $min, $sec;
    print QMQ "Received: from $returnpath by $hostname with qmail-scanner-$VERSION ($SCANINFO. Clean. Processed in $elapsed_time secs); $findate\n";
  if ( $descriptive_hdrs ) {
    print QMQ "${V_HEADER}-Mail-From: $returnpath via $hostname\n";
    print QMQ "${V_HEADER}-Rcpt-To: $recips\n";
    print QMQ "$V_HEADER: $VERSION (No viruses found. Processed in $elapsed_time secs)\n";
  }
    while (<STDIN>) {
      print QMQ;
    }
    close(QMQ)||&tempfail("Unable to close pipe to $qmailqueue (#4.3.0) - $!");
    #This child is finished - exit
    exit;
  } else {
    # In parent.
    close EOUT;
      
    # Feed the envelope addresses to qmail-queue.
    print EIN "$sender\0$env_recips";
    close EIN  || &tempfail ("Write error to envelope pipe. (#4.3.0) - $!");
}

  # We should now have queued the message.  Let's find out the exit status
  # of qmail-queue.
  waitpid ($pid, 0);
  local($status)=($? >> 8);
  if ($status != 0) { &tempfail ("Unable to queue message ($status). (#4.3.0) - $!" )}
  
}


sub is_automated_email {
  #This subroutine is used to see if the sender of this virus
  #was a mailing-list/postmaster/etc. If it is we don't want to 
  #send a reply.
  if ($headers{'x-loop'} || $headers{'x-listname'} || $headers{'x-listmember'} || $headers{'mailing-list'} || $headers{'x-mailing-list'} || $headers{'precedence'} =~ /^(bulk|list|junk)$/i || $returnpath =~ /^$|daemon|request|bounce|mailer|postm|owner|lists|words|majordom|experts|\-(return|error)/i) {
    return 1;
  } else {
    return 0;
  }
}

sub email_virus_report {
  local($start_email_time)=[gettimeofday];
  if (&is_automated_email) {
    &debug("q_r: smells like this was from an automated mailer - no virus msg to them then...");
    if ($V_FROM eq "") {
      &debug("q_r: no admin to tell (V_FROM undefined) - so no message - owch!");
      return;
    }
  }

  &debug("q_r: quarantine virus msg to $scandir/$vmaildir/new/$file_id");
  #rename("$scandir/$wmaildir/new/$file_id","$scandir/$vmaildir/new/$file_id")||&tempfail("cannot rename $scandir/$wmaildir/new/$file_id into $scandir/$vmaildir/new/ - $!");
  #unlink("$scandir/$wmaildir/new/$file_id");
  &email_sender;
  &email_recips;
  &write_virus_report;
  $elapsed_time = tv_interval ($start_time, [gettimeofday]);
  &debug("q_r: email_virus_report took ".tv_interval ($start_email_time, [gettimeofday])." seconds to execute");
}

sub cleanup {
  chdir("$scandir/");
  if (!$archiveit) {
    &debug("cleanup: $rm_binary -rf $scandir/$file_id/ $scandir/$wmaildir/new/$file_id") ;
  } else {
    &debug("cleanup: archiving into $scandir/$archivedir/new/");
    rename("$scandir/$wmaildir/new/$file_id","$scandir/$archivedir/new/$file_id");
  }
  system("$rm_binary -rf $scandir/$file_id/ $scandir/$wmaildir/new/$file_id") if ($DEBUG < 100);

}


sub scan_queue {
  local($scanner,$SCANINFO);
  local($files,$sweep_eng,$sweep_product);
  local($start_scan_time)=time;
  local($dir);
  
  chdir($scandir);
  &debug("s_q: re-create the quarantine version file");
  foreach $scanner (@scanner_array) {
    $scanner=~s/_scanner//;
    &debug("s_q: detecting version of $scanner");
    if ($scanner eq "uvscan") {
      open(UV,"$uvscan_binary --version|")||die "failed to call $uvscan_binary --version - $!";
      while (<UV>) {
	chop;
	if (/^Scan engine (v[0-9\.]+) /) {
	  $SCANINFO .="uvscan: $1/";
	} elsif (/^Virus data file (v[0-9\.]+) /) {
	  $SCANINFO .= "$1. ";
	}
      }
      close(UV);
    } elsif ($scanner eq "iscan") {
      open(IS,"$iscan_binary -v|")||die "failed to call $iscan_binary -v - $!";
      while (<IS>) {
	chop;
	if (/Virus Scanner (v[0-9\.]+), VSAPI (v[0-9\.\-]+)/) {
	  $SCANINFO .="iscan: $1/$2/";
	} elsif (/Pattern version ([0-9\.]+)/) {
	  $SCANINFO .= "$1/";
	} elsif (/Pattern number ([0-9\.]+)/) {
	  $SCANINFO .= "$1. ";
	}
      }
      close(IS);
    } elsif ($scanner eq "fsecure") {
      open(FS,"$fsecure_binary --version|")||die "failed to call $fsecure_binary --version - $!";
      while (<FS>) {
        chop;
        if (/Release ([0-9\.]+) build ([0-9]+)/) {
          $SCANINFO .="fsecure: $1/$2/";
        } elsif (/sign.def version ([0-9\.]+-[0-9\.]+-[0-9\.]+)/) {
          $SCANINFO .= "$1/";
        } elsif (/fsmacro.def version ([0-9\.]+-[0-9\.]+-[0-9\.]+)/) {
          $SCANINFO .= "$1/";
        } elsif (/sign2.def version ([0-9\.]+-[0-9\.]+-[0-9\.]+)/) {
          $SCANINFO .= "$1. ";
        }
      }
      close(FS);
    } elsif ($scanner eq "hbedv") {
      open(IS,"$hbedv_binary --version 2>&1 |")||die "failed to call  $hbedv_binary --version - $!";
      while (<IS>) {
	chop;
	  $SCANINFO .= "hbedv: $_. ";
	
      }
      close(IS);
    } elsif ($scanner eq "sweep") {
      open(SOP,"$sweep_binary -v|")||die "failed to call $sweep_binary -v - $!";
      while (<SOP>) {
	chop;
	if (/Engine version\s+:\s+(.*)$/) {
	  $sweep_eng=$1;
	} elsif (/Product version\s+:\s+(.*)$/) {
	  $sweep_product=$1;
	}
      }
      $SCANINFO .= "sweep: $sweep_eng/$sweep_product. "; 
      close(SOP);
    } elsif ($scanner eq "inocucmd") {
      open(IOP,"$inocucmd_binary -HEL|")||die "failed to call $inocucmd_binary -HEL - $!";
      while (<IOP>) {
	chop;
	if (/Engine version:\s+(.*) ([0-9\/]+)$/) {
	  $inocucmd_eng=$1;
	} elsif (/Data version:\s+(.*) ([0-9\/]+)$/) {
	  $inocucmd_product=$1;
	}
      }
      $SCANINFO .= "inocucmd: $inocucmd_eng/$inocucmd_product. "; 
      close(IOP);
    }
  }
  open(VER,">$versionfile")||die "cannot write to $versionfile - $!";
  print VER $SCANINFO;
  close(VER);

  &debug("s_q: cleaning up old files via $find_binary $scandir -type f \! -name '*.log' \! -name '*.txt' \! -name '*.db' \! -path '*/quarantine/*' -prune  -mtime +36 -exec $rm_binary -f {} \;");
  $OLDFILES=`$find_binary $scandir -type f \! -name '*.log' \! -name '*.txt' \! -name '*.db' \! -path '*/quarantine/*' -prune  -mmin +2160 -exec $rm_binary -f {} \\; 2>/dev/null`;
}

sub write_virus_report {
	local($temp);
	$subj=$headers{'subject'};
	$subj=~s/\t/ /g;
	local($desc)=$virus_description;
	$desc=~s/\n\t/ /g;
	local($report) = "$nowdate\t$returnpath\t$recips\t$subj\t$desc\t$SCANINFO\n";
	open(VIRUSLOG,">>$scandir/$viruslog");
	print VIRUSLOG $report;
	close VIRUSLOG;
	&debug("w_v_r: writing virus log report of: $report");
}

sub scanner_info {
  open(SC,"<$versionfile")||&tempfail("cannot open $versionfile - did you initialise the system by running \"$0 -z\"? - $!");
  $SCANINFO = <SC>;
  close(SC);
}

sub generate_quarantine_db {
  use DB_File;
  use vars qw( %h);
  local($line);
  if ($opt_g) {
   unlink("$db_filename.db.tmp");
    tie (%array, 'DB_File', "$db_filename.db.tmp", O_CREAT|O_RDWR, 0640, $DB_HASH ) || &tempfail("cannot open for write $db_filename.db.tmp - $!");
    
    open(TXT,"<$db_filename.txt");

    #Remeber: all filenames are lowercased, but headers aren't...
    while (<TXT>) {
      $line++;
      next if (/^\#|^\s+$/); #ignore lines starting with hashes
      chop;
      $count++;
      ($match,$type,$descr)=split(/\t+/,$_,3);
      if ( $match =~ /^\.dat$/i) {
	print "ERROR: on line $line. Cannot block all .dat files -skipped\n";
	next;
      }
      if ( $match eq "" || ($type !~ /^[0-9]+$/ && $type !~ /^Virus-[0-9a-z\_\-]+:$/i) ) {
	print "ERROR: incorrect format on line $line - skipped\n";
      } else {
	#Strip off any regex endings
	if ($type =~ /^[0-9]+$/) {
	  #this is a filename/attachment
	  $match = tolower($match);
	} else {
	  #this is for header matches
	  $match =~ s/^\^|\$$//g;
	  $type=~s/:$//;
	}
	$array{$match}="$type\t$descr";
      }
    }
    close(TXT);
#    $array->sync;
    untie %array ;
    rename("$db_filename.db.tmp","$db_filename.db");
    print "Total of $count entries.\n";
  } else {
    print "Reading from $db_filename.txt\n";
    tie (%array, 'DB_File', "$db_filename.db", O_RDONLY, 0600) || &tempfail("cannot open  $db_filename - $!");
    foreach $entry (keys %array) {
      $count++;
      ($type,$descrip)=split(/\t/,$array{$entry},2);
      if ( $type =~ /^([0-9]+|Any)/) {
	if ($type eq "0") {
	  $type="Any";
	} elsif ($size =~ /^[0-9]+$/) {
	  $type="$type bytes";
	}
	print "File: \t$entry\n\t\t\tSize: $type\n\t\t\tDescription: $descrip\n\n";
      }
      if ($type =~ /^Virus-(.*)$/i) {
	$type=$1;
	  print "Email Header: \t$type\n\t\t\tContent: ^$entry\$\n\t\t\tDescription: $descrip\n\n";
      }
    }
    untie %array;
    print "Total of $count files found.\n";
  }
}




sub show_version {

  &scanner_info;
  print "

$0 

Version: $VERSION

Perl:    Summary of my perl5 (5.0 patchlevel 5 subversion 3) configuration:
    /usr/local/lib/perl5/5.00503/sun4-solaris
    /usr/local/lib/perl5/5.00503
    /usr/local/lib/perl5/site_perl/5.005/sun4-solaris
    /usr/local/lib/perl5/site_perl/5.005

Scanners: perlscanner";
  foreach $scanner (@scanner_array) {
    print ", $scanner";
  }

  print "\n\nScanner versioning: $SCANINFO\n";
  print "
Operating System: SunOS, 5.7
Hardware:         sun4u";
  print "\n\n\n";
}


sub email_sender {

  open(SM,"|$qmailinject -h -f ''")||&tempfail("cannot open $qmailinject for sending virus report - $!");
  print SM "From: \"$V_FROMNAME\" <$V_FROM>\n";
  if (!&is_automated_email && &notify_addr('sender')) {
    &debug("e_s: sending virus report via: $qmailinject to sender address ($returnpath)");
    print SM "To: $returnpath\n";
  }
  if (&notify_addr('admin')) {
    &debug("e_s: sending virus report via: $qmailinject to admin address ($VIRUS_CC)");
    print SM "Cc: $VIRUS_CC\n";
  }
  print SM "Subject: $destring found in sent message \"$headers{'subject'}\"\n";
  print SM "X-Tnz-Problem-Type: 40\n";
  print SM "MIME-Version: 1.0\n";
  print SM "Content-type: text/plain\n";
  if ( $descriptive_hdrs ) {
    print SM "${V_HEADER}-Mail-From: $returnpath via $hostname\n";
    print SM "${V_HEADER}-Rcpt-To: $recips\n";
    print SM "$V_HEADER: $VERSION ($SCANINFO $destring Found. Processed in ",tv_interval($start_time,[gettimeofday])," secs)\n\n";
  }
  
  if (!&is_automated_email) {
    print SM "
Attention: $headers{'from'}.\n";
  } else {
    print SM "
Attention: $V_FROMNAME.\n";
    print SM "
[This message was _not_ sent to the originator, as they appear to
be a mailing-list or other automated Email message]\n";
  }
  print SM "\n
A $destring was found in an Email message you sent. 
This Email scanner intercepted it and stopped the entire message
reaching it's destination. 

The $destring was reported to be: 

$virus_description\n";
  if ($destring eq "Virus") {
    print SM "\n
Please update your virus scanner or contact your I.T support 
personnel as soon as possible as you have a virus on your system.\n";
  } else {
    print SM "\n
Please contact your I.T support personnel with any queries regarding this 
policy.\n";
  }
  print SM "\n
Your message was sent with the following envelope:

MAIL FROM: $returnpath
RCPT TO:   $recips 

... and with the following headers:\n\n";
  
  print SM "From:    $headers{'from'}\n";
  print SM "To:      $headers{'to'}\n" if ($headers{'to'});
  print SM "Cc:	 $headers{'cc'}\n" if ($headers{'cc'});
  print SM "Subject: $headers{'subject'}\n" if ($headers{'subject'});
  print SM "Message-ID: $headers{'message-id'}\n" if ($headers{'message-id'});
  print SM "Date:    $headers{'date'}\n" if ($headers{'date'});
  print SM "\n

The Email scanner reported the following when it scanned that message:

--- 
$description
---\n";
  close(SM);
}

sub email_recips {
  open(SM,"|$qmailinject -h -f ''")||&tempfail("cannot open $qmailinject for sending virus report - $!");
  print SM "From: \"$V_FROMNAME\" <$V_FROM>\n";
  if (&notify_addr('recips')) {
    &debug("e_r: sending virus report via: $qmailinject to recips address ($recips)");
    print SM "To: $recips\n";
  }
  print SM "Subject: $destring found in received message \"$headers{'subject'}\"\n";
  print SM "X-Tnz-Problem-Type: 40\n";
  print SM "MIME-Version: 1.0\n";
  print SM "Content-type: text/plain\n";
  if ( $descriptive_hdrs ) {
    print SM "${V_HEADER}-Mail-From: $returnpath via $hostname\n";
    print SM "${V_HEADER}-Rcpt-To: $recips\n";
    print SM "$V_HEADER: $VERSION ($SCANINFO $destring Found. Processed in ",tv_interval($start_time,[gettimeofday])," secs)\n\n";
  }
  
  print SM "

Attention: $recips\n";
  
  if (!&is_automated_email) {
    if (&notify_addr('sender')) {
      print SM "
[A message has been sent to the originator, stating there is a virus
in the Email they just sent to you. No further action is required on
your part.]\n";
    }
  } else {
    print SM "

[This message was _not_ sent to the originator address, as that appears to
be a mailing-list or some other automated Email message]\n";
  }
  print SM "\nA $destring was found in an Email message sent to you. 
This Email scanner intercepted it and stopped the entire message
before it reached you.\n";
  print SM "\nThe $destring was reported to be: 

$virus_description

Please contact your I.T support personnel with any queries regarding this 
policy.

The message sent to you had the following envelope:

MAIL FROM: $returnpath
RCPT TO:   $recips 

... and with the following headers:\n\n";
  
  print SM "From:    $headers{'from'}\n";
  print SM "To:      $headers{'to'}\n" if ($headers{'to'});
  print SM "Cc:	 $headers{'cc'}\n" if ($headers{'cc'});
  print SM "Subject: $headers{'subject'}\n" if ($headers{'subject'});
  print SM "Message-ID: $headers{'message-id'}\n" if ($headers{'message-id'});
  print SM "Date:    $headers{'date'}\n" if ($headers{'date'});
  print SM "\n

The Email scanner reported the following when it scanned that message:

--- 
$description
---\n";
  close(SM);
}

sub notify_addr {
  local($addr_type)=@_;
  &debug("n_a: notify_addr (set to $NOTIFY_ADDRS) called with $addr_type");
  if (($NOTIFY_ADDRS =~ /$addr_type/ || $NOTIFY_ADDRS =~ /all/) && ($NOTIFY_ADDRS !~ /none/)) {
    return 1;
  } else {
    return 0;
  }
}

sub unzip_file {
  my($zipfile)=@_;
  &debug("d_m: potential zip archive file found ($zipfile).");
  &debug ("d_m: it is possibly a zip file, run unzip -t $scandir/$file_id/$zipfile");
  $MAYBEZIP=`$unzip_binary -t $scandir/$file_id/$zipfile 2>&1`;
  if ( $? ) {
    &debug("d_m: not a zip ($MAYBEZIP)");
  } else {
    &debug ("d_m: it is a zip file - unpack it!");
    &debug("d_m: run $unzip_binary -oj $scandir/$file_id/$zipfile 2>&1");
    $UNPACK=`$unzip_binary -oj  $scandir/$file_id/$zipfile 2>&1`;
  }
}

sub check_and_grab_uuencoding {
  local ($begin,$perms,$uufile,$uuextension,$uulength,$DD);
  if (/^(begin) ([0-9][0-9][0-9]) (.*)\n$/) {
    &debug("Ooohhhh, a uuencoded attachment!");
    $uuencoded_attachments++;
    $begin=$1;
    $perms=$2;
    $uufile=$3;
    push(@uufile_list, $uufile);
    $uufile=~s/[^0-9a-z\_\-\.]/_/gi;
    $uufile =~ /\.([^\.]+)$/;
    $uuextension=$1;
    #Ensure the file extension isn't too long either...
    $uuextension=substr($uuextension,0,20); 
    $uulength=length($uufile);
    #Ensure the filelength isn't too large!
    if ( $uulength > $MAX_FILE_LENGTH) {
      &debug("uudecode output: gah! filename is > $MAX_FILE_LENGTH (actually $uulength), chopping...");
      $uufile=substr($uufile,0,$MAX_FILE_LENGTH).".".$uuextension;
    }
    if (! -f "$scandir/$file_id/$file_id-$uuencoded_attachments-$uufile.uue") {
      open(UUIN,">$scandir/$file_id/$file_id-$uuencoded_attachments-$uufile.uue")||&tempfail("cannot open $scandir/$file_id/$file_id-$uuencoded_attachments-$uufile.uue - $!");
    } else {
      &tempfail("$scandir/$file_id/$file_id-$uuencoded_attachments-$uufile.uue already exists! - $!");
    }
    print UUIN "$begin $perms $uufile\n";
    print TMPFILE;
    while (<STDIN>) {
      print UUIN;
      print TMPFILE;
      if (/^end/) {
	close(UUIN)||&tempfail("cannot close $scandir/$file_id/$file_id-$uuencoded_attachments-$uufile - $!");
	#uudecode it - toss away the error code - who cares if it's broken...
	&debug("c_a_g_u: $uudecode_binary $uudecode_pipe $scandir/$file_id/$file_id-$uuencoded_attachments-$uufile.uue");
	open(UUOUT,"$uudecode_binary $uudecode_pipe $scandir/$file_id/$file_id-$uuencoded_attachments-$uufile.uue|");
	open(UUFILE,">$scandir/$file_id/$file_id-$uuencoded_attachments-$uufile");
	while (<UUOUT>) {
	  print UUFILE;
	}
	close UUOUT;
	close UUFILE;
#	$DD=`$uudecode_binary -o $scandir/$file_id/$file_id-$uuencoded_attachments-$uufile $scandir/$file_id/$file_id-$uuencoded_attachments-$uufile.uue 2>&1`;
	
	&debug("deleting uuencoded file as we have a decoded version of it now");
	unlink("$scandir/$file_id/$file_id-$uuencoded_attachments-$uufile.uue") if ($DEBUG < 100);
	last;
      }
    }
  }
}


sub log_msg() {};


###############################
#
##  END of standard subroutines
##  Virus-scanner specific subroutines automatically added below by setup.sh
##
###############################

sub uvscan_scanner {
  #MacAfee scanner
  &debug("uvscanner: starting scan of directory \"$scandir/$file_id\"...");
  local($uvscan_verbose)="-v" if ($DEBUG);
  local($start_uvscan_time)=[gettimeofday];
  &debug("run $uvscan_binary  $uvscan_verbose -r --secure --fam --unzip --macro-heuristics  $scandir/$file_id  $extra_file  2>&1");
  $DD=`$uvscan_binary  $uvscan_verbose -r --secure --fam --unzip --macro-heuristics  $scandir/$file_id  $extra_file 2>&1`;
  $uvscan_status=($? >> 8);
  &debug("--output of uvscan was:\n$DD--");
  if ( $uvscan_status > 0 ) {
      $virus_description=$DD;
      &debug("There be a virus! ($virus_description)");
      $virus_found++;
      #$DD =~ s/\n//g;
      $description .= "\n---uvscan results ---\n$DD";
      #	   print "virus \"$virus\"\n";
      $section=$apptype=$save_filename=$filename="";
  }
  local($stop_uvscan_time)=[gettimeofday];
  $uvscan_time = tv_interval ($start_uvscan_time, $stop_uvscan_time);
  &debug("uvscanner: finished scan of dir \"$scandir/$file_id\" in $uvscan_time secs");
}
#########################
## END of scanner definitions
##
#########################
